+-- benchmarks
|   --- README.md: # Performance Benchmarks
+-- docs
|   --- README.md: # API Documentation
+-- examples
|   --- README.md: # Usage Examples
+-- scripts
|   --- README.md: # Build Scripts
+-- src
|   +-- adapters
|   |   \-- geojson
|   |       --- Feature.ts: // Feature.ts import { GeometryCollection } from "./GeometryCollection.js"; import { LineString } from "./LineString.js"; import { MultiLineString } from "./MultiLineString.js"; import { MultiPoint } from "./MultiPoint.js"; import { MultiPolygon } from "./MultiPolygon.js"; import { Point } from "./Point.js"; import { Polygon } from "./Polygon.js"; export interface Feature { type: "Feature"; geometry: GeometryCollection | Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon; properties: { [key: string]: any }; }
|   |       --- FeatureCollection.ts: // FeatureCollection.ts import { Feature } from "./Feature.js"; export interface FeatureCollection { type: "FeatureCollection"; features: Feature[]; }
|   |       --- GeoConversionError.ts: import { Feature } from "./Feature.js"; export class GeoConversionError extends Error { constructor( message: string, public readonly sourceType?: string, public readonly targetType?: string, public readonly cause?: Error ) { super(message); this.name = 'GeoConversionError'; } } // Add validation and error handling to existing classes: export class TypeValidator { static validateFeature(feature: Feature): void { if (!feature.type || feature.type !== 'Feature') { throw new GeoConversionError('Invalid Feature type'); } if (!feature.geometry) { throw new GeoConversionError('Missing geometry'); } // Add more validation } static validateGeometry(geometry: any): void { // Geometry validation } }
|   |       --- GeoConverter.ts: import { Feature } from "./Feature.js"; import { GeoReader } from "./GeoReader.js"; import { GeoWriter } from "./GeoWriter.js"; export class GeoConverter { static toGeoJSON(input: any): Feature | Feature[] { if (Array.isArray(input)) { return GeoWriter.writeCollection(input); } return GeoWriter.write(input); } static fromGeoJSON(input: Feature | Feature[]): any { if (Array.isArray(input)) { return GeoReader.readCollection(input); } return GeoReader.read(input); } } /* Example usage: const feature = GeoConverter.toGeoJSON(greatCircle); const circle = GeoConverter.fromGeoJSON(feature); */
|   |       --- GeoReader.ts: import { Feature } from "./Feature.js"; import { GeoRegistry } from "./GeoRegistry.js"; export class GeoReader { static read(feature: Feature): any { return GeoRegistry.reverse(feature); } static readCollection(collection: Feature[]): any[] { return collection.map(f => GeoReader.read(f)); } }
|   |       --- GeoRegistry.ts: import { Feature } from "./Feature.js"; import { TypeConverter } from "./TypeConverter.js"; import { TypeMapping } from "./TypeMapping.js"; export class GeoRegistry { private static readonly converters = new Map<string, TypeConverter>(); static register(type: any, converter: TypeConverter): void { const geoType = TypeMapping.get(type); if (!geoType) throw new Error(`No mapping for type ${type.name}`); GeoRegistry.converters.set(type.name, converter); } static convert(source: any, target: string): any { const converter = GeoRegistry.converters.get(source.constructor.name); if (!converter) throw new Error(`No converter for ${source.constructor.name}`); return TypeConverter.toFeature(source); } static reverse(feature: Feature): any { return TypeConverter.fromFeature(feature); } }
|   |       --- GeoWriter.ts: import { Feature } from "./Feature.js"; import { GeoRegistry } from "./GeoRegistry.js"; export class GeoWriter { static write(source: any): Feature { return GeoRegistry.convert(source, 'Feature'); } static writeCollection(sources: any[]): Feature[] { return sources.map(s => GeoWriter.write(s)); } }
|   |       --- GeometryCollection.ts: import { LineString } from "./LineString.js"; import { MultiLineString } from "./MultiLineString.js"; import { MultiPoint } from "./MultiPoint.js"; import { MultiPolygon } from "./MultiPolygon.js"; import { Point } from "./Point.js"; import { Polygon } from "./Polygon.js"; // GeometryCollection.ts export interface GeometryCollection { type: "GeometryCollection"; geometries: Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection>; }
|   |       --- LineString.ts: import { Point } from "./Point.js"; export interface LineString { type: "LineString"; coordinates: Point['coordinates'][]; }
|   |       --- MultiLineString.ts: import { LineString } from "./LineString.js"; export interface MultiLineString { type: "MultiLineString"; coordinates: LineString['coordinates'][]; }
|   |       --- MultiPoint.ts: import { Point } from "./Point.js"; export interface MultiPoint { type: "MultiPoint"; coordinates: Point['coordinates'][]; }
|   |       --- MultiPolygon.ts: import { Polygon } from "./Polygon.js"; export interface MultiPolygon { type: "MultiPolygon"; coordinates: Polygon['coordinates'][]; }
|   |       --- Point.ts: // Point.ts export interface Point { type: "Point"; coordinates: [number, number]; // Longitude, Latitude }
|   |       --- Polygon.ts: import { LineString } from "./LineString.js"; export interface Polygon { type: "Polygon"; coordinates: LineString['coordinates'][]; // Array of linear rings }
|   |       --- TypeConverter.ts: import { Coordinate } from "../../core/models/Coordinate.js"; import { Distance } from "../../core/models/Distance.js"; import { GreatCircle } from "../../core/models/GreatCircle.js"; import { SmallCircle } from "../../core/models/SmallCircle.js"; import { Triangle } from "../../core/models/Triangle.js"; import { Feature } from "./Feature.js"; import { TypeMapping } from "./TypeMapping.js"; export class TypeConverter { static toFeature(source: any): Feature { const type = TypeMapping.get(source.constructor); if (!type) { throw new Error(`No mapping for type ${source.constructor.name}`); } try { switch(type.type) { case "Point": if (source instanceof Coordinate) { return { type: "Feature", geometry: { type: "Point", coordinates: [source.longitude, source.latitude] }, properties: {} }; } return { type: "Feature", geometry: { type: "Point", coordinates: [0, 0] // Default return }, properties: {} }; case "LineString": if (source instanceof GreatCircle) { const points = source.generatePoints({ minPoints: 100 }); return { type: "Feature", geometry: { type: "LineString", coordinates: points.map((p: Coordinate) => [p.longitude, p.latitude]) }, properties: { distance: source.distance().inMeters() } }; } return { type: "Feature", geometry: { type: "LineString", coordinates: [] }, properties: {} }; case "Polygon": if (source instanceof SmallCircle) { const points = source.generatePoints(100); points.push(points[0]); return { type: "Feature", geometry: { type: "Polygon", coordinates: [points.map((p: Coordinate) => [p.longitude, p.latitude])] }, properties: { radius: source.getRadius().inMeters(), area: source.area() } }; } if (source instanceof Triangle) { const vertices = source.vertices; const allVertices = [...vertices, vertices[0]]; return { type: "Feature", geometry: { type: "Polygon", coordinates: [allVertices.map((v: Coordinate) => [v.longitude, v.latitude])] }, properties: { area: source.area(), perimeter: source.perimeter().inMeters() } }; } return { type: "Feature", geometry: { type: "Polygon", coordinates: [[]] }, properties: {} }; } throw new Error(`Conversion not implemented for ${type.type}`); } catch (exception: any) { console.log('Conversion error:', exception); return { type: "Feature", geometry: { type: "Point", coordinates: [0, 0] }, properties: {} }; } } static fromFeature(feature: Feature): any { if (!feature.geometry) { throw new Error('Invalid Feature: missing geometry'); } try { switch(feature.geometry.type) { case "Point": const [lon, lat] = feature.geometry.coordinates; return Coordinate.at(lat, lon); case "LineString": const coords = feature.geometry.coordinates; if (coords.length < 2) { throw new Error('Invalid LineString: needs at least 2 points'); } const startCoord = Coordinate.at(coords[0][1], coords[0][0]); const endCoord = Coordinate.at(coords[coords.length - 1][1], coords[coords.length - 1][0]); return GreatCircle.from(startCoord).to(endCoord); case "Polygon": const vertices = feature.geometry.coordinates[0]; if (vertices.length === 4 && feature.properties?.area) { const points = vertices.slice(0, -1).map(([lon, lat]) => Coordinate.at(lat, lon)); return Triangle.from(points[0]).to(points[1]).and(points[2]); } else if (feature.properties?.radius) { const center = Coordinate.at(vertices[0][1], vertices[0][0]); const radius = new Distance(feature.properties.radius.inMeters()); return SmallCircle.withCenter(center).radius(radius); } throw new Error('Unsupported Polygon type'); } throw new Error(`Conversion not implemented for geometry type ${feature.geometry.type}`); } catch (exception: any) { console.log('Conversion error:', exception); return null; } } }
|   |       --- TypeMapping.ts: import { Coordinate } from "../../core/models/Coordinate.js"; import { GreatCircle } from "../../core/models/GreatCircle.js"; import { Point } from "../../core/models/Point.js"; import { SmallCircle } from "../../core/models/SmallCircle.js"; import { Triangle } from "../../core/models/Triangle.js"; export interface GeoType { type: string; coordinates: any; } export class TypeMapping { private static readonly map = new Map<any, GeoType>([ [Coordinate, { type: "Point", coordinates: [] }], [Point, { type: "Point", coordinates: [] }], [GreatCircle, { type: "LineString", coordinates: [] }], [SmallCircle, { type: "Polygon", coordinates: [] }], [Triangle, { type: "Polygon", coordinates: [] }] ]); static get(type: any): GeoType | null { const mapping = TypeMapping.map.get(type); if (!mapping) { return null; } return { ...mapping }; // Return a copy to prevent modification } static set(sourceType: any, geoType: GeoType): void { TypeMapping.map.set(sourceType, { ...geoType }); // Store a copy } static hasMapping(type: any): boolean { return TypeMapping.map.has(type); } static getAllMappings(): Map<any, GeoType> { return new Map(TypeMapping.map); // Return a copy } static getSourceTypeForGeoType(geoType: string): any[] { const results: any[] = []; TypeMapping.map.forEach((value, key) => { if (value.type === geoType) { results.push(key); } }); return results; } static registerMapping(sourceType: any, geoType: GeoType): void { if (!geoType.type || !["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"].includes(geoType.type)) { throw new Error(`Invalid GeoJSON type: ${geoType.type}`); } TypeMapping.set(sourceType, geoType); } }
|   +-- core
|   |   +-- coordinate
|   |   |   --- CoordinateSystem.ts: import { Coordinate } from "../models/Coordinate.js"; import { Point } from "../models/Point.js"; export class CoordinateSystem { static fromCoordinate(coord: Coordinate): Point { const lat = coord.latitude * (Math.PI / 180); const lon = coord.longitude * (Math.PI / 180); return Point.at(lat, lon); } static fromPoint(point: Point): Coordinate { const lat = point.X * (180 / Math.PI); const lon = point.Y * (180 / Math.PI); return Coordinate.at(lat, lon); } }
|   |   +-- errors
|   |   |   --- GeoConversionError.ts: import { GeoError } from "./GeoError.js"; export class GeoConversionError extends GeoError { constructor( message: string, public readonly sourceType: string, public readonly targetType: string, cause?: Error ) { super(message, cause); } }
|   |   |   --- GeoError.ts: export abstract class GeoError extends Error { constructor( message: string, public readonly cause?: Error ) { super(message); this.name = this.constructor.name; } }
|   |   |   --- GeoValidationError.ts: import { GeoError } from "./GeoError.js"; export class GeoValidationError extends GeoError { constructor( message: string, public readonly validationType: string, public readonly invalidValue: any, cause?: Error ) { super(message, cause); } }
|   |   |   --- index.ts: export * from './GeoError.js'; export * from './GeoConversionError.js'; export * from './GeoValidationError.js';
|   |   \-- models
|   |       --- Angle.js: "use strict"; exports.__esModule = true; exports.Angle = void 0; // This file defines the Angle class. // Angle.ts var Angle = /** @class */ (function () { function Angle(degrees) { this.degrees = degrees; } // Convert angle to radians Angle.prototype.toRadians = function () { return this.degrees * (Math.PI / 180); }; // Normalize the angle to be within the range [0, 360] Angle.prototype.normalize = function () { return ((this.degrees % 360) + 360) % 360; }; // Optional: Add another angle Angle.prototype.add = function (angle) { return new Angle(this.normalize() + angle.normalize()); }; // Optional: Subtract another angle Angle.prototype.subtract = function (angle) { return new Angle(this.normalize() - angle.normalize()); }; // Optional: toString method for easy debugging Angle.prototype.toString = function () { return "Angle(".concat(this.degrees, " degrees)"); }; return Angle; }()); exports.Angle = Angle;
|   |       --- Angle.ts: import { Arc } from "./Arc.js"; import { Distance } from './Distance.js'; // Angle.ts export class Angle { constructor(public readonly degrees: number) {} // Add toRadians method toRadians(): number { return this.degrees * (Math.PI / 180); } normalize(): number { return ((this.degrees % 360) + 360) % 360; } // Fix overload signatures static defineBy(a: Arc, b: Arc, c: Arc | Angle, aLength?: Distance, bLength?: Distance, cLength?: Distance): Angle { if (!aLength || !bLength || !cLength) { throw new Error("Length parameters are required"); } if (c instanceof Angle) { // Law of Sines case const sinA = Math.sin(c.toRadians()); const calculatedAngleDegrees = Math.asin( (aLength.inMeters() * Math.sin(c.toRadians())) / bLength.inMeters() ) * (180 / Math.PI); return new Angle(calculatedAngleDegrees); } else { // Law of Cosines case const cosC = ( Math.pow(aLength.inMeters(), 2) + Math.pow(bLength.inMeters(), 2) - Math.pow(cLength.inMeters(), 2) ) / (2 * aLength.inMeters() * bLength.inMeters()); const calculatedAngleDegrees = Math.acos(cosC) * (180 / Math.PI); return new Angle(calculatedAngleDegrees); } } toString(): string { return `Angle(${this.degrees} degrees)`; } }
|   |       --- Arc.js: "use strict"; exports.__esModule = true; exports.Arc = void 0; // This file defines the Arc class. // Arc.ts var Coordinate_1 = require("./Coordinate"); var Arc = /** @class */ (function () { function Arc(start, end, circleRadius) { this.start = start; this.end = end; this.circleRadius = circleRadius; // This might be the Earth's radius or other, depending on the small circle } // Calculate the length of the arc Arc.prototype.calculateLength = function () { // Placeholder for actual calculation // This would involve more complex geometry depending on whether it's a great circle or small circle return 0; }; // Calculate any intermediary point on the arc Arc.prototype.findPointAtFraction = function (fraction) { // This method would compute a point at a given fraction between start and end // Placeholder for actual calculation return new Coordinate_1.Coordinate(0, 0); // Dummy return }; return Arc; }()); exports.Arc = Arc;
|   |       --- Arc.ts: import { Angle } from "./Angle.js"; import { Coordinate } from "./Coordinate.js"; import { Distance } from "./Distance.js"; import { Sphere } from "./Sphere.js"; import { Point } from "./Point.js"; import { CoordinateSystem } from "../coordinate/CoordinateSystem.js"; export class Arc { private constructor( private readonly sphereRadius: Distance, private readonly centralAngle?: Angle, private readonly start?: Coordinate, private readonly end?: Coordinate ) { } static onSphere( sphereRadius: Distance = Sphere.getRadius(), centralAngle?: Angle ): Arc { return new Arc(sphereRadius, centralAngle); } static fromPoints( start: Coordinate, end: Coordinate, sphereRadius: Distance = Sphere.getRadius() ): Arc { return new Arc(sphereRadius, undefined, start, end); } length(): Distance { if (this.start && this.end) { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); // Calculate central angle using haversine formula const dLat = endPoint.Y - startPoint.Y; const dLon = endPoint.X - startPoint.X; const a = Math.sin(dLat / 2) ** 2 + Math.cos(startPoint.Y) * Math.cos(endPoint.Y) * Math.sin(dLon / 2) ** 2; const centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return new Distance(this.sphereRadius.inMeters() * centralAngle); } else if (this.centralAngle) { return new Distance(this.sphereRadius.inMeters() * this.centralAngle.toRadians()); } else { return new Distance(2 * Math.PI * this.sphereRadius.inMeters()); } } interpolate(fraction: number): Coordinate | undefined { if (fraction < 0 || fraction > 1) { throw new Error('Fraction must be between 0 and 1'); } if (this.start && this.end) { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const d = this.length().inMeters() / this.sphereRadius.inMeters(); const A = Math.sin((1 - fraction) * d) / Math.sin(d); const B = Math.sin(fraction * d) / Math.sin(d); const x = A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) + B * Math.cos(endPoint.Y) * Math.cos(endPoint.X); const y = A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) + B * Math.cos(endPoint.Y) * Math.sin(endPoint.X); const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y); const lat3 = Math.atan2(z, Math.sqrt(x * x + y * y)); const lon3 = Math.atan2(y, x); return CoordinateSystem.fromPoint(Point.at(lon3, lat3)); } return undefined; } }
|   |       --- Azimuth.js: "use strict"; exports.__esModule = true; exports.Azimuth = void 0; var Azimuth = /** @class */ (function () { function Azimuth(start, end) { this.start = start; this.end = end; } // Calculate the azimuth angle in degrees from north Azimuth.prototype.calculateAzimuth = function () { var lat1 = this.start.toRadians().latRadians; var lon1 = this.start.toRadians().lonRadians; var lat2 = this.end.toRadians().latRadians; var lon2 = this.end.toRadians().lonRadians; var dLon = lon2 - lon1; var y = Math.sin(dLon) * Math.cos(lat2); var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon); var angle = Math.atan2(y, x); return (angle * (180 / Math.PI) + 360) % 360; // Normalize angle to positive degrees }; return Azimuth; }()); exports.Azimuth = Azimuth;
|   |       --- Azimuth.ts: import { Coordinate } from './Coordinate.js'; import { Angle } from './Angle.js'; import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; export class Azimuth { private constructor( private readonly start: Coordinate, private readonly end: Coordinate ) {} static from = (start: Coordinate) => ({ to: (end: Coordinate) => new Azimuth(start, end) }); forward = (): Angle => { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const dLon = endPoint.X - startPoint.X; const y = Math.sin(dLon) * Math.cos(endPoint.Y); const x = Math.cos(startPoint.Y) * Math.sin(endPoint.Y) - Math.sin(startPoint.Y) * Math.cos(endPoint.Y) * Math.cos(dLon); const azimuthRadians = Math.atan2(y, x); const azimuthDegrees = (azimuthRadians * (180 / Math.PI) + 360) % 360; return new Angle(azimuthDegrees); }; reverse = (): Angle => { const forward = this.forward().degrees; return new Angle((forward + 180) % 360); }; toString = (): string => `Azimuth(${this.start} → ${this.end})`; }
|   |       --- Bearing.js: "use strict"; exports.__esModule = true; exports.Bearing = void 0; var Azimuth_1 = require("./Azimuth"); var Bearing = /** @class */ (function () { function Bearing(start, end) { this.start = start; this.end = end; } // Calculate the initial bearing using azimuth calculations Bearing.prototype.calculateInitialBearing = function () { var azimuth = new Azimuth_1.Azimuth(this.start, this.end); return azimuth.calculateAzimuth(); }; // Calculate the final bearing by reversing start and end Bearing.prototype.calculateFinalBearing = function () { var azimuth = new Azimuth_1.Azimuth(this.end, this.start); return (azimuth.calculateAzimuth() + 180) % 360; // Adjust by 180 degrees to get the opposite direction }; return Bearing; }()); exports.Bearing = Bearing;
|   |       --- Bearing.ts: import { Coordinate } from './Coordinate.js'; import { Angle } from './Angle.js'; import { Azimuth } from './Azimuth.js'; export class Bearing { private constructor( private readonly start: Coordinate, private readonly end: Coordinate ) {} static from = (start: Coordinate) => ({ to: (end: Coordinate) => new Bearing(start, end) }); initial = (): Angle => Azimuth.from(this.start).to(this.end).forward(); final = (): Angle => Azimuth.from(this.start).to(this.end).reverse(); toString = (): string => `Bearing(${this.start} → ${this.end})`; }
|   |       --- Coordinate.js: "use strict"; exports.__esModule = true; exports.Coordinate = void 0; // Coordinate.ts var Coordinate = /** @class */ (function () { function Coordinate(latitude, longitude, altitude) { this.latitude = latitude; this.longitude = longitude; this.altitude = altitude; } // Convert latitude and longitude from degrees to radians Coordinate.prototype.toRadians = function () { return { latRadians: this.latitude * (Math.PI / 180), lonRadians: this.longitude * (Math.PI / 180) }; }; // Optional: toString method for easy debugging Coordinate.prototype.toString = function () { return "Coordinate(".concat(this.latitude, ", ").concat(this.longitude).concat(this.altitude ? ', ' + this.altitude : '', ")"); }; return Coordinate; }()); exports.Coordinate = Coordinate;
|   |       --- Coordinate.ts: export class Coordinate { public constructor( private readonly lat: number, private readonly lon: number, private readonly alt?: number ) { if (lat < -90 || lat > 90) { throw new Error('Latitude must be between -90 and 90 degrees'); } if (lon < -180 || lon > 180) { throw new Error('Longitude must be between -180 and 180 degrees'); } } static at = (lat: number, lon: number, alt?: number) => new Coordinate(lat, lon, alt); get latitude(): number { return this.lat; } get longitude(): number { return this.lon; } get altitude(): number | undefined { return this.alt; } equals = (other: Coordinate): boolean => this.lat === other.lat && this.lon === other.lon && this.alt === other.alt; toString = (): string => `(${this.lat}°, ${this.lon}°${this.alt ? `, ${this.alt}m` : ''})`; }
|   |       --- Distance.ts: // Angle.ts remains the same... // Distance.ts export class Distance { private static readonly METERS_TO_NM = 0.000539957; constructor(private readonly meters: number) {} inMeters(): number { return this.meters; } inKilometers(): number { return this.meters / 1000; } inCentimeters(): number { return this.meters * 100; } inMiles(): number { return this.meters * 0.000621371; } inFeet(): number { return this.meters * 3.28084; } inYards(): number { return this.meters * 1.09361; } inNauticalMiles(): number { return this.meters * Distance.METERS_TO_NM; } static fromMeters(meters: number): Distance { return new Distance(meters); } static fromKilometers(km: number): Distance { return new Distance(km * 1000); } static fromMiles(miles: number): Distance { return new Distance(miles / 0.000621371); } static fromNauticalMiles(nm: number): Distance { return new Distance(nm / Distance.METERS_TO_NM); } static fromFeet(feet: number): Distance { return new Distance(feet / 3.28084); } toString(): string { return `${this.inKilometers().toFixed(2)} km`; } toFormat(unit: 'km' | 'mi' | 'nm' | 'ft' | 'm'): string { switch(unit) { case 'km': return `${this.inKilometers().toFixed(2)} km`; case 'mi': return `${this.inMiles().toFixed(2)} mi`; case 'nm': return `${this.inNauticalMiles().toFixed(2)} nm`; case 'ft': return `${this.inFeet().toFixed(2)} ft`; case 'm': return `${this.inMeters().toFixed(2)} m`; } } }
|   |       --- GreatCircle.js: "use strict"; exports.__esModule = true; exports.GreatCircle = void 0; // This file defines the GreatCircle class. // GreatCircle.ts var Coordinate_1 = require("./Coordinate"); var GreatCircle = /** @class */ (function () { function GreatCircle(start, end) { this.start = start; this.end = end; } // Calculate the distance along the great circle using the haversine formula GreatCircle.prototype.calculateDistance = function () { var radius = 6371; // Earth's radius in kilometers var lat1 = this.start.toRadians().latRadians; var lon1 = this.start.toRadians().lonRadians; var lat2 = this.end.toRadians().latRadians; var lon2 = this.end.toRadians().lonRadians; var dLat = lat2 - lat1; var dLon = lon2 - lon1; var a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(dLon / 2), 2); var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return radius * c; }; // Calculate the midpoint along the great circle path GreatCircle.prototype.findMidpoint = function () { var lat1 = this.start.toRadians().latRadians; var lon1 = this.start.toRadians().lonRadians; var lat2 = this.end.toRadians().latRadians; var lon2 = this.end.toRadians().lonRadians; var Bx = Math.cos(lat2) * Math.cos(lon2 - lon1); var By = Math.cos(lat2) * Math.sin(lon2 - lon1); var lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2), Math.sqrt(Math.pow((Math.cos(lat1) + Bx), 2) + Math.pow(By, 2))); var lon3 = lon1 + Math.atan2(By, Math.cos(lat1) + Bx); return new Coordinate_1.Coordinate(lat3 * (180 / Math.PI), lon3 * (180 / Math.PI)); }; return GreatCircle; }()); exports.GreatCircle = GreatCircle;
|   |       --- GreatCircle.ts: import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; import { Azimuth } from './Azimuth.js'; import { Coordinate } from './Coordinate.js'; import { Distance } from './Distance.js'; import { Point } from './Point.js'; import { Sphere } from './Sphere.js'; interface PointGenerationOptions { spacing?: Distance; minPoints?: number; maxPoints?: number; } export class GreatCircle { public constructor( private readonly start: Coordinate, private readonly end: Coordinate, private readonly sphereRadius: Distance = Sphere.getRadius() ) {} static from(start: Coordinate) { return { to: (end: Coordinate) => new GreatCircle(start, end) }; } withSphere = (sphereRadius: Distance): GreatCircle => new GreatCircle(this.start, this.end, sphereRadius); distance = (): Distance => { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const dLat = endPoint.Y - startPoint.Y; const dLon = endPoint.X - startPoint.X; const a = Math.sin(dLat/2) ** 2 + Math.cos(startPoint.Y) * Math.cos(endPoint.Y) * Math.sin(dLon/2) ** 2; const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return new Distance(this.sphereRadius.inMeters() * c); }; interpolate = (fraction: number): Coordinate | undefined => { if (fraction < 0 || fraction > 1) { throw new Error('Fraction must be between 0 and 1'); } const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const d = this.distance().inMeters() / this.sphereRadius.inMeters(); const A = Math.sin((1 - fraction) * d) / Math.sin(d); const B = Math.sin(fraction * d) / Math.sin(d); const x = A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) + B * Math.cos(endPoint.Y) * Math.cos(endPoint.X); const y = A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) + B * Math.cos(endPoint.Y) * Math.sin(endPoint.X); const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y); const lat = Math.atan2(z, Math.sqrt(x * x + y * y)); const lon = Math.atan2(y, x); return CoordinateSystem.fromPoint(Point.at(lon, lat)); }; // Rest of the methods remain unchanged generatePoints = (options: PointGenerationOptions): Coordinate[] => { const totalDistance = this.distance(); let numPoints: number; if (options.spacing) { numPoints = Math.ceil(totalDistance.inMeters() / options.spacing.inMeters()); } else if (options.minPoints) { numPoints = options.minPoints; } else { numPoints = 100; } if (options.maxPoints) { numPoints = Math.min(numPoints, options.maxPoints); } const points: Coordinate[] = []; for (let i = 0; i <= numPoints; i++) { const fraction = i / numPoints; const point = this.interpolate(fraction); if (point) points.push(point); } return points; }; extend = (distance: Distance): GreatCircle => { const bearing = Azimuth.from(this.start).to(this.end).forward(); const endPoint = this.interpolate(1 + (distance.inMeters() / this.distance().inMeters())); return endPoint ? GreatCircle.from(this.start).to(endPoint) : this; }; midpoint = (): Coordinate => this.interpolate(0.5)!; toString = (): string => `GreatCircle(${this.start} → ${this.end})`; }
|   |       --- Point.ts: import { Coordinate } from "./Coordinate.js"; export class Point { private constructor( private readonly x: number, private readonly y: number, private readonly z?: number ) {} static at = (x: number, y: number, z?: number) => new Point(x, y, z); get X(): number { return this.x; } get Y(): number { return this.y; } get Z(): number | undefined { return this.z; } equals = (other: Point): boolean => this.x === other.x && this.y === other.y && this.z === other.z; toString = (): string => `Point(${this.x}, ${this.y}${this.z ? `, ${this.z}` : ''})`; }
|   |       --- Polygon.ts: import { CoordinateSystem } from "../coordinate/CoordinateSystem.js"; import { Coordinate } from "./Coordinate.js"; import { Point } from "./Point.js"; export class Polygon { constructor(private readonly vertices: Coordinate[]) { if (vertices.length < 3) { throw new Error("Polygon must have at least 3 vertices"); } } // Coordinate-based constructor static fromCoordinates = (coords: Coordinate[]): Polygon => new Polygon(coords); // Point-based constructor static fromPoints = (points: Point[]): Polygon => { const coords = points.map(p => CoordinateSystem.fromPoint(p) ); return new Polygon(coords); }; getVertices = (): Coordinate[] => this.vertices; rewind = (): Polygon => { const points = this.vertices.map(c => CoordinateSystem.fromCoordinate(c)); const fixed = this.ensureProperWindingPoints(points); return Polygon.fromPoints(fixed); }; private ensureProperWindingPoints = (points: Point[]): Point[] => { // Calculate the signed area let area = 0; for (let i = 0; i < points.length; i++) { const j = (i + 1) % points.length; area += points[i].X * points[j].Y - points[j].X * points[i].Y; } // If area is negative (clockwise), reverse the points if (area > 0) { return [...points].reverse(); } return points; }; toString = (): string => `Polygon(${this.vertices.length} vertices)`; }
|   |       --- SmallCircle.js: "use strict"; exports.__esModule = true; exports.SmallCircle = void 0; var SmallCircle = /** @class */ (function () { function SmallCircle(center, angularRadius) { this.center = center; this.angularRadius = angularRadius; } // Calculate the circumference of the small circle SmallCircle.prototype.circumference = function () { var earthRadius = 6371; // Earth's average radius in kilometers var angularRadiusRadians = this.angularRadius * Math.PI / 180; // Convert angular radius to radians return 2 * Math.PI * earthRadius * Math.sin(angularRadiusRadians); }; // Calculate the area of the small circle SmallCircle.prototype.area = function () { var earthRadius = 6371; // Earth's radius in kilometers var angularRadiusRadians = this.angularRadius * Math.PI / 180; // Convert angular radius to radians return 2 * Math.PI * earthRadius * earthRadius * (1 - Math.cos(angularRadiusRadians)); }; // Calculate the angular diameter of the small circle SmallCircle.prototype.angularDiameter = function () { return 2 * this.angularRadius; }; // Optional: Convert the small circle definition to a string for easy debugging SmallCircle.prototype.toString = function () { return "SmallCircle(Center: ".concat(this.center.toString(), ", Angular Radius: ").concat(this.angularRadius, " degrees)"); }; return SmallCircle; }()); exports.SmallCircle = SmallCircle;
|   |       --- SmallCircle.ts: import { Coordinate } from './Coordinate.js'; import { Point } from './Point.js'; import { Distance } from './Distance.js'; import { Sphere } from './Sphere.js'; import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; export class SmallCircle { private readonly centerPoint: Point; private constructor( private readonly center: Coordinate, private readonly circleRadius: Distance, private readonly sphereRadius: Distance = Sphere.getRadius() ) { this.centerPoint = CoordinateSystem.fromCoordinate(center); } static withCenter = (center: Coordinate) => ({ radius: (radius: Distance) => new SmallCircle(center, radius) }); withSphere = (sphere: Sphere): SmallCircle => new SmallCircle(this.center, this.circleRadius, Sphere.getRadius()); circumference = (): Distance => { const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters(); return new Distance(2 * Math.PI * this.sphereRadius.inMeters() * Math.sin(angularRadius)); }; area = (): number => { const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters(); const sphereRadiusKm = this.sphereRadius.inMeters() / 1000; return 2 * Math.PI * Math.pow(sphereRadiusKm, 2) * (1 - Math.cos(angularRadius)); }; generatePoints = (numPoints: number = 100): Coordinate[] => { const points: Coordinate[] = []; const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters(); for (let i = 0; i < numPoints; i++) { const angle = (2 * Math.PI * i) / numPoints; const latRad = Math.asin( Math.sin(this.centerPoint.Y) * Math.cos(angularRadius) + Math.cos(this.centerPoint.Y) * Math.sin(angularRadius) * Math.cos(angle) ); const lonRad = this.centerPoint.X + Math.atan2( Math.sin(angle) * Math.sin(angularRadius) * Math.cos(this.centerPoint.Y), Math.cos(angularRadius) - Math.sin(this.centerPoint.Y) * Math.sin(latRad) ); points.push(CoordinateSystem.fromPoint(Point.at(lonRad, latRad))); } return points; }; getCenter = (): Coordinate => this.center; getRadius = (): Distance => this.circleRadius; toString = (): string => `SmallCircle(center: ${this.center}, radius: ${this.circleRadius})`; }
|   |       --- Sphere.js: "use strict"; exports.__esModule = true; exports.Sphere = void 0; // Sphere.ts var Sphere = /** @class */ (function () { function Sphere(radius) { if (radius === void 0) { radius = 6371; } this.radius = radius; } // Method to calculate the surface area of the sphere Sphere.prototype.surfaceArea = function () { return 4 * Math.PI * Math.pow(this.radius, 2); }; // Method to calculate the volume of the sphere Sphere.prototype.volume = function () { return (4 / 3) * Math.PI * Math.pow(this.radius, 3); }; return Sphere; }()); exports.Sphere = Sphere;
|   |       --- Sphere.ts: import { Distance } from "./Distance.js"; export class Sphere { private static readonly DEFAULT_RADIUS = Distance.fromKilometers(6371); static getRadius = (radius?: Distance): Distance => radius ?? Sphere.DEFAULT_RADIUS; static surfaceAreaFromRadius = (radius: Distance): number => 4 * Math.PI * Math.pow(radius.inMeters() / 1000, 2); static volumeFromRadius = (radius: Distance): number => (4/3) * Math.PI * Math.pow(radius.inMeters() / 1000, 3); } // // Usage: // const radius = Sphere.getRadius(); // Default 6371km // const customRadius = Sphere.getRadius(Distance.fromMiles(4000));
|   |       --- SphericalTrigonometry.ts: import { Angle } from "./Angle.js"; import { Distance } from "./Distance.js"; // For Law of Sines/Cosines calculations, we should use Distance directly export class SphericalTrigonometry { static lawOfCosines(arcA: Distance, arcB: Distance, angleC: Angle): Distance { const a = arcA.inMeters(); const b = arcB.inMeters(); const C = angleC.toRadians(); const c = Math.sqrt( Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b * Math.cos(C) ); return new Distance(c); } static lawOfSines(angleA: Angle, angleB: Angle, arcC: Distance): Distance { const A = angleA.toRadians(); const B = angleB.toRadians(); const C = Math.PI - (A + B); const c = arcC.inMeters(); const a = Math.abs(c * Math.sin(A) / Math.sin(C)); return new Distance(a); } }
|   |       --- Triangle.js: "use strict"; exports.__esModule = true; exports.Triangle = void 0; var Triangle = /** @class */ (function () { function Triangle(vertexA, vertexB, vertexC, sphere) { this.vertices = [vertexA, vertexB, vertexC]; this.sphere = sphere; } // Calculate the area of the spherical triangle using the spherical excess formula Triangle.prototype.calculateArea = function () { var radius = this.sphere.radius; var A = this.angleBetween(this.vertices[1], this.vertices[2]); var B = this.angleBetween(this.vertices[0], this.vertices[2]); var C = this.angleBetween(this.vertices[0], this.vertices[1]); var sphericalExcess = (A + B + C) - Math.PI; return (sphericalExcess * radius * radius); }; // Calculate the perimeter of the spherical triangle Triangle.prototype.calculatePerimeter = function () { var a = this.sphericalDistance(this.vertices[1], this.vertices[2]); var b = this.sphericalDistance(this.vertices[0], this.vertices[2]); var c = this.sphericalDistance(this.vertices[0], this.vertices[1]); return a + b + c; }; // Calculate the spherical distance between two coordinates on the surface of the sphere Triangle.prototype.sphericalDistance = function (coordA, coordB) { var lat1 = coordA.toRadians().latRadians; var lon1 = coordA.toRadians().lonRadians; var lat2 = coordB.toRadians().latRadians; var lon2 = coordB.toRadians().lonRadians; // Using the haversine formula to calculate spherical distance var dLat = lat2 - lat1; var dLon = lon2 - lon1; var a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(dLon / 2), 2); var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return this.sphere.radius * c; }; // Calculate the angle between two vertices, opposite the third vertex Triangle.prototype.angleBetween = function (coordA, coordB) { var a = this.sphericalDistance(coordA, coordB); var b = this.sphericalDistance(this.vertices[0], coordB); var c = this.sphericalDistance(this.vertices[0], coordA); // Using the spherical law of cosines to calculate the angle at the first vertex return Math.acos((Math.cos(a / this.sphere.radius) - Math.cos(b / this.sphere.radius) * Math.cos(c / this.sphere.radius)) / (Math.sin(b / this.sphere.radius) * Math.sin(c / this.sphere.radius))); }; return Triangle; }()); exports.Triangle = Triangle;
|   |       --- Triangle.ts: import { Coordinate } from './Coordinate.js'; import { Point } from './Point.js'; import { Sphere } from './Sphere.js'; import { Distance } from './Distance.js'; import { Angle } from './Angle.js'; import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; export class Triangle { private readonly points: Point[]; public constructor( private readonly triangleVertices: [Coordinate, Coordinate, Coordinate], private readonly sphereRadius: Distance = Sphere.getRadius() ) { this.points = triangleVertices.map(v => CoordinateSystem.fromCoordinate(v)); } static from = (a: Coordinate) => ({ to: (b: Coordinate) => ({ and: (c: Coordinate) => new Triangle([a, b, c]) }) }); withSphere = (sphere: Sphere): Triangle => new Triangle(this.triangleVertices, Sphere.getRadius()); area = (): number => { const angles = this.angles(); const sphericalExcess = angles.reduce((sum, angle) => sum + angle.degrees, 0) - 180; return sphericalExcess * (Math.PI / 180) * Math.pow(this.sphereRadius.inMeters() / 1000, 2); }; perimeter = (): Distance => { const sides = this.sides(); const totalMeters = sides.reduce((sum, side) => sum + side.inMeters(), 0); return new Distance(totalMeters); }; angles = (): [Angle, Angle, Angle] => { return [0, 1, 2].map(i => { const p1 = this.points[i]; const p2 = this.points[(i + 1) % 3]; const p3 = this.points[(i + 2) % 3]; const v1 = this.vectorBetween(p1, p2); const v2 = this.vectorBetween(p1, p3); const angle = this.angleBetweenVectors(v1, v2); return new Angle(angle * (180 / Math.PI)); }) as [Angle, Angle, Angle]; }; sides = (): [Distance, Distance, Distance] => { return [0, 1, 2].map(i => { const start = this.points[i]; const end = this.points[(i + 1) % 3]; return this.sphericalDistance(start, end); }) as [Distance, Distance, Distance]; }; private vectorBetween = (p1: Point, p2: Point): [number, number, number] => { // Points are already in radians since we converted them in constructor const x = Math.cos(p2.Y) * Math.cos(p2.X) - Math.cos(p1.Y) * Math.cos(p1.X); const y = Math.cos(p2.Y) * Math.sin(p2.X) - Math.cos(p1.Y) * Math.sin(p1.X); const z = Math.sin(p2.Y) - Math.sin(p1.Y); return [x, y, z]; }; private angleBetweenVectors = (v1: [number, number, number], v2: [number, number, number]): number => { const dot = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]; const mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]); const mag2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]); return Math.acos(dot / (mag1 * mag2)); }; private sphericalDistance = (p1: Point, p2: Point): Distance => { // Points are already in radians from CoordinateSystem conversion const dLat = p2.Y - p1.Y; const dLon = p2.X - p1.X; const a = Math.sin(dLat/2) ** 2 + Math.cos(p1.Y) * Math.cos(p2.Y) * Math.sin(dLon/2) ** 2; const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return new Distance(this.sphereRadius.inMeters() * c); }; get vertices(): [Coordinate, Coordinate, Coordinate] { return this.triangleVertices; } toString = (): string => `Triangle(${this.triangleVertices.map(v => v.toString()).join(' → ')})`; }
|   +-- utils
|   |   +-- conversion
|   |   \-- math
|   --- index.js: // Main entry point for the module.
|   --- index.ts: // Main entry point for the spherical geometry library // Export core models export * from './core/models/Angle.js'; export * from './core/models/Arc.js'; export * from './core/models/Azimuth.js'; export * from './core/models/Bearing.js'; export * from './core/models/Coordinate.js'; export * from './core/models/Distance.js'; export * from './core/models/GreatCircle.js'; export * from './core/models/Point.js'; export * from './core/models/Polygon.js'; export * from './core/models/SmallCircle.js'; export * from './core/models/Sphere.js'; export * from './core/models/SphericalTrigonometry.js'; export * from './core/models/Triangle.js'; // Export coordinate system utilities export * from './core/coordinate/CoordinateSystem.js'; // Export error types export * from './core/errors/GeoError.js'; export * from './core/errors/GeoConversionError.js'; export * from './core/errors/GeoValidationError.js'; // Export GeoJSON adapters export * from './adapters/geojson/Feature.js'; export * from './adapters/geojson/FeatureCollection.js'; export * from './adapters/geojson/GeoConverter.js'; export * from './adapters/geojson/TypeConverter.js'; export * from './adapters/geojson/TypeMapping.js';
--- .gitignore: # Node.js node_modules/ npm-debug.log npm-debug.log.* yarn-debug.log yarn-error.log # Environment files .env .env.local .env.development.local .env.test.local .env.production.local # Editor directories and files .vscode/ .idea/ *.sublime-workspace *.sublime-project # Operating System generated files .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db # TypeScript Compiler output /build /dist /out /*.tsbuildinfo # Logs logs *.log *.csv # Dependency directories jspm_packages/ bower_components/ # Optional eslint cache .eslintcache # Output of 'npm pack' *.tgz # Yarn Integrity file .yarn-integrity # Generated files /src/**/*.js /src/**/*.js.map /src/**/*.d.ts # Production specific .production
--- New Text Document.txt: <empty file>
--- README.md: // Readme file for the project. # Spherical Geometry API ## Overview This API provides a comprehensive toolkit for performing geometric calculations on a spherical surface, ideal for applications in navigation, astronomy, and geospatial analysis. ## Classes and Methods ### Sphere | Method | Description | |-------------------|--------------------------------------------| | `surfaceArea()` | Calculates the surface area of the sphere. | | `volume()` | Calculates the volume of the sphere. | ### Coordinate | Method | Description | |-------------------|----------------------------------------------------| | `toRadians()` | Converts the latitude and longitude to radians. | | `toString()` | Returns a string representation of the coordinate. | ### GreatCircle | Method | Description | |------------------------|----------------------------------------------------| | `calculateDistance()` | Calculates the distance between two coordinates. | | `findMidpoint()` | Finds the midpoint along the great circle path. | ### Arc | Method | Description | |------------------------|------------------------------------------| | `calculateLength()` | Calculates the length of the arc. | | `findPointAtFraction()`| Finds a point at a specified fraction along the arc. | ### Triangle | Method | Description | |------------------------|------------------------------------------| | `calculateArea()` | Calculates the area of the spherical triangle. | | `calculatePerimeter()` | Calculates the perimeter of the triangle. | ### Angle | Method | Description | |------------------------|--------------------------------------------| | `toRadians()` | Converts the angle to radians. | | `normalize()` | Normalizes the angle to the range [0, 360]. | | `add(angle: Angle)` | Adds another angle to this angle. | | `subtract(angle: Angle)` | Subtracts another angle from this angle. | ### Azimuth | Method | Description | |------------------------|--------------------------------------------| | `calculateAzimuth()` | Calculates the azimuth from start to end point. | ### Bearing | Method | Description | |-----------------------------|----------------------------------------------| | `calculateInitialBearing()` | Calculates the initial bearing from start to end point. | | `calculateFinalBearing()` | Calculates the final bearing from start to end point. | ### GeometryService | Method | Description | |----------------------------------|----------------------------------------------| | `createGreatCircle()` | Creates a great circle from two coordinates. | | `calculateSmallCircleArea()` | Calculates the area of a small circle given its radius. | | `isWithinDistanceFromGreatCircle()` | Determines if a coordinate is within a certain distance from a great circle. | ### CalculationService | Method | Description | |----------------------------------|----------------------------------------------| | `calculateDistance()` | Calculates the distance between two coordinates. | | `calculateBearing()` | Calculates the bearing between two coordinates. | | `calculateTriangleAngle()` | Calculates the angle at a vertex of a spherical triangle given three coordinates. | ### Converters | Method | Description | |----------------------------|----------------------------------------------| | `degreesToRadians(degrees)`| Converts degrees to radians. | | `radiansToDegrees(radians)`| Converts radians to degrees. | ### Validators | Method | Description | |----------------------------|----------------------------------------------| | `validateLatitude(latitude)` | Validates if the latitude is within valid range. | | `validateLongitude(longitude)` | Validates if the longitude is within valid range. |
--- vitest.config.ts: import { defineConfig } from 'vitest/config' export default defineConfig({ test: { globals: true, environment: 'node', include: ['test/**/*.test.ts'], coverage: { provider: 'v8', reporter: ['text', 'json', 'html'], }, testTimeout: 20000, hookTimeout: 20000, teardownTimeout: 1000 } })
