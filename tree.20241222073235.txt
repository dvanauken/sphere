+-- .gitignore
+-- README.md
+-- package-lock.json
+-- package.json
+-- src
|   +-- geojson
|   |   +-- Feature.ts: // Feature.ts import { GeometryCollection } from "./GeometryCollection"; import { LineString } from "./LineString"; import { MultiLineString } from "./MultiLineString"; import { MultiPoint } from "./MultiPoint"; import { MultiPolygon } from "./MultiPolygon"; import { Point } from "./Point"; import { Polygon } from "./Polygon";  export interface Feature {   type: "Feature";   geometry: GeometryCollection | Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon;   properties: { [key: string]: any }; } 
|   |   +-- FeatureCollection.ts: // FeatureCollection.ts import { Feature } from "./Feature";  export interface FeatureCollection {   type: "FeatureCollection";   features: Feature[]; } 
|   |   +-- GeometryCollection.ts: import { LineString } from "./LineString"; import { MultiLineString } from "./MultiLineString"; import { MultiPoint } from "./MultiPoint"; import { MultiPolygon } from "./MultiPolygon"; import { Point } from "./Point"; import { Polygon } from "./Polygon";  // GeometryCollection.ts export interface GeometryCollection {   type: "GeometryCollection";   geometries: Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection>; } 
|   |   +-- LineString.ts: // LineString.ts import { Point } from "./Point";  export interface LineString {   type: "LineString";   coordinates: Point['coordinates'][]; } 
|   |   +-- MultiLineString.ts: // MultiLineString.ts import { LineString } from "./LineString";  export interface MultiLineString {   type: "MultiLineString";   coordinates: LineString['coordinates'][]; } 
|   |   +-- MultiPoint.ts: // MultiPoint.ts import { Point } from "./Point";  export interface MultiPoint {   type: "MultiPoint";   coordinates: Point['coordinates'][]; } 
|   |   +-- MultiPolygon.ts: // MultiPolygon.ts import { Polygon } from "./Polygon";  export interface MultiPolygon {   type: "MultiPolygon";   coordinates: Polygon['coordinates'][]; } 
|   |   +-- Point.ts: // Point.ts export interface Point {   type: "Point";   coordinates: [number, number]; // Longitude, Latitude } 
|   |   -- Polygon.ts: // Polygon.ts import { LineString } from "./LineString";  export interface Polygon {   type: "Polygon";   coordinates: LineString['coordinates'][]; // Array of linear rings } 
|   +-- index.js
|   +-- index.ts: // Main entry point for the module.  
|   +-- models
|   |   +-- Angle.js
|   |   +-- Angle.ts: import { Arc } from "./Arc"; import { Distance } from './Distance.js';    // Angle.ts export class Angle {     constructor(public readonly degrees: number) {}      // Add toRadians method     toRadians(): number {         return this.degrees * (Math.PI / 180);     }      normalize(): number {         return ((this.degrees % 360) + 360) % 360;     }      // Fix overload signatures     static defineBy(a: Arc, b: Arc, c: Arc | Angle, aLength?: Distance, bLength?: Distance, cLength?: Distance): Angle {         if (!aLength || !bLength || !cLength) {             throw new Error("Length parameters are required");         }          if (c instanceof Angle) {             // Law of Sines case             const sinA = Math.sin(c.toRadians());             const calculatedAngleDegrees = Math.asin(                 (aLength.inMeters() * Math.sin(c.toRadians())) / bLength.inMeters()             ) * (180 / Math.PI);              return new Angle(calculatedAngleDegrees);         } else {             // Law of Cosines case             const cosC = (                 Math.pow(aLength.inMeters(), 2) +                  Math.pow(bLength.inMeters(), 2) -                  Math.pow(cLength.inMeters(), 2)             ) / (2 * aLength.inMeters() * bLength.inMeters());              const calculatedAngleDegrees = Math.acos(cosC) * (180 / Math.PI);             return new Angle(calculatedAngleDegrees);         }     }      toString(): string {         return `Angle(${this.degrees} degrees)`;     } }  
|   |   +-- Arc.js
|   |   +-- Arc.ts: import { Coordinate } from './Coordinate.js'; import { Angle } from './Angle.js'; import { Distance } from './Distance.js'; import { Sphere } from './Sphere.js';  export class Arc {     private constructor(         private readonly sphere: Sphere,         private readonly centralAngle?: Angle,         private readonly start?: Coordinate,         private readonly end?: Coordinate     ) { }      static onSphere(         sphere: Sphere = Sphere.earth(),         centralAngle?: Angle     ): Arc {         return new Arc(sphere, centralAngle);     }      static fromPoints(         start: Coordinate,         end: Coordinate,         sphere: Sphere = Sphere.earth()     ): Arc {         return new Arc(sphere, undefined, start, end);     }      length(): Distance {         if (this.start && this.end) {             // Calculate from points using great circle formula             const lat1 = this.start.toRadians().latRadians;             const lon1 = this.start.toRadians().lonRadians;             const lat2 = this.end.toRadians().latRadians;             const lon2 = this.end.toRadians().lonRadians;              // Calculate central angle using haversine formula             const dLat = lat2 - lat1;             const dLon = lon2 - lon1;              const a =                 Math.sin(dLat / 2) ** 2 +                 Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;              const centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));              return new Distance(this.sphere.radius * 1000 * centralAngle);         } else if (this.centralAngle) {             return new Distance(this.sphere.radius * 1000 * this.centralAngle.toRadians());         } else {             // Full circumference if no angle specified             return new Distance(2 * Math.PI * this.sphere.radius * 1000);         }     }      interpolate(fraction: number): Coordinate | undefined {         if (fraction < 0 || fraction > 1) {             throw new Error('Fraction must be between 0 and 1');         }          if (this.start && this.end) {             const lat1 = this.start.toRadians().latRadians;             const lon1 = this.start.toRadians().lonRadians;             const lat2 = this.end.toRadians().latRadians;             const lon2 = this.end.toRadians().lonRadians;              const d = this.length().inMeters() / (this.sphere.radius * 1000);              const A = Math.sin((1 - fraction) * d) / Math.sin(d);             const B = Math.sin(fraction * d) / Math.sin(d);              const x =                 A * Math.cos(lat1) * Math.cos(lon1) +                 B * Math.cos(lat2) * Math.cos(lon2);             const y =                 A * Math.cos(lat1) * Math.sin(lon1) +                 B * Math.cos(lat2) * Math.sin(lon2);             const z = A * Math.sin(lat1) + B * Math.sin(lat2);              const lat3 = Math.atan2(z, Math.sqrt(x * x + y * y));             const lon3 = Math.atan2(y, x);              return new Coordinate(                 (lat3 * 180) / Math.PI,                 (lon3 * 180) / Math.PI             );         }         return undefined;     } }
|   |   +-- Azimuth.js
|   |   +-- Azimuth.ts: // This file defines the Azimuth class.  // Azimuth.ts import { Coordinate } from './Coordinate'; import { Angle } from './Angle';  export class Azimuth {     start: Coordinate;     end: Coordinate;      constructor(start: Coordinate, end: Coordinate) {         this.start = start;         this.end = end;     }      // Calculate the azimuth angle in degrees from north     calculateAzimuth(): number {         const lat1 = this.start.toRadians().latRadians;         const lon1 = this.start.toRadians().lonRadians;         const lat2 = this.end.toRadians().latRadians;         const lon2 = this.end.toRadians().lonRadians;          const dLon = lon2 - lon1;         const y = Math.sin(dLon) * Math.cos(lat2);         const x = Math.cos(lat1) * Math.sin(lat2) -                   Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);         const angle = Math.atan2(y, x);          return (angle * (180 / Math.PI) + 360) % 360;  // Normalize angle to positive degrees     } } 
|   |   +-- Bearing.js
|   |   +-- Bearing.ts: // This file defines the Bearing class.  // Bearing.ts import { Coordinate } from './Coordinate'; import { Azimuth } from './Azimuth';  export class Bearing {     start: Coordinate;     end: Coordinate;      constructor(start: Coordinate, end: Coordinate) {         this.start = start;         this.end = end;     }      // Calculate the initial bearing using azimuth calculations     calculateInitialBearing(): number {         const azimuth = new Azimuth(this.start, this.end);         return azimuth.calculateAzimuth();     }      // Calculate the final bearing by reversing start and end     calculateFinalBearing(): number {         const azimuth = new Azimuth(this.end, this.start);         return (azimuth.calculateAzimuth() + 180) % 360;  // Adjust by 180 degrees to get the opposite direction     } } 
|   |   +-- Coordinate.js
|   |   +-- Coordinate.ts: // Coordinate.ts export class Coordinate {   latitude: number;   longitude: number;   altitude?: number;  // Optional altitude for 3D positioning    constructor(latitude: number, longitude: number, altitude?: number) {       this.latitude = latitude;       this.longitude = longitude;       this.altitude = altitude;   }    // Convert latitude and longitude from degrees to radians   toRadians(): { latRadians: number, lonRadians: number } {       return {           latRadians: this.latitude * (Math.PI / 180),           lonRadians: this.longitude * (Math.PI / 180),       };   }    // Optional: toString method for easy debugging   toString(): string {       return `Coordinate(${this.latitude}, ${this.longitude}${this.altitude ? ', ' + this.altitude : ''})`;   } } 
|   |   +-- Distance.ts: // Angle.ts remains the same...  // Distance.ts export class Distance {     private static readonly METERS_TO_NM = 0.000539957;      constructor(private readonly meters: number) {}      inMeters(): number {         return this.meters;     }      inKilometers(): number {         return this.meters / 1000;     }      inCentimeters(): number {         return this.meters * 100;     }      inMiles(): number {         return this.meters * 0.000621371;     }      inFeet(): number {         return this.meters * 3.28084;     }      inYards(): number {         return this.meters * 1.09361;     }      inNauticalMiles(): number {         return this.meters * Distance.METERS_TO_NM;     }      static fromKilometers(km: number): Distance {         return new Distance(km * 1000);     }      static fromMiles(miles: number): Distance {         return new Distance(miles / 0.000621371);     }      static fromNauticalMiles(nm: number): Distance {         return new Distance(nm / Distance.METERS_TO_NM);     }      static fromFeet(feet: number): Distance {         return new Distance(feet / 3.28084);     }      toString(): string {         return `${this.inKilometers().toFixed(2)} km`;     }      toFormat(unit: 'km' | 'mi' | 'nm' | 'ft' | 'm'): string {         switch(unit) {             case 'km': return `${this.inKilometers().toFixed(2)} km`;             case 'mi': return `${this.inMiles().toFixed(2)} mi`;             case 'nm': return `${this.inNauticalMiles().toFixed(2)} nm`;             case 'ft': return `${this.inFeet().toFixed(2)} ft`;             case 'm': return `${this.inMeters().toFixed(2)} m`;         }     } }
|   |   +-- GreatCircle.js
|   |   +-- GreatCircle.ts: // This file defines the GreatCircle class.  // GreatCircle.ts import { Coordinate } from './Coordinate'; import { Angle } from './Angle'; import { Sphere } from './Sphere'; import { Distance } from './Distance';  // Now let's modify the GreatCircle class to be fluent export class GreatCircle {   private readonly start: Coordinate;   private readonly end: Coordinate;   private sphere: Sphere;    constructor(start: Coordinate, end: Coordinate) {       this.start = start;       this.end = end;       this.sphere = Sphere.earth(); // Default Earth sphere   }    withSphere(sphere: Sphere): GreatCircle {       this.sphere = sphere;       return this;   }    // This returns our Distance class instead of a raw number   calculateDistance(): Distance {       const lat1 = this.start.toRadians().latRadians;       const lon1 = this.start.toRadians().lonRadians;       const lat2 = this.end.toRadians().latRadians;       const lon2 = this.end.toRadians().lonRadians;        const dLat = lat2 - lat1;       const dLon = lon2 - lon1;        const a = Math.sin(dLat/2) ** 2 +               Math.cos(lat1) * Math.cos(lat2) *               Math.sin(dLon/2) ** 2;       const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));              // Convert to meters for our Distance class       const distanceInMeters = this.sphere.radius * 1000 * c;       return new Distance(distanceInMeters);   }    // Shorthand method for more fluent API   distance(): Distance {       return this.calculateDistance();   }    findMidpoint(): Coordinate {       // Existing midpoint calculation       const lat1 = this.start.toRadians().latRadians;       const lon1 = this.start.toRadians().lonRadians;       const lat2 = this.end.toRadians().latRadians;       const lon2 = this.end.toRadians().lonRadians;        const Bx = Math.cos(lat2) * Math.cos(lon2 - lon1);       const By = Math.cos(lat2) * Math.sin(lon2 - lon1);       const lat3 = Math.atan2(Math.sin(lat1) + Math.sin(lat2),                           Math.sqrt((Math.cos(lat1) + Bx) ** 2 + By ** 2));       const lon3 = lon1 + Math.atan2(By, Math.cos(lat1) + Bx);        return new Coordinate(           lat3 * (180 / Math.PI),            lon3 * (180 / Math.PI)       );   } }
|   |   +-- SmallCircle.js
|   |   +-- SmallCircle.ts: // This file defines the SmallCircle class.  // SmallCircle.ts import { Coordinate } from './Coordinate';  export class SmallCircle {     center: Coordinate;     angularRadius: number; // Angular radius in degrees      constructor(center: Coordinate, angularRadius: number) {         this.center = center;         this.angularRadius = angularRadius;     }      // Calculate the circumference of the small circle     circumference(): number {         const earthRadius = 6371; // Earth's average radius in kilometers         const angularRadiusRadians = this.angularRadius * Math.PI / 180; // Convert angular radius to radians         return 2 * Math.PI * earthRadius * Math.sin(angularRadiusRadians);     }      // Calculate the area of the small circle     area(): number {         const earthRadius = 6371; // Earth's radius in kilometers         const angularRadiusRadians = this.angularRadius * Math.PI / 180; // Convert angular radius to radians         return 2 * Math.PI * earthRadius * earthRadius * (1 - Math.cos(angularRadiusRadians));     }      // Calculate the angular diameter of the small circle     angularDiameter(): number {         return 2 * this.angularRadius;     }      // Optional: Convert the small circle definition to a string for easy debugging     toString(): string {         return `SmallCircle(Center: ${this.center.toString()}, Angular Radius: ${this.angularRadius} degrees)`;     } } 
|   |   +-- Sphere.js
|   |   +-- Sphere.ts: // src/models/Sphere.ts export class Sphere {   private constructor(public readonly radius: number) {       this.radius = radius;   }    // Factory methods for common celestial bodies   static earth(): Sphere {       return new Sphere(6371); // Mean radius in kilometers   }    static moon(): Sphere {       return new Sphere(1737.1);   }    static mars(): Sphere {       return new Sphere(3389.5);   }    static custom(radius: number): Sphere {       if (radius <= 0) {           throw new Error('Radius must be positive');       }       return new Sphere(radius);   }    // Calculation methods   surfaceArea(): number {       return 4 * Math.PI * Math.pow(this.radius, 2);   }    volume(): number {       return (4/3) * Math.PI * Math.pow(this.radius, 3);   } }
|   |   +-- SphericalTrigonometry.ts: import { Angle } from "./Angle"; import { Distance } from "./Distance";  // For Law of Sines/Cosines calculations, we should use Distance directly export class SphericalTrigonometry {   static lawOfCosines(arcA: Distance, arcB: Distance, angleC: Angle): Distance {       const a = arcA.inMeters();       const b = arcB.inMeters();       const C = angleC.toRadians();              const c = Math.sqrt(           Math.pow(a, 2) + Math.pow(b, 2) -            2 * a * b * Math.cos(C)       );        return new Distance(c);   }    static lawOfSines(angleA: Angle, angleB: Angle, arcC: Distance): Distance {       const A = angleA.toRadians();       const B = angleB.toRadians();       const C = Math.PI - (A + B);              const c = arcC.inMeters();       const a = Math.abs(c * Math.sin(A) / Math.sin(C));        return new Distance(a);   } }
|   |   +-- Triangle.js
|   |   -- Triangle.ts: // This file defines the Triangle class.  // Triangle.ts import { Coordinate } from './Coordinate'; import { Sphere } from './Sphere';  export class Triangle {     vertices: Coordinate[];     sphere: Sphere;      constructor(vertexA: Coordinate, vertexB: Coordinate, vertexC: Coordinate, sphere: Sphere) {         this.vertices = [vertexA, vertexB, vertexC];         this.sphere = sphere;     }      // Calculate the area of the spherical triangle using the spherical excess formula     calculateArea(): number {         const radius = this.sphere.radius;         const A = this.angleBetween(this.vertices[1], this.vertices[2]);         const B = this.angleBetween(this.vertices[0], this.vertices[2]);         const C = this.angleBetween(this.vertices[0], this.vertices[1]);          const sphericalExcess = (A + B + C) - Math.PI;         return (sphericalExcess * radius * radius);     }      // Calculate the perimeter of the spherical triangle     calculatePerimeter(): number {         const a = this.sphericalDistance(this.vertices[1], this.vertices[2]);         const b = this.sphericalDistance(this.vertices[0], this.vertices[2]);         const c = this.sphericalDistance(this.vertices[0], this.vertices[1]);                  return a + b + c;     }      // Calculate the spherical distance between two coordinates on the surface of the sphere     private sphericalDistance(coordA: Coordinate, coordB: Coordinate): number {         const lat1 = coordA.toRadians().latRadians;         const lon1 = coordA.toRadians().lonRadians;         const lat2 = coordB.toRadians().latRadians;         const lon2 = coordB.toRadians().lonRadians;          // Using the haversine formula to calculate spherical distance         const dLat = lat2 - lat1;         const dLon = lon2 - lon1;         const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;         const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));          return this.sphere.radius * c;     }      // Calculate the angle between two vertices, opposite the third vertex     private angleBetween(coordA: Coordinate, coordB: Coordinate): number {         const a = this.sphericalDistance(coordA, coordB);         const b = this.sphericalDistance(this.vertices[0], coordB);         const c = this.sphericalDistance(this.vertices[0], coordA);          // Using the spherical law of cosines to calculate the angle at the first vertex         return Math.acos((Math.cos(a / this.sphere.radius) - Math.cos(b / this.sphere.radius) * Math.cos(c / this.sphere.radius)) / (Math.sin(b / this.sphere.radius) * Math.sin(c / this.sphere.radius)));     } } 
|   +-- services
|   |   +-- CalculationService.js
|   |   +-- CalculationService.ts: // src/services/CalculationService.ts import { Angle } from "../models/Angle"; import { Azimuth } from "../models/Azimuth"; import { Bearing } from "../models/Bearing"; import { Coordinate } from "../models/Coordinate"; import { GreatCircle } from "../models/GreatCircle"; import { Distance } from "../models/Distance"; import { Sphere } from "../models/Sphere";  export class CalculationService {     // Calculate the distance between two coordinates on the sphere     calculateDistance(start: Coordinate, end: Coordinate): Distance {         const greatCircle = new GreatCircle(start, end)             .withSphere(Sphere.earth()); // Using our new factory method         return greatCircle.distance();     }      // Calculate the bearing from one coordinate to another     calculateBearing(start: Coordinate, end: Coordinate): number {         const bearing = new Bearing(start, end);         return bearing.calculateInitialBearing();     }      // Calculate the angle between three points on the sphere     calculateTriangleAngle(a: Coordinate, b: Coordinate, c: Coordinate): Angle {         // Placeholder for method implementation         return new Angle(0);  // Example placeholder     }      // Calculate the area of a polygon defined by spherical coordinates     calculatePolygonArea(coordinates: Coordinate[]): number {         // Placeholder for area calculation using spherical excess formula         return 0;  // Simplified example return     } }
|   |   +-- GeometryService.js
|   |   +-- GeometryService.ts: import { Coordinate } from "../models/Coordinate"; import { GreatCircle } from "../models/GreatCircle"; import { SmallCircle } from "../models/SmallCircle"; import { Sphere } from "../models/Sphere"; import { Triangle } from "../models/Triangle";  export class GeometryService {   private sphere: Sphere;    constructor(radius: number) {     this.sphere = Sphere.earth();   }    createGreatCircle(start: Coordinate, end: Coordinate): GreatCircle {     return new GreatCircle(start, end);   }    createSmallCircle(center: Coordinate, radius: number): SmallCircle {     return new SmallCircle(center, radius);   }    isWithinDistanceFromGreatCircle(coordinate: Coordinate, greatCircle: GreatCircle, distance: number): boolean {     return true;  // Example placeholder   }    createTriangle(a: Coordinate, b: Coordinate, c: Coordinate): Triangle {     return new Triangle(a, b, c, this.sphere); // Now passing 'sphere' as well   }    calculateGeographicCenter(coordinates: Coordinate[]): Coordinate {     return new Coordinate(0, 0);  // Simplified example return   } } 
|   |   +-- IntersectionService.js
|   |   +-- IntersectionService.ts: // This file provides intersection services.  
|   |   +-- VisibilityService.js
|   |   -- VisibilityService.ts: // This file provides visibility services.  
|   -- utils
|      +-- converters.js
|      +-- converters.ts: // Utility functions for conversions.  // Converters.ts export class Converters {   // Converts degrees to radians   static degreesToRadians(degrees: number): number {       return degrees * Math.PI / 180;   }    // Converts radians to degrees   static radiansToDegrees(radians: number): number {       return radians * 180 / Math.PI;   }    // Optionally, include other relevant conversions } 
|      +-- validators.js
|      -- validators.ts: // Utility functions for validations.  // Validators.ts export class Validators {   // Validate that latitude values are between -90 and 90   static validateLatitude(latitude: number): boolean {       return latitude >= -90 && latitude <= 90;   }    // Validate that longitude values are between -180 and 180   static validateLongitude(longitude: number): boolean {       return longitude >= -180 && longitude <= 180;   }    // Optionally, include methods to validate other types of geometric data } 
+-- test
|   +-- Arc.test.ts: // test/Arc.test.ts import test from 'node:test'; import { Arc } from '../src/models/Arc.js'; import { SphericalTrigonometry } from '../src/models/SphericalTrigonometry.js'; import { Coordinate } from '../src/models/Coordinate.js'; import { Angle } from '../src/models/Angle.js'; import { Distance } from '../src/models/Distance.js'; import { Sphere } from '../src/models/Sphere.js'; import { assertDistanceNearlyEqual } from './helpers/assertions.js';  test('Arc Calculations', async (t) => {     await t.test('should create simple arc with default radius', () => {         const arc = Arc.onSphere();  // defaults to Earth         const circumference = arc.length();                  // 2πr where r is Earth's radius (6371km)         const expectedCircumference = 2 * Math.PI * 6371;         assertDistanceNearlyEqual(             circumference.inKilometers(),             expectedCircumference,             1,             'Default arc should have Earth\'s circumference'         );     });      await t.test('should calculate great circle arc between two points', () => {         // London to Paris         const london = new Coordinate(51.5074, -0.1278);         const paris = new Coordinate(48.8566, 2.3522);                  const arc = Arc.fromPoints(london, paris);  // defaults to Earth sphere         const length = arc.length();          // Debug output         console.log('London-Paris arc length test:');         console.log(`Calculated length: ${length.inKilometers()} km`);         console.log(`Expected length: 344 km`);                  assertDistanceNearlyEqual(             length.inKilometers(),             344,             1,             'London-Paris arc length should be about 344 km'         );     });      await t.test('should calculate simple known arc length', () => {         // Test with two points on the equator, 90 degrees apart         const point1 = new Coordinate(0, 0);  // 0°N, 0°E         const point2 = new Coordinate(0, 90); // 0°N, 90°E                  const arc = Arc.fromPoints(point1, point2);         const length = arc.length();          // For 90 degrees on Earth's great circle, should be 1/4 of circumference         const expectedLength = (2 * Math.PI * 6371) / 4; // ~10,007 km                  assertDistanceNearlyEqual(             length.inKilometers(),             expectedLength,             1,             'Quarter Earth circumference calculation'         );     }); });  // Separate test file for SphericalTrigonometry test('Spherical Trigonometry', async (t) => {     await t.test('should calculate using Law of Cosines', () => {         // Isosceles triangle with:         // - Two equal sides of 100km         // - Included angle of 60°         // - Expected third side should be approximately 100km         const arcA = Distance.fromKilometers(100);         const arcB = Distance.fromKilometers(100);         const angleC = new Angle(60);          const result = SphericalTrigonometry.lawOfCosines(arcA, arcB, angleC);          assertDistanceNearlyEqual(             result.inKilometers(),             100,             0.1,             'Law of Cosines for isosceles triangle with 60° angle'         );     });      await t.test('should calculate using Law of Sines', () => {         // Right triangle with:         // - 30° and 60° angles (therefore 90° for third angle)         // - Hypotenuse of 100km         // - Expected shortest side should be 50km         const angleA = new Angle(30);         const angleB = new Angle(60);         const arcC = Distance.fromKilometers(100);          const result = SphericalTrigonometry.lawOfSines(angleA, angleB, arcC);          assertDistanceNearlyEqual(             result.inKilometers(),             50,             0.1,             'Law of Sines for 30-60-90 triangle with hypotenuse 100km'         );     }); });
|   +-- GreatCircle.test.ts: // test/GreatCircle.test.ts import test from 'node:test'; import assert from 'node:assert'; import { GreatCircle } from '../src/models/GreatCircle.js'; import { Coordinate } from '../src/models/Coordinate.js'; import { Sphere } from '../src/models/Sphere.js';  test('GreatCircle Calculations', async (t) => {     const london = new Coordinate(51.5074, -0.1278);     const nyc = new Coordinate(40.7128, -74.0060);      await t.test('should calculate distances using Earth sphere factory', () => {         const distance = new GreatCircle(london, nyc)             .withSphere(Sphere.earth())             .distance();          // Test each unit conversion separately with descriptive messages         assert.equal(             Math.round(distance.inKilometers()),              5570,             'GreatCircle.distance().inKilometers() gave incorrect value'         );          assert.equal(             Math.round(distance.inMiles()),              3461,             'GreatCircle.distance().inMiles() gave incorrect value'         );          // assert.equal(         //     Math.round(distance.inNauticalMiles()),          //     3007,         //     'GreatCircle.distance().inNauticalMiles() gave incorrect value'         // );          // assert.equal(         //     Math.round(distance.inFeet()),          //     18274278,         //     'GreatCircle.distance().inFeet() gave incorrect value'         // );     });      // Add more specific tests for each calculation type     await t.test('should handle zero distance', () => {         const distance = new GreatCircle(london, london)             .withSphere(Sphere.earth())             .distance();          assert.equal(             Math.round(distance.inKilometers()),              0,             'GreatCircle.distance() should be 0 for same point'         );     }); });
|   -- helpers
|      -- assertions.ts: // test/helpers/assertions.ts import assert from 'node:assert';  export function assertNearlyEqual(     actual: number,     expected: number,     tolerance: number,     message?: string ) {     const diff = Math.abs(actual - expected);     assert.ok(         diff <= tolerance,         message || `Expected ${actual} to be within ${tolerance} of ${expected} (diff: ${diff})`     ); }  export function assertDistanceNearlyEqual(     actual: number,     expected: number,     toleranceKm: number = 0.1,     message?: string ) {     assertNearlyEqual(         actual,         expected,         toleranceKm,         message || `Distance ${actual}km should be within ${toleranceKm}km of ${expected}km`     ); }
+-- tree-content.py
-- tsconfig.json
