+-- package.json
+-- src
|   +-- CoordinateSystem.ts: import { Coordinate } from "./models/Coordinate"; import { Point } from "./models/Point";  export class CoordinateSystem {   static fromCoordinate(coord: Coordinate): Point {       const lat = coord.latitude * (Math.PI / 180);       const lon = coord.longitude * (Math.PI / 180);       return Point.at(lat, lon);   }    static fromPoint(point: Point): Coordinate {       const lat = point.X * (180 / Math.PI);       const lon = point.Y * (180 / Math.PI);       return Coordinate.at(lat, lon);   } }
|   +-- geojson
|   |   +-- Feature.ts: // Feature.ts import { GeometryCollection } from "./GeometryCollection"; import { LineString } from "./LineString"; import { MultiLineString } from "./MultiLineString"; import { MultiPoint } from "./MultiPoint"; import { MultiPolygon } from "./MultiPolygon"; import { Point } from "./Point"; import { Polygon } from "./Polygon";  export interface Feature {   type: "Feature";   geometry: GeometryCollection | Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon;   properties: { [key: string]: any }; } 
|   |   +-- FeatureCollection.ts: // FeatureCollection.ts import { Feature } from "./Feature";  export interface FeatureCollection {   type: "FeatureCollection";   features: Feature[]; } 
|   |   +-- GeoConversionError.ts: export class GeoConversionError extends Error {   constructor(       message: string,       public readonly sourceType?: string,       public readonly targetType?: string,       public readonly cause?: Error   ) {       super(message);       this.name = 'GeoConversionError';   } }  // Add validation and error handling to existing classes: export class TypeValidator {   static validateFeature(feature: Feature): void {       if (!feature.type || feature.type !== 'Feature') {           throw new GeoConversionError('Invalid Feature type');       }       if (!feature.geometry) {           throw new GeoConversionError('Missing geometry');       }       // Add more validation   }    static validateGeometry(geometry: any): void {       // Geometry validation   } }
|   |   +-- GeoConverter.ts: export class GeoConverter {   static toGeoJSON(input: any): Feature | Feature[] {       if (Array.isArray(input)) {           return GeoWriter.writeCollection(input);       }       return GeoWriter.write(input);   }    static fromGeoJSON(input: Feature | Feature[]): any {       if (Array.isArray(input)) {           return GeoReader.readCollection(input);       }       return GeoReader.read(input);   } }  // Convert to GeoJSON const feature = GeoConverter.toGeoJSON(myGreatCircle);  // Convert from GeoJSON const circle = GeoConverter.fromGeoJSON(feature);
|   |   +-- GeoReader.ts: export class GeoReader {   static read(feature: Feature): any {       return GeoRegistry.reverse(feature);   }    static readCollection(collection: Feature[]): any[] {       return collection.map(f => GeoReader.read(f));   } }  
|   |   +-- GeoRegistry.ts: export class GeoRegistry {   private static readonly converters = new Map<string, TypeConverter>();    static register(type: any, converter: TypeConverter): void {       const geoType = TypeMapping.get(type);       if (!geoType) throw new Error(`No mapping for type ${type.name}`);       GeoRegistry.converters.set(type.name, converter);   }    static convert(source: any, target: string): any {       const converter = GeoRegistry.converters.get(source.constructor.name);       if (!converter) throw new Error(`No converter for ${source.constructor.name}`);       return converter.toFeature(source);   }    static reverse(feature: Feature): any {       // Convert from Feature back to our types   } }
|   |   +-- GeoWriter.ts:  export class GeoWriter {   static write(source: any): Feature {       return GeoRegistry.convert(source, 'Feature');   }    static writeCollection(sources: any[]): Feature[] {       return sources.map(s => GeoWriter.write(s));   } }
|   |   +-- GeometryCollection.ts: import { LineString } from "./LineString"; import { MultiLineString } from "./MultiLineString"; import { MultiPoint } from "./MultiPoint"; import { MultiPolygon } from "./MultiPolygon"; import { Point } from "./Point"; import { Polygon } from "./Polygon";  // GeometryCollection.ts export interface GeometryCollection {   type: "GeometryCollection";   geometries: Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection>; } 
|   |   +-- LineString.ts: // LineString.ts import { Point } from "./Point";  export interface LineString {   type: "LineString";   coordinates: Point['coordinates'][]; } 
|   |   +-- MultiLineString.ts: // MultiLineString.ts import { LineString } from "./LineString";  export interface MultiLineString {   type: "MultiLineString";   coordinates: LineString['coordinates'][]; } 
|   |   +-- MultiPoint.ts: // MultiPoint.ts import { Point } from "./Point";  export interface MultiPoint {   type: "MultiPoint";   coordinates: Point['coordinates'][]; } 
|   |   +-- MultiPolygon.ts: // MultiPolygon.ts import { Polygon } from "./Polygon";  export interface MultiPolygon {   type: "MultiPolygon";   coordinates: Polygon['coordinates'][]; } 
|   |   +-- Point.ts: // Point.ts export interface Point {   type: "Point";   coordinates: [number, number]; // Longitude, Latitude } 
|   |   +-- Polygon.ts: // Polygon.ts import { LineString } from "./LineString";  export interface Polygon {   type: "Polygon";   coordinates: LineString['coordinates'][]; // Array of linear rings } 
|   |   +-- TypeConverter.ts: import { Coordinate } from '../models/Coordinate'; import { Point } from '../models/Point'; import { GreatCircle } from '../models/GreatCircle'; import { SmallCircle } from '../models/SmallCircle'; import { TypeMapping } from './TypeMapping'; import { Feature } from './Feature';  export class TypeConverter {     static toFeature(source: any): Feature {         const type = TypeMapping.get(source.constructor);         if (!type) throw new Error(`No mapping for type ${source.constructor.name}`);          switch(type) {             case FeaturePoint:                 return {                     type: "Feature",                     geometry: {                         type: "Point",                         coordinates: [source.longitude, source.latitude]                     },                     properties: {}                 };             // Add other conversions             default:                 throw new Error(`Conversion not implemented for ${type}`);         }     }      static fromFeature(feature: Feature): any {         // Reverse conversions     } }
|   |   -- TypeMapping.ts: import { Coordinate } from '../models/Coordinate'; import { Point } from '../models/Point'; import { GreatCircle } from '../models/GreatCircle'; import { SmallCircle } from '../models/SmallCircle'; import { Triangle } from '../models/Triangle'; import { LineString } from './LineString';  export class TypeMapping {     private static readonly map = new Map([         // ['GeoPolyCollection', null],         // ['GeoPointCollection', null],         // ['Route', null],         // ['Waypoints', null],         //[Coordinate, FeaturePoint],         //[Point, FeaturePoint],         [GreatCircle, LineString],         //[SmallCircle, Polygon],         //[Triangle, Polygon]     ]);      static get(type: any): any | null {         return TypeMapping.map.get(type) ?? null;     } }
|   +-- index.js
|   +-- index.ts: // Main entry point for the module.  
|   -- models
|      +-- Angle.js
|      +-- Angle.ts: import { Arc } from "./Arc"; import { Distance } from './Distance.js';    // Angle.ts export class Angle {     constructor(public readonly degrees: number) {}      // Add toRadians method     toRadians(): number {         return this.degrees * (Math.PI / 180);     }      normalize(): number {         return ((this.degrees % 360) + 360) % 360;     }      // Fix overload signatures     static defineBy(a: Arc, b: Arc, c: Arc | Angle, aLength?: Distance, bLength?: Distance, cLength?: Distance): Angle {         if (!aLength || !bLength || !cLength) {             throw new Error("Length parameters are required");         }          if (c instanceof Angle) {             // Law of Sines case             const sinA = Math.sin(c.toRadians());             const calculatedAngleDegrees = Math.asin(                 (aLength.inMeters() * Math.sin(c.toRadians())) / bLength.inMeters()             ) * (180 / Math.PI);              return new Angle(calculatedAngleDegrees);         } else {             // Law of Cosines case             const cosC = (                 Math.pow(aLength.inMeters(), 2) +                  Math.pow(bLength.inMeters(), 2) -                  Math.pow(cLength.inMeters(), 2)             ) / (2 * aLength.inMeters() * bLength.inMeters());              const calculatedAngleDegrees = Math.acos(cosC) * (180 / Math.PI);             return new Angle(calculatedAngleDegrees);         }     }      toString(): string {         return `Angle(${this.degrees} degrees)`;     } }  
|      +-- Arc.js
|      +-- Arc.ts: import { Angle } from "./Angle"; import { Coordinate } from "./Coordinate"; import { Distance } from "./Distance"; import { Sphere } from "./Sphere"; import { Point } from "./Point"; import { CoordinateSystem } from "../CoordinateSystem";  export class Arc {     private constructor(         private readonly sphereRadius: Distance,         private readonly centralAngle?: Angle,         private readonly start?: Coordinate,         private readonly end?: Coordinate     ) { }      static onSphere(         sphereRadius: Distance = Sphere.getRadius(),         centralAngle?: Angle     ): Arc {         return new Arc(sphereRadius, centralAngle);     }      static fromPoints(         start: Coordinate,         end: Coordinate,         sphereRadius: Distance = Sphere.getRadius()     ): Arc {         return new Arc(sphereRadius, undefined, start, end);     }      length(): Distance {         if (this.start && this.end) {             const startPoint = CoordinateSystem.fromCoordinate(this.start);             const endPoint = CoordinateSystem.fromCoordinate(this.end);              // Calculate central angle using haversine formula             const dLat = endPoint.Y - startPoint.Y;             const dLon = endPoint.X - startPoint.X;              const a =                 Math.sin(dLat / 2) ** 2 +                 Math.cos(startPoint.Y) * Math.cos(endPoint.Y) * Math.sin(dLon / 2) ** 2;              const centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));              return new Distance(this.sphereRadius.inMeters() * centralAngle);         } else if (this.centralAngle) {             return new Distance(this.sphereRadius.inMeters() * this.centralAngle.toRadians());         } else {             return new Distance(2 * Math.PI * this.sphereRadius.inMeters());         }     }      interpolate(fraction: number): Coordinate | undefined {         if (fraction < 0 || fraction > 1) {             throw new Error('Fraction must be between 0 and 1');         }          if (this.start && this.end) {             const startPoint = CoordinateSystem.fromCoordinate(this.start);             const endPoint = CoordinateSystem.fromCoordinate(this.end);              const d = this.length().inMeters() / this.sphereRadius.inMeters();              const A = Math.sin((1 - fraction) * d) / Math.sin(d);             const B = Math.sin(fraction * d) / Math.sin(d);              const x =                 A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.cos(endPoint.X);             const y =                 A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.sin(endPoint.X);             const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y);              const lat3 = Math.atan2(z, Math.sqrt(x * x + y * y));             const lon3 = Math.atan2(y, x);              return CoordinateSystem.fromPoint(Point.at(lon3, lat3));         }         return undefined;     } }
|      +-- Azimuth.js
|      +-- Azimuth.ts: import { Coordinate } from './Coordinate'; import { Angle } from './Angle'; import { CoordinateSystem } from '../CoordinateSystem';  export class Azimuth {     private constructor(         private readonly start: Coordinate,         private readonly end: Coordinate     ) {}      static from = (start: Coordinate) => ({         to: (end: Coordinate) => new Azimuth(start, end)     });      forward = (): Angle => {         const startPoint = CoordinateSystem.fromCoordinate(this.start);         const endPoint = CoordinateSystem.fromCoordinate(this.end);          const dLon = endPoint.X - startPoint.X;         const y = Math.sin(dLon) * Math.cos(endPoint.Y);         const x = Math.cos(startPoint.Y) * Math.sin(endPoint.Y) -                  Math.sin(startPoint.Y) * Math.cos(endPoint.Y) * Math.cos(dLon);                  const azimuthRadians = Math.atan2(y, x);         const azimuthDegrees = (azimuthRadians * (180 / Math.PI) + 360) % 360;          return new Angle(azimuthDegrees);     };      reverse = (): Angle => {         const forward = this.forward().degrees;         return new Angle((forward + 180) % 360);     };      toString = (): string =>          `Azimuth(${this.start} → ${this.end})`; }
|      +-- Bearing.js
|      +-- Bearing.ts: import { Coordinate } from './Coordinate'; import { Angle } from './Angle'; import { Azimuth } from './Azimuth';  export class Bearing {     private constructor(         private readonly start: Coordinate,         private readonly end: Coordinate     ) {}      static from = (start: Coordinate) => ({         to: (end: Coordinate) => new Bearing(start, end)     });      initial = (): Angle =>          Azimuth.from(this.start).to(this.end).forward();      final = (): Angle =>          Azimuth.from(this.start).to(this.end).reverse();      toString = (): string =>          `Bearing(${this.start} → ${this.end})`; }
|      +-- Coordinate.js
|      +-- Coordinate.ts: export class Coordinate {     public constructor(         private readonly lat: number,         private readonly lon: number,         private readonly alt?: number     ) {         if (lat < -90 || lat > 90) {             throw new Error('Latitude must be between -90 and 90 degrees');         }         if (lon < -180 || lon > 180) {             throw new Error('Longitude must be between -180 and 180 degrees');         }     }      static at = (lat: number, lon: number, alt?: number) =>          new Coordinate(lat, lon, alt);      get latitude(): number {         return this.lat;     }      get longitude(): number {         return this.lon;     }      get altitude(): number | undefined {         return this.alt;     }      equals = (other: Coordinate): boolean =>          this.lat === other.lat &&          this.lon === other.lon &&          this.alt === other.alt;      toString = (): string =>         `(${this.lat}°, ${this.lon}°${this.alt ? `, ${this.alt}m` : ''})`; }
|      +-- Distance.ts: // Angle.ts remains the same...  // Distance.ts export class Distance {     private static readonly METERS_TO_NM = 0.000539957;      constructor(private readonly meters: number) {}      inMeters(): number {         return this.meters;     }      inKilometers(): number {         return this.meters / 1000;     }      inCentimeters(): number {         return this.meters * 100;     }      inMiles(): number {         return this.meters * 0.000621371;     }      inFeet(): number {         return this.meters * 3.28084;     }      inYards(): number {         return this.meters * 1.09361;     }      inNauticalMiles(): number {         return this.meters * Distance.METERS_TO_NM;     }      static fromKilometers(km: number): Distance {         return new Distance(km * 1000);     }      static fromMiles(miles: number): Distance {         return new Distance(miles / 0.000621371);     }      static fromNauticalMiles(nm: number): Distance {         return new Distance(nm / Distance.METERS_TO_NM);     }      static fromFeet(feet: number): Distance {         return new Distance(feet / 3.28084);     }      toString(): string {         return `${this.inKilometers().toFixed(2)} km`;     }      toFormat(unit: 'km' | 'mi' | 'nm' | 'ft' | 'm'): string {         switch(unit) {             case 'km': return `${this.inKilometers().toFixed(2)} km`;             case 'mi': return `${this.inMiles().toFixed(2)} mi`;             case 'nm': return `${this.inNauticalMiles().toFixed(2)} nm`;             case 'ft': return `${this.inFeet().toFixed(2)} ft`;             case 'm': return `${this.inMeters().toFixed(2)} m`;         }     } }
|      +-- GreatCircle.js
|      +-- GreatCircle.ts: import { CoordinateSystem } from '../CoordinateSystem'; import { Azimuth } from './Azimuth'; import { Coordinate } from './Coordinate'; import { Distance } from './Distance'; import { Point } from './Point'; import { Sphere } from './Sphere';  interface PointGenerationOptions {    spacing?: Distance;    minPoints?: number;    maxPoints?: number; }  export class GreatCircle {    public constructor(        private readonly start: Coordinate,        private readonly end: Coordinate,        private readonly sphereRadius: Distance = Sphere.getRadius()    ) {}     static from(start: Coordinate) {        return {            to: (end: Coordinate) => new GreatCircle(start, end)        };    }     withSphere = (sphereRadius: Distance): GreatCircle =>         new GreatCircle(this.start, this.end, sphereRadius);     distance = (): Distance => {        const startPoint = CoordinateSystem.fromCoordinate(this.start);        const endPoint = CoordinateSystem.fromCoordinate(this.end);                const dLat = endPoint.Y - startPoint.Y;        const dLon = endPoint.X - startPoint.X;                const a = Math.sin(dLat/2) ** 2 +                  Math.cos(startPoint.Y) *                  Math.cos(endPoint.Y) *                  Math.sin(dLon/2) ** 2;                         const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));                return new Distance(this.sphereRadius.inMeters() * c);    };     interpolate = (fraction: number): Coordinate | undefined => {        if (fraction < 0 || fraction > 1) {            throw new Error('Fraction must be between 0 and 1');        }         const startPoint = CoordinateSystem.fromCoordinate(this.start);        const endPoint = CoordinateSystem.fromCoordinate(this.end);                const d = this.distance().inMeters() / this.sphereRadius.inMeters();                const A = Math.sin((1 - fraction) * d) / Math.sin(d);        const B = Math.sin(fraction * d) / Math.sin(d);                const x = A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.cos(endPoint.X);        const y = A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.sin(endPoint.X);        const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y);                const lat = Math.atan2(z, Math.sqrt(x * x + y * y));        const lon = Math.atan2(y, x);                return CoordinateSystem.fromPoint(Point.at(lon, lat));    };     // Rest of the methods remain unchanged    generatePoints = (options: PointGenerationOptions): Coordinate[] => {        const totalDistance = this.distance();                let numPoints: number;        if (options.spacing) {            numPoints = Math.ceil(totalDistance.inMeters() / options.spacing.inMeters());        } else if (options.minPoints) {            numPoints = options.minPoints;        } else {            numPoints = 100;        }         if (options.maxPoints) {            numPoints = Math.min(numPoints, options.maxPoints);        }         const points: Coordinate[] = [];        for (let i = 0; i <= numPoints; i++) {            const fraction = i / numPoints;            const point = this.interpolate(fraction);            if (point) points.push(point);        }         return points;    };     extend = (distance: Distance): GreatCircle => {        const bearing = Azimuth.from(this.start).to(this.end).forward();        const endPoint = this.interpolate(1 + (distance.inMeters() / this.distance().inMeters()));        return endPoint ? GreatCircle.from(this.start).to(endPoint) : this;    };     midpoint = (): Coordinate =>         this.interpolate(0.5)!;     toString = (): string =>        `GreatCircle(${this.start} → ${this.end})`; }
|      +-- Point.ts: import { Coordinate } from "./Coordinate";  export class Point {    private constructor(        private readonly x: number,        private readonly y: number,        private readonly z?: number    ) {}     static at = (x: number, y: number, z?: number) =>        new Point(x, y, z);     get X(): number {        return this.x;    }     get Y(): number {        return this.y;    }     get Z(): number | undefined {        return this.z;    }     equals = (other: Point): boolean =>        this.x === other.x &&        this.y === other.y &&        this.z === other.z;     toString = (): string =>        `Point(${this.x}, ${this.y}${this.z ? `, ${this.z}` : ''})`; }
|      +-- Polygon.ts: import { Coordinate } from "./Coordinate"; import { Point } from "./Point";  export class Polygon {   // Coordinate-based   static fromCoordinates = (coords: Coordinate[]) => new Polygon(coords);    // Point-based    static fromPoints = (points: Point[]) => {       const coords = points.map(p =>            Coordinate.at(p.Y * 180/Math.PI, p.X * 180/Math.PI)       );       return new Polygon(coords);   };    rewind = (): Polygon => {       const points = this.coordinates.map(c => Point.fromCoordinate(c));       const fixed = this.ensureProperWindingPoints(points);       return Polygon.fromPoints(fixed);   };  }
|      +-- SmallCircle.js
|      +-- SmallCircle.ts: import { Coordinate } from './Coordinate'; import { Point } from './Point'; import { Distance } from './Distance'; import { Angle } from './Angle'; import { Sphere } from './Sphere';  export class SmallCircle {     private readonly centerPoint: Point;      private constructor(         private readonly center: Coordinate,         private readonly radius: Distance,         private readonly sphere: Sphere = Sphere.earth()     ) {         this.centerPoint = Point.fromCoordinate(center);     }      static withCenter = (center: Coordinate) => ({         radius: (radius: Distance) => new SmallCircle(center, radius)     });      withSphere = (sphere: Sphere): SmallCircle =>         new SmallCircle(this.center, this.radius, sphere);      circumference = (): Distance => {         const angularRadius = this.radius.inMeters() / (this.sphere.radius * 1000);         return new Distance(2 * Math.PI * this.sphere.radius * 1000 * Math.sin(angularRadius));     };      area = (): number => {         const angularRadius = this.radius.inMeters() / (this.sphere.radius * 1000);         return 2 * Math.PI * this.sphere.radius ** 2 * (1 - Math.cos(angularRadius));     };      generatePoints = (numPoints: number = 100): Coordinate[] => {         const points: Coordinate[] = [];         const angularRadius = this.radius.inMeters() / (this.sphere.radius * 1000);          for (let i = 0; i < numPoints; i++) {             const angle = (2 * Math.PI * i) / numPoints;             const latRad = Math.asin(                 Math.sin(this.centerPoint.Y) * Math.cos(angularRadius) +                 Math.cos(this.centerPoint.Y) * Math.sin(angularRadius) * Math.cos(angle)             );             const lonRad = this.centerPoint.X + Math.atan2(                 Math.sin(angle) * Math.sin(angularRadius) * Math.cos(this.centerPoint.Y),                 Math.cos(angularRadius) - Math.sin(this.centerPoint.Y) * Math.sin(latRad)             );              points.push(Coordinate.at(                 latRad * 180 / Math.PI,                 lonRad * 180 / Math.PI             ));         }          return points;     };      toString = (): string =>         `SmallCircle(center: ${this.center}, radius: ${this.radius})`; }
|      +-- Sphere.js
|      +-- Sphere.ts: import { Distance } from "./Distance";  export class Sphere {     private static readonly DEFAULT_RADIUS = Distance.fromKilometers(6371);      static getRadius = (radius?: Distance): Distance =>          radius ?? Sphere.DEFAULT_RADIUS;      static surfaceAreaFromRadius = (radius: Distance): number =>          4 * Math.PI * Math.pow(radius.inMeters() / 1000, 2);      static volumeFromRadius = (radius: Distance): number =>          (4/3) * Math.PI * Math.pow(radius.inMeters() / 1000, 3); }  // Usage: const radius = Sphere.getRadius();  // Default 6371km const customRadius = Sphere.getRadius(Distance.fromMiles(4000));
|      +-- SphericalTrigonometry.ts: import { Angle } from "./Angle"; import { Distance } from "./Distance";  // For Law of Sines/Cosines calculations, we should use Distance directly export class SphericalTrigonometry {   static lawOfCosines(arcA: Distance, arcB: Distance, angleC: Angle): Distance {       const a = arcA.inMeters();       const b = arcB.inMeters();       const C = angleC.toRadians();              const c = Math.sqrt(           Math.pow(a, 2) + Math.pow(b, 2) -            2 * a * b * Math.cos(C)       );        return new Distance(c);   }    static lawOfSines(angleA: Angle, angleB: Angle, arcC: Distance): Distance {       const A = angleA.toRadians();       const B = angleB.toRadians();       const C = Math.PI - (A + B);              const c = arcC.inMeters();       const a = Math.abs(c * Math.sin(A) / Math.sin(C));        return new Distance(a);   } }
|      +-- Triangle.js
|      -- Triangle.ts: import { Coordinate } from './Coordinate'; import { Point } from './Point'; import { Sphere } from './Sphere'; import { Distance } from './Distance'; import { Angle } from './Angle';  export class Triangle {     private readonly points: Point[];      private constructor(         private readonly vertices: [Coordinate, Coordinate, Coordinate],         private readonly sphere: Sphere = Sphere.earth()     ) {         this.points = vertices.map(v => Point.fromCoordinate(v));     }      static from = (a: Coordinate) => ({         to: (b: Coordinate) => ({             and: (c: Coordinate) => new Triangle([a, b, c])         })     });      withSphere = (sphere: Sphere): Triangle =>         new Triangle(this.vertices, sphere);      area = (): number => {         const angles = this.angles();         const sphericalExcess = angles.reduce((sum, angle) => sum + angle.degrees, 0) - 180;         return sphericalExcess * (Math.PI / 180) * this.sphere.radius ** 2;     };      perimeter = (): Distance => {         const sides = this.sides();         const totalMeters = sides.reduce((sum, side) => sum + side.inMeters(), 0);         return new Distance(totalMeters);     };      angles = (): [Angle, Angle, Angle] => {         return [0, 1, 2].map(i => {             const p1 = this.points[i];             const p2 = this.points[(i + 1) % 3];             const p3 = this.points[(i + 2) % 3];                          const v1 = this.vectorBetween(p1, p2);             const v2 = this.vectorBetween(p1, p3);             const angle = this.angleBetweenVectors(v1, v2);                          return new Angle(angle * (180 / Math.PI));         }) as [Angle, Angle, Angle];     };      sides = (): [Distance, Distance, Distance] => {         return [0, 1, 2].map(i => {             const start = this.points[i];             const end = this.points[(i + 1) % 3];             return this.sphericalDistance(start, end);         }) as [Distance, Distance, Distance];     };      private vectorBetween = (p1: Point, p2: Point): [number, number, number] => {         const x = Math.cos(p2.Y) * Math.cos(p2.X) - Math.cos(p1.Y) * Math.cos(p1.X);         const y = Math.cos(p2.Y) * Math.sin(p2.X) - Math.cos(p1.Y) * Math.sin(p1.X);         const z = Math.sin(p2.Y) - Math.sin(p1.Y);         return [x, y, z];     };      private angleBetweenVectors = (v1: [number, number, number], v2: [number, number, number]): number => {         const dot = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];         const mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);         const mag2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);         return Math.acos(dot / (mag1 * mag2));     };      private sphericalDistance = (p1: Point, p2: Point): Distance => {         const dLat = p2.Y - p1.Y;         const dLon = p2.X - p1.X;         const a = Math.sin(dLat/2) ** 2 +                   Math.cos(p1.Y) * Math.cos(p2.Y) *                   Math.sin(dLon/2) ** 2;         const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));         return new Distance(this.sphere.radius * 1000 * c);     };      toString = (): string =>         `Triangle(${this.vertices.map(v => v.toString()).join(' → ')})`; }
