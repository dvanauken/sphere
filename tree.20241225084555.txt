+-- benchmarks
|   --- README.md: # Performance Benchmarks
+-- docs
|   --- README.md: # API Documentation
+-- examples
|   --- README.md: # Usage Examples
+-- scripts
|   --- README.md: # Build Scripts
+-- src
|   +-- adapters
|   |   \-- geojson
|   |       --- Feature.ts: // Feature.ts import { GeometryCollection } from "./GeometryCollection.js"; import { LineString } from "./LineString.js"; import { MultiLineString } from "./MultiLineString.js"; import { MultiPoint } from "./MultiPoint.js"; import { MultiPolygon } from "./MultiPolygon.js"; import { Point } from "./Point.js"; import { Polygon } from "./Polygon.js"; export interface Feature { type: "Feature"; geometry: GeometryCollection | Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon; properties: { [key: string]: any }; }
|   |       --- FeatureCollection.ts: // FeatureCollection.ts import { Feature } from "./Feature.js"; export interface FeatureCollection { type: "FeatureCollection"; features: Feature[]; }
|   |       --- GeoConversionError.ts: import { Feature } from "./Feature.js"; export class GeoConversionError extends Error { constructor( message: string, public readonly sourceType?: string, public readonly targetType?: string, public readonly cause?: Error ) { super(message); this.name = 'GeoConversionError'; } } // Add validation and error handling to existing classes: export class TypeValidator { static validateFeature(feature: Feature): void { if (!feature.type || feature.type !== 'Feature') { throw new GeoConversionError('Invalid Feature type'); } if (!feature.geometry) { throw new GeoConversionError('Missing geometry'); } // Add more validation } static validateGeometry(geometry: any): void { // Geometry validation } }
|   |       --- GeoConverter.ts: import { Feature } from "./Feature.js"; import { GeoReader } from "./GeoReader.js"; import { GeoWriter } from "./GeoWriter.js"; export class GeoConverter { static toGeoJSON(input: any): Feature | Feature[] { if (Array.isArray(input)) { return GeoWriter.writeCollection(input); } return GeoWriter.write(input); } static fromGeoJSON(input: Feature | Feature[]): any { if (Array.isArray(input)) { return GeoReader.readCollection(input); } return GeoReader.read(input); } } /* Example usage: const feature = GeoConverter.toGeoJSON(greatCircle); const circle = GeoConverter.fromGeoJSON(feature); */
|   |       --- GeoReader.ts: import { Feature } from "./Feature.js"; import { GeoRegistry } from "./GeoRegistry.js"; export class GeoReader { static read(feature: Feature): any { return GeoRegistry.reverse(feature); } static readCollection(collection: Feature[]): any[] { return collection.map(f => GeoReader.read(f)); } }
|   |       --- GeoRegistry.ts: import { Feature } from "./Feature.js"; import { TypeConverter } from "./TypeConverter.js"; import { TypeMapping } from "./TypeMapping.js"; export class GeoRegistry { private static readonly converters = new Map<string, TypeConverter>(); static register(type: any, converter: TypeConverter): void { const geoType = TypeMapping.get(type); if (!geoType) throw new Error(`No mapping for type ${type.name}`); GeoRegistry.converters.set(type.name, converter); } static convert(source: any, target: string): any { const converter = GeoRegistry.converters.get(source.constructor.name); if (!converter) throw new Error(`No converter for ${source.constructor.name}`); return TypeConverter.toFeature(source); } static reverse(feature: Feature): any { return TypeConverter.fromFeature(feature); } }
|   |       --- GeoWriter.ts: import { Feature } from "./Feature.js"; import { GeoRegistry } from "./GeoRegistry.js"; export class GeoWriter { static write(source: any): Feature { return GeoRegistry.convert(source, 'Feature'); } static writeCollection(sources: any[]): Feature[] { return sources.map(s => GeoWriter.write(s)); } }
|   |       --- GeometryCollection.ts: import { LineString } from "./LineString.js"; import { MultiLineString } from "./MultiLineString.js"; import { MultiPoint } from "./MultiPoint.js"; import { MultiPolygon } from "./MultiPolygon.js"; import { Point } from "./Point.js"; import { Polygon } from "./Polygon.js"; // GeometryCollection.ts export interface GeometryCollection { type: "GeometryCollection"; geometries: Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection>; }
|   |       --- LineString.ts: import { Point } from "./Point.js"; export interface LineString { type: "LineString"; coordinates: Point['coordinates'][]; }
|   |       --- MultiLineString.ts: import { LineString } from "./LineString.js"; export interface MultiLineString { type: "MultiLineString"; coordinates: LineString['coordinates'][]; }
|   |       --- MultiPoint.ts: import { Point } from "./Point.js"; export interface MultiPoint { type: "MultiPoint"; coordinates: Point['coordinates'][]; }
|   |       --- MultiPolygon.ts: import { Polygon } from "./Polygon.js"; export interface MultiPolygon { type: "MultiPolygon"; coordinates: Polygon['coordinates'][]; }
|   |       --- Point.ts: // Point.ts export interface Point { type: "Point"; coordinates: [number, number]; // Longitude, Latitude }
|   |       --- Polygon.ts: import { LineString } from "./LineString.js"; export interface Polygon { type: "Polygon"; coordinates: LineString['coordinates'][]; // Array of linear rings }
|   |       --- TypeConverter.ts: import { Coordinate } from "../../core/models/Coordinate.js"; import { Distance } from "../../core/models/Distance.js"; import { GreatCircle } from "../../core/models/GreatCircle.js"; import { SmallCircle } from "../../core/models/SmallCircle.js"; import { Triangle } from "../../core/models/Triangle.js"; import { Feature } from "./Feature.js"; import { TypeMapping } from "./TypeMapping.js"; export class TypeConverter { static toFeature(source: any): Feature { const type = TypeMapping.get(source.constructor); if (!type) { throw new Error(`No mapping for type ${source.constructor.name}`); } try { switch(type.type) { case "Point": if (source instanceof Coordinate) { return { type: "Feature", geometry: { type: "Point", coordinates: [source.longitude, source.latitude] }, properties: {} }; } return { type: "Feature", geometry: { type: "Point", coordinates: [0, 0] // Default return }, properties: {} }; case "LineString": if (source instanceof GreatCircle) { const points = source.generatePoints({ minPoints: 100 }); return { type: "Feature", geometry: { type: "LineString", coordinates: points.map((p: Coordinate) => [p.longitude, p.latitude]) }, properties: { distance: source.distance().inMeters() } }; } return { type: "Feature", geometry: { type: "LineString", coordinates: [] }, properties: {} }; case "Polygon": if (source instanceof SmallCircle) { const points = source.generatePoints(100); points.push(points[0]); return { type: "Feature", geometry: { type: "Polygon", coordinates: [points.map((p: Coordinate) => [p.longitude, p.latitude])] }, properties: { radius: source.getRadius().inMeters(), area: source.area() } }; } if (source instanceof Triangle) { const vertices = source.vertices; const allVertices = [...vertices, vertices[0]]; return { type: "Feature", geometry: { type: "Polygon", coordinates: [allVertices.map((v: Coordinate) => [v.longitude, v.latitude])] }, properties: { area: source.area(), perimeter: source.perimeter().inMeters() } }; } return { type: "Feature", geometry: { type: "Polygon", coordinates: [[]] }, properties: {} }; } throw new Error(`Conversion not implemented for ${type.type}`); } catch (exception: any) { console.log('Conversion error:', exception); return { type: "Feature", geometry: { type: "Point", coordinates: [0, 0] }, properties: {} }; } } static fromFeature(feature: Feature): any { if (!feature.geometry) { throw new Error('Invalid Feature: missing geometry'); } try { switch(feature.geometry.type) { case "Point": const [lon, lat] = feature.geometry.coordinates; return Coordinate.at(lat, lon); case "LineString": const coords = feature.geometry.coordinates; if (coords.length < 2) { throw new Error('Invalid LineString: needs at least 2 points'); } const startCoord = Coordinate.at(coords[0][1], coords[0][0]); const endCoord = Coordinate.at(coords[coords.length - 1][1], coords[coords.length - 1][0]); return GreatCircle.from(startCoord).to(endCoord); case "Polygon": const vertices = feature.geometry.coordinates[0]; if (vertices.length === 4 && feature.properties?.area) { const points = vertices.slice(0, -1).map(([lon, lat]) => Coordinate.at(lat, lon)); return Triangle.from(points[0]).to(points[1]).and(points[2]); } else if (feature.properties?.radius) { const center = Coordinate.at(vertices[0][1], vertices[0][0]); const radius = new Distance(feature.properties.radius.inMeters()); return SmallCircle.withCenter(center).radius(radius); } throw new Error('Unsupported Polygon type'); } throw new Error(`Conversion not implemented for geometry type ${feature.geometry.type}`); } catch (exception: any) { console.log('Conversion error:', exception); return null; } } }
|   |       --- TypeMapping.ts: import { Coordinate } from "../../core/models/Coordinate.js"; import { GreatCircle } from "../../core/models/GreatCircle.js"; import { Point } from "../../core/models/Point.js"; import { SmallCircle } from "../../core/models/SmallCircle.js"; import { Triangle } from "../../core/models/Triangle.js"; export interface GeoType { type: string; coordinates: any; } export class TypeMapping { private static readonly map = new Map<any, GeoType>([ [Coordinate, { type: "Point", coordinates: [] }], [Point, { type: "Point", coordinates: [] }], [GreatCircle, { type: "LineString", coordinates: [] }], [SmallCircle, { type: "Polygon", coordinates: [] }], [Triangle, { type: "Polygon", coordinates: [] }] ]); static get(type: any): GeoType | null { const mapping = TypeMapping.map.get(type); if (!mapping) { return null; } return { ...mapping }; // Return a copy to prevent modification } static set(sourceType: any, geoType: GeoType): void { TypeMapping.map.set(sourceType, { ...geoType }); // Store a copy } static hasMapping(type: any): boolean { return TypeMapping.map.has(type); } static getAllMappings(): Map<any, GeoType> { return new Map(TypeMapping.map); // Return a copy } static getSourceTypeForGeoType(geoType: string): any[] { const results: any[] = []; TypeMapping.map.forEach((value, key) => { if (value.type === geoType) { results.push(key); } }); return results; } static registerMapping(sourceType: any, geoType: GeoType): void { if (!geoType.type || !["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"].includes(geoType.type)) { throw new Error(`Invalid GeoJSON type: ${geoType.type}`); } TypeMapping.set(sourceType, geoType); } }
|   +-- core
|   |   +-- coordinate
|   |   |   --- CoordinateSystem.ts: import { Coordinate } from "../models/Coordinate.js"; import { Point } from "../models/Point.js"; export class CoordinateSystem { static fromCoordinate(coord: Coordinate): Point { const lat = coord.latitude * (Math.PI / 180); const lon = coord.longitude * (Math.PI / 180); return Point.at(lat, lon); } static fromPoint(point: Point): Coordinate { const lat = point.X * (180 / Math.PI); const lon = point.Y * (180 / Math.PI); return Coordinate.at(lat, lon); } }
|   |   +-- errors
|   |   |   --- GeoConversionError.ts: import { GeoError } from "./GeoError.js"; export class GeoConversionError extends GeoError { constructor( message: string, public readonly sourceType: string, public readonly targetType: string, cause?: Error ) { super(message, cause); } }
|   |   |   --- GeoError.ts: export abstract class GeoError extends Error { constructor( message: string, public readonly cause?: Error ) { super(message); this.name = this.constructor.name; } }
|   |   |   --- GeoValidationError.ts: import { GeoError } from "./GeoError.js"; export class GeoValidationError extends GeoError { constructor( message: string, public readonly validationType: string, public readonly invalidValue: any, cause?: Error ) { super(message, cause); } }
|   |   |   --- index.ts: export * from './GeoError.js'; export * from './GeoConversionError.js'; export * from './GeoValidationError.js';
|   |   \-- models
|   |       --- Angle.ts: import { Arc } from "./Arc.js"; import { Distance } from './Distance.js'; // Angle.ts export class Angle { constructor(public readonly degrees: number) {} // Add toRadians method toRadians(): number { return this.degrees * (Math.PI / 180); } normalize(): number { return ((this.degrees % 360) + 360) % 360; } // Fix overload signatures static defineBy(a: Arc, b: Arc, c: Arc | Angle, aLength?: Distance, bLength?: Distance, cLength?: Distance): Angle { if (!aLength || !bLength || !cLength) { throw new Error("Length parameters are required"); } if (c instanceof Angle) { // Law of Sines case const sinA = Math.sin(c.toRadians()); const calculatedAngleDegrees = Math.asin( (aLength.inMeters() * Math.sin(c.toRadians())) / bLength.inMeters() ) * (180 / Math.PI); return new Angle(calculatedAngleDegrees); } else { // Law of Cosines case const cosC = ( Math.pow(aLength.inMeters(), 2) + Math.pow(bLength.inMeters(), 2) - Math.pow(cLength.inMeters(), 2) ) / (2 * aLength.inMeters() * bLength.inMeters()); const calculatedAngleDegrees = Math.acos(cosC) * (180 / Math.PI); return new Angle(calculatedAngleDegrees); } } toString(): string { return `Angle(${this.degrees} degrees)`; } }
|   |       --- Arc.ts: import { Angle } from "./Angle.js"; import { Coordinate } from "./Coordinate.js"; import { Distance } from "./Distance.js"; import { Sphere } from "./Sphere.js"; import { Point } from "./Point.js"; import { CoordinateSystem } from "../coordinate/CoordinateSystem.js"; export class Arc { private constructor( private readonly sphereRadius: Distance, private readonly centralAngle?: Angle, private readonly start?: Coordinate, private readonly end?: Coordinate ) { } static onSphere( sphereRadius: Distance = Sphere.getRadius(), centralAngle?: Angle ): Arc { return new Arc(sphereRadius, centralAngle); } static fromPoints( start: Coordinate, end: Coordinate, sphereRadius: Distance = Sphere.getRadius() ): Arc { return new Arc(sphereRadius, undefined, start, end); } length(): Distance { if (this.start && this.end) { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); // Calculate central angle using haversine formula const dLat = endPoint.Y - startPoint.Y; const dLon = endPoint.X - startPoint.X; const a = Math.sin(dLat / 2) ** 2 + Math.cos(startPoint.Y) * Math.cos(endPoint.Y) * Math.sin(dLon / 2) ** 2; const centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return new Distance(this.sphereRadius.inMeters() * centralAngle); } else if (this.centralAngle) { return new Distance(this.sphereRadius.inMeters() * this.centralAngle.toRadians()); } else { return new Distance(2 * Math.PI * this.sphereRadius.inMeters()); } } interpolate(fraction: number): Coordinate | undefined { if (fraction < 0 || fraction > 1) { throw new Error('Fraction must be between 0 and 1'); } if (this.start && this.end) { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const d = this.length().inMeters() / this.sphereRadius.inMeters(); const A = Math.sin((1 - fraction) * d) / Math.sin(d); const B = Math.sin(fraction * d) / Math.sin(d); const x = A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) + B * Math.cos(endPoint.Y) * Math.cos(endPoint.X); const y = A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) + B * Math.cos(endPoint.Y) * Math.sin(endPoint.X); const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y); const lat3 = Math.atan2(z, Math.sqrt(x * x + y * y)); const lon3 = Math.atan2(y, x); return CoordinateSystem.fromPoint(Point.at(lon3, lat3)); } return undefined; } }
|   |       --- Azimuth.ts: import { Coordinate } from './Coordinate.js'; import { Angle } from './Angle.js'; import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; export class Azimuth { private constructor( private readonly start: Coordinate, private readonly end: Coordinate ) {} static from = (start: Coordinate) => ({ to: (end: Coordinate) => new Azimuth(start, end) }); forward = (): Angle => { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const dLon = endPoint.X - startPoint.X; const y = Math.sin(dLon) * Math.cos(endPoint.Y); const x = Math.cos(startPoint.Y) * Math.sin(endPoint.Y) - Math.sin(startPoint.Y) * Math.cos(endPoint.Y) * Math.cos(dLon); const azimuthRadians = Math.atan2(y, x); const azimuthDegrees = (azimuthRadians * (180 / Math.PI) + 360) % 360; return new Angle(azimuthDegrees); }; reverse = (): Angle => { const forward = this.forward().degrees; return new Angle((forward + 180) % 360); }; toString = (): string => `Azimuth(${this.start} → ${this.end})`; }
|   |       --- Bearing.ts: import { Coordinate } from './Coordinate.js'; import { Angle } from './Angle.js'; import { Azimuth } from './Azimuth.js'; export class Bearing { private constructor( private readonly start: Coordinate, private readonly end: Coordinate ) {} static from = (start: Coordinate) => ({ to: (end: Coordinate) => new Bearing(start, end) }); initial = (): Angle => Azimuth.from(this.start).to(this.end).forward(); final = (): Angle => Azimuth.from(this.start).to(this.end).reverse(); toString = (): string => `Bearing(${this.start} → ${this.end})`; }
|   |       --- Coordinate.ts: export class Coordinate { public constructor( private readonly lat: number, private readonly lon: number, private readonly alt?: number ) { if (lat < -90 || lat > 90) { throw new Error('Latitude must be between -90 and 90 degrees'); } if (lon < -180 || lon > 180) { throw new Error('Longitude must be between -180 and 180 degrees'); } } static at = (lat: number, lon: number, alt?: number) => new Coordinate(lat, lon, alt); get latitude(): number { return this.lat; } get longitude(): number { return this.lon; } get altitude(): number | undefined { return this.alt; } equals = (other: Coordinate): boolean => this.lat === other.lat && this.lon === other.lon && this.alt === other.alt; toString = (): string => `(${this.lat}°, ${this.lon}°${this.alt ? `, ${this.alt}m` : ''})`; }
|   |       --- Distance.ts: // Angle.ts remains the same... // Distance.ts export class Distance { private static readonly METERS_TO_NM = 0.000539957; constructor(private readonly meters: number) {} inMeters(): number { return this.meters; } inKilometers(): number { return this.meters / 1000; } inCentimeters(): number { return this.meters * 100; } inMiles(): number { return this.meters * 0.000621371; } inFeet(): number { return this.meters * 3.28084; } inYards(): number { return this.meters * 1.09361; } inNauticalMiles(): number { return this.meters * Distance.METERS_TO_NM; } static fromMeters(meters: number): Distance { return new Distance(meters); } static fromKilometers(km: number): Distance { return new Distance(km * 1000); } static fromMiles(miles: number): Distance { return new Distance(miles / 0.000621371); } static fromNauticalMiles(nm: number): Distance { return new Distance(nm / Distance.METERS_TO_NM); } static fromFeet(feet: number): Distance { return new Distance(feet / 3.28084); } toString(): string { return `${this.inKilometers().toFixed(2)} km`; } toFormat(unit: 'km' | 'mi' | 'nm' | 'ft' | 'm'): string { switch(unit) { case 'km': return `${this.inKilometers().toFixed(2)} km`; case 'mi': return `${this.inMiles().toFixed(2)} mi`; case 'nm': return `${this.inNauticalMiles().toFixed(2)} nm`; case 'ft': return `${this.inFeet().toFixed(2)} ft`; case 'm': return `${this.inMeters().toFixed(2)} m`; } } }
|   |       --- GreatCircle.ts: import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; import { Azimuth } from './Azimuth.js'; import { Coordinate } from './Coordinate.js'; import { Distance } from './Distance.js'; import { Point } from './Point.js'; import { Sphere } from './Sphere.js'; interface PointGenerationOptions { spacing?: Distance; minPoints?: number; maxPoints?: number; } export class GreatCircle { public constructor( private readonly start: Coordinate, private readonly end: Coordinate, private readonly sphereRadius: Distance = Sphere.getRadius() ) {} static from(start: Coordinate) { return { to: (end: Coordinate) => new GreatCircle(start, end) }; } withSphere = (sphereRadius: Distance): GreatCircle => new GreatCircle(this.start, this.end, sphereRadius); distance = (): Distance => { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const dLat = endPoint.Y - startPoint.Y; const dLon = endPoint.X - startPoint.X; const a = Math.sin(dLat/2) ** 2 + Math.cos(startPoint.Y) * Math.cos(endPoint.Y) * Math.sin(dLon/2) ** 2; const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return new Distance(this.sphereRadius.inMeters() * c); }; interpolate = (fraction: number): Coordinate | undefined => { if (fraction < 0 || fraction > 1) { throw new Error('Fraction must be between 0 and 1'); } const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const d = this.distance().inMeters() / this.sphereRadius.inMeters(); const A = Math.sin((1 - fraction) * d) / Math.sin(d); const B = Math.sin(fraction * d) / Math.sin(d); const x = A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) + B * Math.cos(endPoint.Y) * Math.cos(endPoint.X); const y = A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) + B * Math.cos(endPoint.Y) * Math.sin(endPoint.X); const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y); const lat = Math.atan2(z, Math.sqrt(x * x + y * y)); const lon = Math.atan2(y, x); return CoordinateSystem.fromPoint(Point.at(lon, lat)); }; // Rest of the methods remain unchanged generatePoints = (options: PointGenerationOptions): Coordinate[] => { const totalDistance = this.distance(); let numPoints: number; if (options.spacing) { numPoints = Math.ceil(totalDistance.inMeters() / options.spacing.inMeters()); } else if (options.minPoints) { numPoints = options.minPoints; } else { numPoints = 100; } if (options.maxPoints) { numPoints = Math.min(numPoints, options.maxPoints); } const points: Coordinate[] = []; for (let i = 0; i <= numPoints; i++) { const fraction = i / numPoints; const point = this.interpolate(fraction); if (point) points.push(point); } return points; }; extend = (distance: Distance): GreatCircle => { const bearing = Azimuth.from(this.start).to(this.end).forward(); const endPoint = this.interpolate(1 + (distance.inMeters() / this.distance().inMeters())); return endPoint ? GreatCircle.from(this.start).to(endPoint) : this; }; midpoint = (): Coordinate => this.interpolate(0.5)!; toString = (): string => `GreatCircle(${this.start} → ${this.end})`; }
|   |       --- Point.ts: import { Coordinate } from "./Coordinate.js"; export class Point { private constructor( private readonly x: number, private readonly y: number, private readonly z?: number ) {} static at = (x: number, y: number, z?: number) => new Point(x, y, z); get X(): number { return this.x; } get Y(): number { return this.y; } get Z(): number | undefined { return this.z; } equals = (other: Point): boolean => this.x === other.x && this.y === other.y && this.z === other.z; toString = (): string => `Point(${this.x}, ${this.y}${this.z ? `, ${this.z}` : ''})`; }
|   |       --- Polygon.ts: import { CoordinateSystem } from "../coordinate/CoordinateSystem.js"; import { Coordinate } from "./Coordinate.js"; import { Point } from "./Point.js"; export class Polygon { constructor(private readonly vertices: Coordinate[]) { if (vertices.length < 3) { throw new Error("Polygon must have at least 3 vertices"); } } // Coordinate-based constructor static fromCoordinates = (coords: Coordinate[]): Polygon => new Polygon(coords); // Point-based constructor static fromPoints = (points: Point[]): Polygon => { const coords = points.map(p => CoordinateSystem.fromPoint(p) ); return new Polygon(coords); }; getVertices = (): Coordinate[] => this.vertices; rewind = (): Polygon => { const points = this.vertices.map(c => CoordinateSystem.fromCoordinate(c)); const fixed = this.ensureProperWindingPoints(points); return Polygon.fromPoints(fixed); }; private ensureProperWindingPoints = (points: Point[]): Point[] => { // Calculate the signed area let area = 0; for (let i = 0; i < points.length; i++) { const j = (i + 1) % points.length; area += points[i].X * points[j].Y - points[j].X * points[i].Y; } // If area is negative (clockwise), reverse the points if (area > 0) { return [...points].reverse(); } return points; }; toString = (): string => `Polygon(${this.vertices.length} vertices)`; }
|   |       --- SmallCircle.ts: import { Coordinate } from './Coordinate.js'; import { Point } from './Point.js'; import { Distance } from './Distance.js'; import { Sphere } from './Sphere.js'; import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; export class SmallCircle { private readonly centerPoint: Point; private constructor( private readonly center: Coordinate, private readonly circleRadius: Distance, private readonly sphereRadius: Distance = Sphere.getRadius() ) { this.centerPoint = CoordinateSystem.fromCoordinate(center); } static withCenter = (center: Coordinate) => ({ radius: (radius: Distance) => new SmallCircle(center, radius) }); withSphere = (sphere: Sphere): SmallCircle => new SmallCircle(this.center, this.circleRadius, Sphere.getRadius()); circumference = (): Distance => { const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters(); return new Distance(2 * Math.PI * this.sphereRadius.inMeters() * Math.sin(angularRadius)); }; area = (): number => { const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters(); const sphereRadiusKm = this.sphereRadius.inMeters() / 1000; return 2 * Math.PI * Math.pow(sphereRadiusKm, 2) * (1 - Math.cos(angularRadius)); }; generatePoints = (numPoints: number = 100): Coordinate[] => { const points: Coordinate[] = []; const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters(); for (let i = 0; i < numPoints; i++) { const angle = (2 * Math.PI * i) / numPoints; const latRad = Math.asin( Math.sin(this.centerPoint.Y) * Math.cos(angularRadius) + Math.cos(this.centerPoint.Y) * Math.sin(angularRadius) * Math.cos(angle) ); const lonRad = this.centerPoint.X + Math.atan2( Math.sin(angle) * Math.sin(angularRadius) * Math.cos(this.centerPoint.Y), Math.cos(angularRadius) - Math.sin(this.centerPoint.Y) * Math.sin(latRad) ); points.push(CoordinateSystem.fromPoint(Point.at(lonRad, latRad))); } return points; }; getCenter = (): Coordinate => this.center; getRadius = (): Distance => this.circleRadius; toString = (): string => `SmallCircle(center: ${this.center}, radius: ${this.circleRadius})`; }
|   |       --- Sphere.ts: import { Distance } from "./Distance.js"; export class Sphere { private static readonly DEFAULT_RADIUS = Distance.fromKilometers(6371); static getRadius = (radius?: Distance): Distance => radius ?? Sphere.DEFAULT_RADIUS; static surfaceAreaFromRadius = (radius: Distance): number => 4 * Math.PI * Math.pow(radius.inMeters() / 1000, 2); static volumeFromRadius = (radius: Distance): number => (4/3) * Math.PI * Math.pow(radius.inMeters() / 1000, 3); } // // Usage: // const radius = Sphere.getRadius(); // Default 6371km // const customRadius = Sphere.getRadius(Distance.fromMiles(4000));
|   |       --- SphericalTrigonometry.ts: import { Angle } from "./Angle.js"; import { Distance } from "./Distance.js"; // For Law of Sines/Cosines calculations, we should use Distance directly export class SphericalTrigonometry { static lawOfCosines(arcA: Distance, arcB: Distance, angleC: Angle): Distance { const a = arcA.inMeters(); const b = arcB.inMeters(); const C = angleC.toRadians(); const c = Math.sqrt( Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b * Math.cos(C) ); return new Distance(c); } static lawOfSines(angleA: Angle, angleB: Angle, arcC: Distance): Distance { const A = angleA.toRadians(); const B = angleB.toRadians(); const C = Math.PI - (A + B); const c = arcC.inMeters(); const a = Math.abs(c * Math.sin(A) / Math.sin(C)); return new Distance(a); } }
|   |       --- Triangle.ts: import { Coordinate } from './Coordinate.js'; import { Point } from './Point.js'; import { Sphere } from './Sphere.js'; import { Distance } from './Distance.js'; import { Angle } from './Angle.js'; import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; export class Triangle { private readonly points: Point[]; public constructor( private readonly triangleVertices: [Coordinate, Coordinate, Coordinate], private readonly sphereRadius: Distance = Sphere.getRadius() ) { this.points = triangleVertices.map(v => CoordinateSystem.fromCoordinate(v)); } static from = (a: Coordinate) => ({ to: (b: Coordinate) => ({ and: (c: Coordinate) => new Triangle([a, b, c]) }) }); withSphere = (sphere: Sphere): Triangle => new Triangle(this.triangleVertices, Sphere.getRadius()); area = (): number => { const angles = this.angles(); const sphericalExcess = angles.reduce((sum, angle) => sum + angle.degrees, 0) - 180; return sphericalExcess * (Math.PI / 180) * Math.pow(this.sphereRadius.inMeters() / 1000, 2); }; perimeter = (): Distance => { const sides = this.sides(); const totalMeters = sides.reduce((sum, side) => sum + side.inMeters(), 0); return new Distance(totalMeters); }; angles = (): [Angle, Angle, Angle] => { return [0, 1, 2].map(i => { const p1 = this.points[i]; const p2 = this.points[(i + 1) % 3]; const p3 = this.points[(i + 2) % 3]; const v1 = this.vectorBetween(p1, p2); const v2 = this.vectorBetween(p1, p3); const angle = this.angleBetweenVectors(v1, v2); return new Angle(angle * (180 / Math.PI)); }) as [Angle, Angle, Angle]; }; sides = (): [Distance, Distance, Distance] => { return [0, 1, 2].map(i => { const start = this.points[i]; const end = this.points[(i + 1) % 3]; return this.sphericalDistance(start, end); }) as [Distance, Distance, Distance]; }; private vectorBetween = (p1: Point, p2: Point): [number, number, number] => { // Points are already in radians since we converted them in constructor const x = Math.cos(p2.Y) * Math.cos(p2.X) - Math.cos(p1.Y) * Math.cos(p1.X); const y = Math.cos(p2.Y) * Math.sin(p2.X) - Math.cos(p1.Y) * Math.sin(p1.X); const z = Math.sin(p2.Y) - Math.sin(p1.Y); return [x, y, z]; }; private angleBetweenVectors = (v1: [number, number, number], v2: [number, number, number]): number => { const dot = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]; const mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]); const mag2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]); return Math.acos(dot / (mag1 * mag2)); }; private sphericalDistance = (p1: Point, p2: Point): Distance => { // Points are already in radians from CoordinateSystem conversion const dLat = p2.Y - p1.Y; const dLon = p2.X - p1.X; const a = Math.sin(dLat/2) ** 2 + Math.cos(p1.Y) * Math.cos(p2.Y) * Math.sin(dLon/2) ** 2; const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); return new Distance(this.sphereRadius.inMeters() * c); }; get vertices(): [Coordinate, Coordinate, Coordinate] { return this.triangleVertices; } toString = (): string => `Triangle(${this.triangleVertices.map(v => v.toString()).join(' → ')})`; }
|   +-- utils
|   |   +-- conversion
|   |   \-- math
|   --- index.ts: // Main entry point for the spherical geometry library // Export core models export * from './core/models/Angle.js'; export * from './core/models/Arc.js'; export * from './core/models/Azimuth.js'; export * from './core/models/Bearing.js'; export * from './core/models/Coordinate.js'; export * from './core/models/Distance.js'; export * from './core/models/GreatCircle.js'; export * from './core/models/Point.js'; export * from './core/models/Polygon.js'; export * from './core/models/SmallCircle.js'; export * from './core/models/Sphere.js'; export * from './core/models/SphericalTrigonometry.js'; export * from './core/models/Triangle.js'; // Export coordinate system utilities export * from './core/coordinate/CoordinateSystem.js'; // Export error types export * from './core/errors/GeoError.js'; export * from './core/errors/GeoConversionError.js'; export * from './core/errors/GeoValidationError.js'; // Export GeoJSON adapters export * from './adapters/geojson/Feature.js'; export * from './adapters/geojson/FeatureCollection.js'; export * from './adapters/geojson/GeoConverter.js'; export * from './adapters/geojson/TypeConverter.js'; export * from './adapters/geojson/TypeMapping.js';
+-- test
|   +-- __fixtures__
|   |   --- angles.d.ts: import { Angle } from "../../src/core/models/Angle.js"; export declare const ZERO: Angle; export declare const RIGHT_ANGLE: Angle; export declare const STRAIGHT_ANGLE: Angle; export declare const FULL_CIRCLE: Angle; export declare const QUAD_1_MID: Angle; export declare const QUAD_2_MID: Angle; export declare const QUAD_3_MID: Angle; export declare const QUAD_4_MID: Angle; export declare const NORTH: Angle; export declare const EAST: Angle; export declare const SOUTH: Angle; export declare const WEST: Angle; export declare const EQUILATERAL: Angle; export declare const GOLDEN: Angle; export declare const HALF_TURN: Angle; export declare const THIRD_TURN: Angle; export declare const ACUTE: Angle; export declare const OBTUSE: Angle; export declare const REFLEX: Angle; export declare const NEGATIVE: Angle; export declare const OVER_360: Angle; export declare const UNDER_NEG_360: Angle;
|   |   --- angles.js: // Common angles import { Angle } from "../../src/core/models/Angle.js"; // Common Angles export const ZERO = new Angle(0); export const RIGHT_ANGLE = new Angle(90); export const STRAIGHT_ANGLE = new Angle(180); export const FULL_CIRCLE = new Angle(360); // Quadrant Angles export const QUAD_1_MID = new Angle(45); // Northeast export const QUAD_2_MID = new Angle(135); // Northwest export const QUAD_3_MID = new Angle(225); // Southwest export const QUAD_4_MID = new Angle(315); // Southeast // Navigation Angles export const NORTH = new Angle(0); export const EAST = new Angle(90); export const SOUTH = new Angle(180); export const WEST = new Angle(270); // Special Angles export const EQUILATERAL = new Angle(60); // Angle in equilateral triangle export const GOLDEN = new Angle(137.5); // Golden angle export const HALF_TURN = new Angle(180); // Half turn export const THIRD_TURN = new Angle(120); // One third of a circle // Test Cases export const ACUTE = new Angle(45); export const OBTUSE = new Angle(135); export const REFLEX = new Angle(270); // Edge Cases export const NEGATIVE = new Angle(-45); export const OVER_360 = new Angle(400); export const UNDER_NEG_360 = new Angle(-400);
|   |   --- angles.ts: // Common angles import { Angle } from "../../src/core/models/Angle.js"; // Common Angles export const ZERO = new Angle(0); export const RIGHT_ANGLE = new Angle(90); export const STRAIGHT_ANGLE = new Angle(180); export const FULL_CIRCLE = new Angle(360); // Quadrant Angles export const QUAD_1_MID = new Angle(45); // Northeast export const QUAD_2_MID = new Angle(135); // Northwest export const QUAD_3_MID = new Angle(225); // Southwest export const QUAD_4_MID = new Angle(315); // Southeast // Navigation Angles export const NORTH = new Angle(0); export const EAST = new Angle(90); export const SOUTH = new Angle(180); export const WEST = new Angle(270); // Special Angles export const EQUILATERAL = new Angle(60); // Angle in equilateral triangle export const GOLDEN = new Angle(137.5); // Golden angle export const HALF_TURN = new Angle(180); // Half turn export const THIRD_TURN = new Angle(120); // One third of a circle // Test Cases export const ACUTE = new Angle(45); export const OBTUSE = new Angle(135); export const REFLEX = new Angle(270); // Edge Cases export const NEGATIVE = new Angle(-45); export const OVER_360 = new Angle(400); export const UNDER_NEG_360 = new Angle(-400);
|   |   --- coordinates.d.ts: import { Coordinate } from "../../src/index.js"; export declare const LONDON: Coordinate; export declare const NEW_YORK: Coordinate; export declare const TOKYO: Coordinate; export declare const SYDNEY: Coordinate; export declare const PARIS: Coordinate; export declare const LOS_ANGELES: Coordinate; export declare const NORTH_POLE: Coordinate; export declare const SOUTH_POLE: Coordinate; export declare const EQUATOR_PRIME: Coordinate; export declare const EQUATOR_180: Coordinate; export declare const EQUATOR_MINUS_180: Coordinate; export declare const MOUNT_EVEREST: Coordinate; export declare const KILIMANJARO: Coordinate; export declare const MOUNT_MCKINLEY: Coordinate; export declare const MAX_LAT: Coordinate; export declare const MIN_LAT: Coordinate; export declare const MAX_LON: Coordinate; export declare const MIN_LON: Coordinate; export declare const QUAD_1: Coordinate; export declare const QUAD_2: Coordinate; export declare const QUAD_3: Coordinate; export declare const QUAD_4: Coordinate; export declare const TRIANGLE_VERTEX_1: Coordinate; export declare const TRIANGLE_VERTEX_2: Coordinate; export declare const TRIANGLE_VERTEX_3: Coordinate; export declare const CIRCLE_CENTER: Coordinate; export declare const CIRCLE_POINT: Coordinate;
|   |   --- coordinates.js: // Common test coordinates import { Coordinate } from "../../src/index.js"; // Major Cities export const LONDON = new Coordinate(51.5074, -0.1278); export const NEW_YORK = new Coordinate(40.7128, -74.0060); export const TOKYO = new Coordinate(35.6762, 139.6503); export const SYDNEY = new Coordinate(33.8688, 151.2093); export const PARIS = new Coordinate(48.8566, 2.3522); export const LOS_ANGELES = new Coordinate(34.0522, -118.2437); // Geographic Points of Interest export const NORTH_POLE = new Coordinate(90, 0); export const SOUTH_POLE = new Coordinate(-90, 0); export const EQUATOR_PRIME = new Coordinate(0, 0); // Equator at Prime Meridian export const EQUATOR_180 = new Coordinate(0, 180); // Equator at 180° longitude export const EQUATOR_MINUS_180 = new Coordinate(0, -180); // Equator at -180° longitude // Mountain Peaks export const MOUNT_EVEREST = new Coordinate(27.9881, 86.9250, 8848); export const KILIMANJARO = new Coordinate(-3.0674, 37.3556, 5895); export const MOUNT_MCKINLEY = new Coordinate(63.0695, -151.0074, 6190); // Edge Cases export const MAX_LAT = new Coordinate(90, 0); export const MIN_LAT = new Coordinate(-90, 0); export const MAX_LON = new Coordinate(0, 180); export const MIN_LON = new Coordinate(0, -180); // Test Points at Various Quadrants export const QUAD_1 = new Coordinate(45, 45); // Northeast export const QUAD_2 = new Coordinate(45, -45); // Northwest export const QUAD_3 = new Coordinate(-45, -45); // Southwest export const QUAD_4 = new Coordinate(-45, 45); // Southeast // Points for Triangle Testing export const TRIANGLE_VERTEX_1 = new Coordinate(0, 0); export const TRIANGLE_VERTEX_2 = new Coordinate(0, 1); export const TRIANGLE_VERTEX_3 = new Coordinate(1, 0); // Points for Small Circle Testing export const CIRCLE_CENTER = new Coordinate(0, 0); export const CIRCLE_POINT = new Coordinate(0, 1);
|   |   --- coordinates.ts: // Common test coordinates import { Coordinate } from "../../src/core/models/Coordinate"; // Major Cities export const LONDON = new Coordinate(51.5074, -0.1278); export const NEW_YORK = new Coordinate(40.7128, -74.0060); export const TOKYO = new Coordinate(35.6762, 139.6503); export const SYDNEY = new Coordinate(33.8688, 151.2093); export const PARIS = new Coordinate(48.8566, 2.3522); export const LOS_ANGELES = new Coordinate(34.0522, -118.2437); // Geographic Points of Interest export const NORTH_POLE = new Coordinate(90, 0); export const SOUTH_POLE = new Coordinate(-90, 0); export const EQUATOR_PRIME = new Coordinate(0, 0); // Equator at Prime Meridian export const EQUATOR_180 = new Coordinate(0, 180); // Equator at 180° longitude export const EQUATOR_MINUS_180 = new Coordinate(0, -180); // Equator at -180° longitude // Mountain Peaks export const MOUNT_EVEREST = new Coordinate(27.9881, 86.9250, 8848); export const KILIMANJARO = new Coordinate(-3.0674, 37.3556, 5895); export const MOUNT_MCKINLEY = new Coordinate(63.0695, -151.0074, 6190); // Edge Cases export const MAX_LAT = new Coordinate(90, 0); export const MIN_LAT = new Coordinate(-90, 0); export const MAX_LON = new Coordinate(0, 180); export const MIN_LON = new Coordinate(0, -180); // Test Points at Various Quadrants export const QUAD_1 = new Coordinate(45, 45); // Northeast export const QUAD_2 = new Coordinate(45, -45); // Northwest export const QUAD_3 = new Coordinate(-45, -45); // Southwest export const QUAD_4 = new Coordinate(-45, 45); // Southeast // Points for Triangle Testing export const TRIANGLE_VERTEX_1 = new Coordinate(0, 0); export const TRIANGLE_VERTEX_2 = new Coordinate(0, 1); export const TRIANGLE_VERTEX_3 = new Coordinate(1, 0); // Points for Small Circle Testing export const CIRCLE_CENTER = new Coordinate(0, 0); export const CIRCLE_POINT = new Coordinate(0, 1);
|   |   --- distances.d.ts: import { Distance } from "../../src/index.js"; export declare const ONE_KILOMETER: Distance; export declare const ONE_MILE: Distance; export declare const ONE_NAUTICAL_MILE: Distance; export declare const EARTH_RADIUS: Distance; export declare const EARTH_EQUATORIAL_RADIUS: Distance; export declare const EARTH_POLAR_RADIUS: Distance; export declare const EARTH_CIRCUMFERENCE: Distance; export declare const LONDON_TO_PARIS: Distance; export declare const NEW_YORK_TO_LOS_ANGELES: Distance; export declare const SYDNEY_TO_TOKYO: Distance; export declare const TINY_DISTANCE: Distance; export declare const SMALL_DISTANCE: Distance; export declare const MEDIUM_DISTANCE: Distance; export declare const LARGE_DISTANCE: Distance; export declare const HUGE_DISTANCE: Distance; export declare const ZERO_DISTANCE: Distance; export declare const QUARTER_EARTH: Distance; export declare const HALF_EARTH: Distance;
|   |   --- distances.js: // Pre-calculated distances import { Distance } from "../../src/index.js"; // Common Distances export const ONE_KILOMETER = Distance.fromKilometers(1); export const ONE_MILE = Distance.fromMiles(1); export const ONE_NAUTICAL_MILE = Distance.fromNauticalMiles(1); // Earth-related Distances export const EARTH_RADIUS = Distance.fromKilometers(6371); // Average Earth radius export const EARTH_EQUATORIAL_RADIUS = Distance.fromKilometers(6378.137); // WGS84 equatorial radius export const EARTH_POLAR_RADIUS = Distance.fromKilometers(6356.752); // WGS84 polar radius export const EARTH_CIRCUMFERENCE = Distance.fromKilometers(40075.017); // Earth's circumference at equator // Pre-calculated Real-World Distances export const LONDON_TO_PARIS = Distance.fromKilometers(344); // ~344 km export const NEW_YORK_TO_LOS_ANGELES = Distance.fromKilometers(3936); // ~3,936 km export const SYDNEY_TO_TOKYO = Distance.fromKilometers(7832); // ~7,832 km // Common Test Distances export const TINY_DISTANCE = Distance.fromMeters(1); export const SMALL_DISTANCE = Distance.fromKilometers(1); export const MEDIUM_DISTANCE = Distance.fromKilometers(100); export const LARGE_DISTANCE = Distance.fromKilometers(1000); export const HUGE_DISTANCE = Distance.fromKilometers(10000); // Special Case Distances export const ZERO_DISTANCE = Distance.fromMeters(0); export const QUARTER_EARTH = Distance.fromKilometers(10018.75); // One quarter of Earth's circumference export const HALF_EARTH = Distance.fromKilometers(20037.5); // Half of Earth's circumference
|   |   --- distances.ts: // Pre-calculated distances import { Distance } from "../../src/index.js"; // Common Distances export const ONE_KILOMETER = Distance.fromKilometers(1); export const ONE_MILE = Distance.fromMiles(1); export const ONE_NAUTICAL_MILE = Distance.fromNauticalMiles(1); // Earth-related Distances export const EARTH_RADIUS = Distance.fromKilometers(6371); // Average Earth radius export const EARTH_EQUATORIAL_RADIUS = Distance.fromKilometers(6378.137); // WGS84 equatorial radius export const EARTH_POLAR_RADIUS = Distance.fromKilometers(6356.752); // WGS84 polar radius export const EARTH_CIRCUMFERENCE = Distance.fromKilometers(40075.017); // Earth's circumference at equator // Pre-calculated Real-World Distances export const LONDON_TO_PARIS = Distance.fromKilometers(344); // ~344 km export const NEW_YORK_TO_LOS_ANGELES = Distance.fromKilometers(3936); // ~3,936 km export const SYDNEY_TO_TOKYO = Distance.fromKilometers(7832); // ~7,832 km // Common Test Distances export const TINY_DISTANCE = Distance.fromMeters(1); export const SMALL_DISTANCE = Distance.fromKilometers(1); export const MEDIUM_DISTANCE = Distance.fromKilometers(100); export const LARGE_DISTANCE = Distance.fromKilometers(1000); export const HUGE_DISTANCE = Distance.fromKilometers(10000); // Special Case Distances export const ZERO_DISTANCE = Distance.fromMeters(0); export const QUARTER_EARTH = Distance.fromKilometers(10018.75); // One quarter of Earth's circumference export const HALF_EARTH = Distance.fromKilometers(20037.5); // Half of Earth's circumference
|   +-- __helpers__
|   |   --- assertions.d.ts: import { Distance, Angle, Coordinate } from "../../src/index.js"; export declare function assertDistanceNearlyEqual(actual: Distance, expected: Distance, toleranceMeters?: number, message?: string): void; export declare function assertAngleNearlyEqual(actual: Angle, expected: Angle, toleranceDegrees?: number, message?: string): void; export declare function assertCoordinateNearlyEqual(actual: Coordinate, expected: Coordinate, toleranceDegrees?: number, message?: string): void; export declare function assertAreaNearlyEqual(actual: number, expected: number, toleranceKm2?: number, message?: string): void; export declare function assertBearingNearlyEqual(actual: Angle, expected: Angle, toleranceDegrees?: number, message?: string): void;
|   |   --- assertions.js: // Custom assertions import { expect } from "vitest"; // Distance assertions export function assertDistanceNearlyEqual(actual, expected, toleranceMeters = 1, message) { const diff = Math.abs(actual.inMeters() - expected.inMeters()); expect(diff, message || `Expected distance to be within ${toleranceMeters}m of ${expected.inMeters()}m`) .toBeLessThanOrEqual(toleranceMeters); } // Angle assertions export function assertAngleNearlyEqual(actual, expected, toleranceDegrees = 0.1, message) { const diff = Math.abs(actual.degrees - expected.degrees) % 360; const smallestDiff = Math.min(diff, 360 - diff); expect(smallestDiff, message || `Expected angle to be within ${toleranceDegrees}° of ${expected.degrees}°`) .toBeLessThanOrEqual(toleranceDegrees); } // Coordinate assertions export function assertCoordinateNearlyEqual(actual, expected, toleranceDegrees = 0.0001, message) { const latDiff = Math.abs(actual.latitude - expected.latitude); const lonDiff = Math.abs(actual.longitude - expected.longitude); expect(latDiff, message || `Latitude difference exceeds tolerance`) .toBeLessThanOrEqual(toleranceDegrees); expect(lonDiff, message || `Longitude difference exceeds tolerance`) .toBeLessThanOrEqual(toleranceDegrees); if (actual.altitude !== undefined && expected.altitude !== undefined) { const altDiff = Math.abs(actual.altitude - expected.altitude); expect(altDiff, message || `Altitude difference exceeds tolerance`) .toBeLessThanOrEqual(1); // 1 meter tolerance for altitude } } // Area assertions (for spherical geometry) export function assertAreaNearlyEqual(actual, expected, toleranceKm2 = 1, message) { const diff = Math.abs(actual - expected); expect(diff, message || `Expected area to be within ${toleranceKm2}km² of ${expected}km²`) .toBeLessThanOrEqual(toleranceKm2); } // Bearing/Azimuth assertions export function assertBearingNearlyEqual(actual, expected, toleranceDegrees = 0.1, message) { let diff = Math.abs(actual.degrees - expected.degrees) % 360; if (diff > 180) diff = 360 - diff; expect(diff, message || `Expected bearing to be within ${toleranceDegrees}° of ${expected.degrees}°`) .toBeLessThanOrEqual(toleranceDegrees); }
|   |   --- assertions.ts: // Custom assertions import { expect } from "vitest"; import { Distance, Angle, Coordinate } from "../../src/index.js"; // Distance assertions export function assertDistanceNearlyEqual( actual: Distance, expected: Distance, toleranceMeters: number = 1, message?: string ) { const diff = Math.abs(actual.inMeters() - expected.inMeters()); expect(diff, message || `Expected distance to be within ${toleranceMeters}m of ${expected.inMeters()}m`) .toBeLessThanOrEqual(toleranceMeters); } // Angle assertions export function assertAngleNearlyEqual( actual: Angle, expected: Angle, toleranceDegrees: number = 0.1, message?: string ) { const diff = Math.abs(actual.degrees - expected.degrees) % 360; const smallestDiff = Math.min(diff, 360 - diff); expect(smallestDiff, message || `Expected angle to be within ${toleranceDegrees}° of ${expected.degrees}°`) .toBeLessThanOrEqual(toleranceDegrees); } // Coordinate assertions export function assertCoordinateNearlyEqual( actual: Coordinate, expected: Coordinate, toleranceDegrees: number = 0.0001, message?: string ) { const latDiff = Math.abs(actual.latitude - expected.latitude); const lonDiff = Math.abs(actual.longitude - expected.longitude); expect(latDiff, message || `Latitude difference exceeds tolerance`) .toBeLessThanOrEqual(toleranceDegrees); expect(lonDiff, message || `Longitude difference exceeds tolerance`) .toBeLessThanOrEqual(toleranceDegrees); if (actual.altitude !== undefined && expected.altitude !== undefined) { const altDiff = Math.abs(actual.altitude - expected.altitude); expect(altDiff, message || `Altitude difference exceeds tolerance`) .toBeLessThanOrEqual(1); // 1 meter tolerance for altitude } } // Area assertions (for spherical geometry) export function assertAreaNearlyEqual( actual: number, expected: number, toleranceKm2: number = 1, message?: string ) { const diff = Math.abs(actual - expected); expect(diff, message || `Expected area to be within ${toleranceKm2}km² of ${expected}km²`) .toBeLessThanOrEqual(toleranceKm2); } // Bearing/Azimuth assertions export function assertBearingNearlyEqual( actual: Angle, expected: Angle, toleranceDegrees: number = 0.1, message?: string ) { let diff = Math.abs(actual.degrees - expected.degrees) % 360; if (diff > 180) diff = 360 - diff; expect(diff, message || `Expected bearing to be within ${toleranceDegrees}° of ${expected.degrees}°`) .toBeLessThanOrEqual(toleranceDegrees); }
|   |   --- constants.d.ts: export declare const DISTANCE_TOLERANCE_METERS = 1; export declare const ANGLE_TOLERANCE_DEGREES = 0.1; export declare const COORDINATE_TOLERANCE_DEGREES = 0.0001; export declare const AREA_TOLERANCE_KM2 = 1; export declare const ALTITUDE_TOLERANCE_METERS = 1; export declare const TEST_CATEGORIES: { readonly CONSTRUCTOR: "Constructor Tests"; readonly VALIDATION: "Input Validation"; readonly CALCULATIONS: "Core Calculations"; readonly EDGE_CASES: "Edge Cases"; readonly ERROR_HANDLING: "Error Handling"; readonly REAL_WORLD: "Real World Examples"; readonly INTEGRATION: "Integration Tests"; }; export declare const ERROR_MESSAGES: { readonly INVALID_LATITUDE: "Latitude must be between -90 and 90 degrees"; readonly INVALID_LONGITUDE: "Longitude must be between -180 and 180 degrees"; readonly INVALID_ANGLE: "Angle must be a finite number"; readonly INVALID_DISTANCE: "Distance must be non-negative"; readonly INVALID_RADIUS: "Radius must be positive"; readonly INVALID_COORDINATE: "Invalid coordinate"; readonly INVALID_POINT: "Invalid point"; }; export declare const TEST_VALUES: { readonly ITERATIONS: 100; readonly MIN_POINTS: 10; readonly MAX_POINTS: 1000; readonly SEED: 12345; }; export declare const MATH_CONSTANTS: { readonly EARTH_RADIUS_KM: 6371; readonly DEG_TO_RAD: number; readonly RAD_TO_DEG: number; readonly EPSILON: 1e-10; };
|   |   --- constants.js: // Test constants // Test Tolerances export const DISTANCE_TOLERANCE_METERS = 1; // 1 meter tolerance for distance comparisons export const ANGLE_TOLERANCE_DEGREES = 0.1; // 0.1 degree tolerance for angle comparisons export const COORDINATE_TOLERANCE_DEGREES = 0.0001; // 0.0001 degree tolerance for coordinate comparisons export const AREA_TOLERANCE_KM2 = 1; // 1 km² tolerance for area comparisons export const ALTITUDE_TOLERANCE_METERS = 1; // 1 meter tolerance for altitude comparisons // Test Categories export const TEST_CATEGORIES = { CONSTRUCTOR: 'Constructor Tests', VALIDATION: 'Input Validation', CALCULATIONS: 'Core Calculations', EDGE_CASES: 'Edge Cases', ERROR_HANDLING: 'Error Handling', REAL_WORLD: 'Real World Examples', INTEGRATION: 'Integration Tests' }; // Error Messages export const ERROR_MESSAGES = { INVALID_LATITUDE: 'Latitude must be between -90 and 90 degrees', INVALID_LONGITUDE: 'Longitude must be between -180 and 180 degrees', INVALID_ANGLE: 'Angle must be a finite number', INVALID_DISTANCE: 'Distance must be non-negative', INVALID_RADIUS: 'Radius must be positive', INVALID_COORDINATE: 'Invalid coordinate', INVALID_POINT: 'Invalid point' }; // Common Test Values export const TEST_VALUES = { ITERATIONS: 100, MIN_POINTS: 10, MAX_POINTS: 1000, SEED: 12345 // Seed for random number generation }; // Mathematical Constants export const MATH_CONSTANTS = { EARTH_RADIUS_KM: 6371, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, EPSILON: 1e-10 // Small number for floating-point comparisons };
|   |   --- constants.ts: // Test constants // Test Tolerances export const DISTANCE_TOLERANCE_METERS = 1; // 1 meter tolerance for distance comparisons export const ANGLE_TOLERANCE_DEGREES = 0.1; // 0.1 degree tolerance for angle comparisons export const COORDINATE_TOLERANCE_DEGREES = 0.0001; // 0.0001 degree tolerance for coordinate comparisons export const AREA_TOLERANCE_KM2 = 1; // 1 km² tolerance for area comparisons export const ALTITUDE_TOLERANCE_METERS = 1; // 1 meter tolerance for altitude comparisons // Test Categories export const TEST_CATEGORIES = { CONSTRUCTOR: 'Constructor Tests', VALIDATION: 'Input Validation', CALCULATIONS: 'Core Calculations', EDGE_CASES: 'Edge Cases', ERROR_HANDLING: 'Error Handling', REAL_WORLD: 'Real World Examples', INTEGRATION: 'Integration Tests' } as const; // Error Messages export const ERROR_MESSAGES = { INVALID_LATITUDE: 'Latitude must be between -90 and 90 degrees', INVALID_LONGITUDE: 'Longitude must be between -180 and 180 degrees', INVALID_ANGLE: 'Angle must be a finite number', INVALID_DISTANCE: 'Distance must be non-negative', INVALID_RADIUS: 'Radius must be positive', INVALID_COORDINATE: 'Invalid coordinate', INVALID_POINT: 'Invalid point' } as const; // Common Test Values export const TEST_VALUES = { ITERATIONS: 100, // Number of iterations for property-based tests MIN_POINTS: 10, // Minimum points for shape generation MAX_POINTS: 1000, // Maximum points for shape generation SEED: 12345 // Seed for random number generation } as const; // Mathematical Constants export const MATH_CONSTANTS = { EARTH_RADIUS_KM: 6371, // Earth's mean radius in kilometers DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, EPSILON: 1e-10 // Small number for floating-point comparisons } as const;
|   |   --- generators.d.ts: export {};
|   |   --- generators.js: export {}; // Test generators
|   |   --- generators.ts: // Test generators
|   +-- adapters
|   |   \-- geojson
|   |       --- Feature.test.d.ts: export {};
|   |       --- Feature.test.js: export {}; // Feature test file
|   |       --- Feature.test.ts: // Feature test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- FeatureCollection.test.d.ts: export {};
|   |       --- FeatureCollection.test.js: export {}; // FeatureCollection test file
|   |       --- FeatureCollection.test.ts: // FeatureCollection test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- GeoConverter.test.d.ts: export {};
|   |       --- GeoConverter.test.js: export {}; // GeoConverter test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- GeoConverter.test.ts: // GeoConverter test file import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- GeoReader.test.d.ts: export {};
|   |       --- GeoReader.test.js: export {}; // GeoReader test file
|   |       --- GeoReader.test.ts: // GeoReader test file import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- GeoRegistry.test.d.ts: export {};
|   |       --- GeoRegistry.test.js: import { describe, it, expect } from 'vitest'; import { GeoRegistry } from '../../../src/adapters/geojson/GeoRegistry.js'; import { GreatCircle } from '../../../src/core/models/GreatCircle.js'; import { SmallCircle } from '../../../src/core/models/SmallCircle.js'; import { Triangle } from '../../../src/core/models/Triangle.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { LONDON, PARIS, TRIANGLE_VERTEX_1, TRIANGLE_VERTEX_2, TRIANGLE_VERTEX_3 } from '../../__fixtures__/coordinates.js'; import { ONE_KILOMETER } from '../../__fixtures__/distances.js'; describe('GeoRegistry', () => { describe('Feature to Model Conversion', () => { it('should convert LineString feature to GreatCircle', () => { const feature = { type: 'Feature', geometry: { type: 'LineString', coordinates: [ [PARIS.longitude, PARIS.latitude], [LONDON.longitude, LONDON.latitude] ] }, properties: {} }; const result = GeoRegistry.reverse(feature); expect(result).toBeInstanceOf(GreatCircle); }); // Triangle case it('should convert Triangle Polygon feature to Triangle', () => { const triangleFeature = { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[ [0, 0], [1, 0], [0, 1], [0, 0] // Closing point ]] }, properties: { area: 100 } }; const result = GeoRegistry.reverse(triangleFeature); expect(result).toBeInstanceOf(Triangle); }); // Small Circle case it('should convert Circle Polygon feature to SmallCircle', () => { const circleFeature = { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[ [0, 0], [0.1, 0], [0, 0.1], [0, 0] // Closing point ]] }, properties: { radius: 1000 } }; const result = GeoRegistry.reverse(circleFeature); expect(result).toBeInstanceOf(SmallCircle); }); }); describe('Model to Feature Conversion', () => { it('should convert GreatCircle to LineString feature', () => { const greatCircle = GreatCircle.from(PARIS).to(LONDON); const feature = GeoRegistry.convert(greatCircle, 'Feature'); expect(feature.type).toBe('Feature'); expect(feature.geometry.type).toBe('LineString'); if (feature.geometry.type === 'LineString') { expect(feature.geometry.coordinates.length).toBeGreaterThan(0); } }); it('should convert SmallCircle to Polygon feature', () => { const circle = SmallCircle.withCenter(LONDON).radius(ONE_KILOMETER); const feature = GeoRegistry.convert(circle, 'Feature'); expect(feature.type).toBe('Feature'); expect(feature.geometry.type).toBe('Polygon'); if (feature.geometry.type === 'Polygon') { expect(feature.geometry.coordinates[0].length).toBeGreaterThan(0); // Verify polygon is closed const ring = feature.geometry.coordinates[0]; expect(ring[0]).toEqual(ring[ring.length - 1]); } }); it('should convert Triangle to Polygon feature', () => { const triangle = Triangle.from(TRIANGLE_VERTEX_1) .to(TRIANGLE_VERTEX_2) .and(TRIANGLE_VERTEX_3); const feature = GeoRegistry.convert(triangle, 'Feature'); expect(feature.type).toBe('Feature'); expect(feature.geometry.type).toBe('Polygon'); if (feature.geometry.type === 'Polygon') { expect(feature.geometry.coordinates[0].length).toBe(4); // 3 vertices + closing point // Verify polygon is closed const ring = feature.geometry.coordinates[0]; expect(ring[0]).toEqual(ring[ring.length - 1]); } }); }); describe(TEST_CATEGORIES.ERROR_HANDLING, () => { it('should handle invalid LineString features', () => { const invalidFeature = { type: 'Feature', geometry: { type: 'LineString', coordinates: [] // Empty coordinates }, properties: {} }; expect(() => { GeoRegistry.reverse(invalidFeature); }).toThrow(); }); it('should handle LineString with insufficient points', () => { const invalidFeature = { type: 'Feature', geometry: { type: 'LineString', coordinates: [[0, 0]] // Only one point }, properties: {} }; expect(() => { GeoRegistry.reverse(invalidFeature); }).toThrow(); }); }); });
|   |       --- GeoRegistry.test.ts: import { describe, it, expect } from 'vitest'; import { GeoRegistry } from '../../../src/adapters/geojson/GeoRegistry.js'; import { Feature } from '../../../src/adapters/geojson/Feature.js'; import { GreatCircle } from '../../../src/core/models/GreatCircle.js'; import { SmallCircle } from '../../../src/core/models/SmallCircle.js'; import { Triangle } from '../../../src/core/models/Triangle.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { LONDON, PARIS, TRIANGLE_VERTEX_1, TRIANGLE_VERTEX_2, TRIANGLE_VERTEX_3 } from '../../__fixtures__/coordinates.js'; import { ONE_KILOMETER } from '../../__fixtures__/distances.js'; describe('GeoRegistry', () => { describe('Feature to Model Conversion', () => { it('should convert LineString feature to GreatCircle', () => { const feature: Feature = { type: 'Feature', geometry: { type: 'LineString', coordinates: [ [PARIS.longitude, PARIS.latitude], [LONDON.longitude, LONDON.latitude] ] }, properties: {} }; const result = GeoRegistry.reverse(feature); expect(result).toBeInstanceOf(GreatCircle); }); // Triangle case it('should convert Triangle Polygon feature to Triangle', () => { const triangleFeature: Feature = { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[ [0, 0], [1, 0], [0, 1], [0, 0] // Closing point ]] }, properties: { area: 100 } }; const result = GeoRegistry.reverse(triangleFeature); expect(result).toBeInstanceOf(Triangle); }); // Small Circle case it('should convert Circle Polygon feature to SmallCircle', () => { const circleFeature: Feature = { type: 'Feature', geometry: { type: 'Polygon', coordinates: [[ [0, 0], [0.1, 0], [0, 0.1], [0, 0] // Closing point ]] }, properties: { radius: 1000 } }; const result = GeoRegistry.reverse(circleFeature); expect(result).toBeInstanceOf(SmallCircle); }); }); describe('Model to Feature Conversion', () => { it('should convert GreatCircle to LineString feature', () => { const greatCircle = GreatCircle.from(PARIS).to(LONDON); const feature = GeoRegistry.convert(greatCircle, 'Feature'); expect(feature.type).toBe('Feature'); expect(feature.geometry.type).toBe('LineString'); if (feature.geometry.type === 'LineString') { expect(feature.geometry.coordinates.length).toBeGreaterThan(0); } }); it('should convert SmallCircle to Polygon feature', () => { const circle = SmallCircle.withCenter(LONDON).radius(ONE_KILOMETER); const feature = GeoRegistry.convert(circle, 'Feature'); expect(feature.type).toBe('Feature'); expect(feature.geometry.type).toBe('Polygon'); if (feature.geometry.type === 'Polygon') { expect(feature.geometry.coordinates[0].length).toBeGreaterThan(0); // Verify polygon is closed const ring = feature.geometry.coordinates[0]; expect(ring[0]).toEqual(ring[ring.length - 1]); } }); it('should convert Triangle to Polygon feature', () => { const triangle = Triangle.from(TRIANGLE_VERTEX_1) .to(TRIANGLE_VERTEX_2) .and(TRIANGLE_VERTEX_3); const feature = GeoRegistry.convert(triangle, 'Feature'); expect(feature.type).toBe('Feature'); expect(feature.geometry.type).toBe('Polygon'); if (feature.geometry.type === 'Polygon') { expect(feature.geometry.coordinates[0].length).toBe(4); // 3 vertices + closing point // Verify polygon is closed const ring = feature.geometry.coordinates[0]; expect(ring[0]).toEqual(ring[ring.length - 1]); } }); }); describe(TEST_CATEGORIES.ERROR_HANDLING, () => { it('should handle invalid LineString features', () => { const invalidFeature: Feature = { type: 'Feature', geometry: { type: 'LineString', coordinates: [] // Empty coordinates }, properties: {} }; expect(() => { GeoRegistry.reverse(invalidFeature); }).toThrow(); }); it('should handle LineString with insufficient points', () => { const invalidFeature: Feature = { type: 'Feature', geometry: { type: 'LineString', coordinates: [[0, 0]] // Only one point }, properties: {} }; expect(() => { GeoRegistry.reverse(invalidFeature); }).toThrow(); }); }); });
|   |       --- GeoWriter.test.d.ts: export {};
|   |       --- GeoWriter.test.js: export {}; // GeoWriter test file
|   |       --- GeoWriter.test.ts: // GeoWriter test file import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- GeometryCollection.test.d.ts: export {};
|   |       --- GeometryCollection.test.js: export {}; // GeometryCollection test file
|   |       --- GeometryCollection.test.ts: // GeometryCollection test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- LineString.test.d.ts: export {};
|   |       --- LineString.test.js: export {}; // LineString test file
|   |       --- LineString.test.ts: // LineString test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- MultiLineString.test.d.ts: export {};
|   |       --- MultiLineString.test.js: export {}; // MultiLineString test file
|   |       --- MultiLineString.test.ts: // MultiLineString test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- MultiPoint.test.d.ts: export {};
|   |       --- MultiPoint.test.js: export {}; // MultiPoint test file
|   |       --- MultiPoint.test.ts: // MultiPoint test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- MultiPolygon.test.d.ts: export {};
|   |       --- MultiPolygon.test.js: export {}; // MultiPolygon test file
|   |       --- MultiPolygon.test.ts: // MultiPolygon test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- Point.test.d.ts: export {};
|   |       --- Point.test.js: export {}; // Point test file
|   |       --- Point.test.ts: // Point test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- Polygon.test.d.ts: export {};
|   |       --- Polygon.test.js: export {}; // Polygon test file
|   |       --- Polygon.test.ts: // Polygon test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- TypeConverter.test.d.ts: export {};
|   |       --- TypeConverter.test.js: export {}; // TypeConverter test file
|   |       --- TypeConverter.test.ts: // TypeConverter test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- TypeMapping.test.d.ts: export {};
|   |       --- TypeMapping.test.js: // TypeMapping test file import { describe, it, expect } from 'vitest'; import { TypeMapping, Coordinate, Point, GreatCircle, SmallCircle, Triangle } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; describe('TypeMapping', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should have default mappings for core types', () => { expect(TypeMapping.hasMapping(Coordinate)).toBe(true); expect(TypeMapping.hasMapping(Point)).toBe(true); expect(TypeMapping.hasMapping(GreatCircle)).toBe(true); expect(TypeMapping.hasMapping(SmallCircle)).toBe(true); expect(TypeMapping.hasMapping(Triangle)).toBe(true); }); it('should return null for unknown types', () => { class UnknownType { } expect(TypeMapping.get(UnknownType)).toBeNull(); }); }); describe('Mapping Operations', () => { it('should get correct GeoJSON type for each model', () => { const mappings = { Coordinate: 'Point', Point: 'Point', GreatCircle: 'LineString', SmallCircle: 'Polygon', Triangle: 'Polygon' }; for (const [modelName, geoType] of Object.entries(mappings)) { const mapping = TypeMapping.get(eval(modelName)); expect(mapping?.type).toBe(geoType); } }); it('should return copy of mapping to prevent modification', () => { const mapping1 = TypeMapping.get(Coordinate); const mapping2 = TypeMapping.get(Coordinate); expect(mapping1).not.toBe(mapping2); expect(mapping1).toEqual(mapping2); }); }); describe('Registration', () => { it('should register new valid mapping', () => { class CustomType { } const geoType = { type: "Point", coordinates: [] }; TypeMapping.registerMapping(CustomType, geoType); expect(TypeMapping.hasMapping(CustomType)).toBe(true); expect(TypeMapping.get(CustomType)).toEqual(geoType); }); it('should throw error for invalid GeoJSON type', () => { class CustomType { } const invalidType = { type: "InvalidType", coordinates: [] }; expect(() => { TypeMapping.registerMapping(CustomType, invalidType); }).toThrow(); }); it('should allow overriding existing mapping', () => { class CustomType { } const type1 = { type: "Point", coordinates: [] }; const type2 = { type: "LineString", coordinates: [] }; TypeMapping.registerMapping(CustomType, type1); TypeMapping.registerMapping(CustomType, type2); expect(TypeMapping.get(CustomType)?.type).toBe("LineString"); }); }); describe('Type Lookup', () => { it('should find source types for GeoJSON type', () => { const pointSources = TypeMapping.getSourceTypeForGeoType('Point'); expect(pointSources).toContain(Coordinate); expect(pointSources).toContain(Point); const polygonSources = TypeMapping.getSourceTypeForGeoType('Polygon'); expect(polygonSources).toContain(SmallCircle); expect(polygonSources).toContain(Triangle); }); it('should return empty array for unknown GeoJSON type', () => { const sources = TypeMapping.getSourceTypeForGeoType('UnknownType'); expect(sources).toHaveLength(0); }); }); describe('Mapping Access', () => { it('should return all mappings', () => { const allMappings = TypeMapping.getAllMappings(); expect(allMappings.size).toBeGreaterThan(0); expect(allMappings instanceof Map).toBe(true); }); it('should return copy of mappings to prevent modification', () => { const mappings1 = TypeMapping.getAllMappings(); const mappings2 = TypeMapping.getAllMappings(); expect(mappings1).not.toBe(mappings2); expect([...mappings1.entries()]).toEqual([...mappings2.entries()]); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle undefined type registration', () => { expect(() => { TypeMapping.registerMapping(undefined, { type: "Point", coordinates: [] }); }).toThrow(); }); it('should handle null type registration', () => { expect(() => { TypeMapping.registerMapping(null, { type: "Point", coordinates: [] }); }).toThrow(); }); it('should handle registration with empty GeoType', () => { class CustomType { } expect(() => { TypeMapping.registerMapping(CustomType, {}); }).toThrow(); }); }); describe('Type Validation', () => { it('should validate GeoJSON types on registration', () => { class CustomType { } const validTypes = ["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"]; validTypes.forEach(type => { expect(() => { TypeMapping.registerMapping(CustomType, { type, coordinates: [] }); }).not.toThrow(); }); }); it('should reject invalid GeoJSON types', () => { class CustomType { } const invalidTypes = ["Invalid", "Circle", "Rectangle", ""]; invalidTypes.forEach(type => { expect(() => { TypeMapping.registerMapping(CustomType, { type, coordinates: [] }); }).toThrow(); }); }); }); });
|   |       --- TypeMapping.test.ts: // TypeMapping test file import { describe, it, expect } from 'vitest'; import { TypeMapping, Coordinate, Point, GreatCircle, SmallCircle, Triangle } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; describe('TypeMapping', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should have default mappings for core types', () => { expect(TypeMapping.hasMapping(Coordinate)).toBe(true); expect(TypeMapping.hasMapping(Point)).toBe(true); expect(TypeMapping.hasMapping(GreatCircle)).toBe(true); expect(TypeMapping.hasMapping(SmallCircle)).toBe(true); expect(TypeMapping.hasMapping(Triangle)).toBe(true); }); it('should return null for unknown types', () => { class UnknownType {} expect(TypeMapping.get(UnknownType)).toBeNull(); }); }); describe('Mapping Operations', () => { // it('should get correct GeoJSON type for each model', () => { // const mappings = { // Coordinate: 'Point', // Point: 'Point', // GreatCircle: 'LineString', // SmallCircle: 'Polygon', // Triangle: 'Polygon' // }; // for (const [modelName, geoType] of Object.entries(mappings)) { // const mapping = TypeMapping.get(eval(modelName)); // expect(mapping?.type).toBe(geoType); // } // }); it('should return copy of mapping to prevent modification', () => { const mapping1 = TypeMapping.get(Coordinate); const mapping2 = TypeMapping.get(Coordinate); expect(mapping1).not.toBe(mapping2); expect(mapping1).toEqual(mapping2); }); }); describe('Registration', () => { it('should register new valid mapping', () => { class CustomType {} const geoType = { type: "Point", coordinates: [] }; TypeMapping.registerMapping(CustomType, geoType); expect(TypeMapping.hasMapping(CustomType)).toBe(true); expect(TypeMapping.get(CustomType)).toEqual(geoType); }); it('should throw error for invalid GeoJSON type', () => { class CustomType {} const invalidType = { type: "InvalidType", coordinates: [] }; expect(() => { TypeMapping.registerMapping(CustomType, invalidType as any); }).toThrow(); }); it('should allow overriding existing mapping', () => { class CustomType {} const type1 = { type: "Point", coordinates: [] }; const type2 = { type: "LineString", coordinates: [] }; TypeMapping.registerMapping(CustomType, type1); TypeMapping.registerMapping(CustomType, type2); expect(TypeMapping.get(CustomType)?.type).toBe("LineString"); }); }); describe('Type Lookup', () => { it('should find source types for GeoJSON type', () => { const pointSources = TypeMapping.getSourceTypeForGeoType('Point'); expect(pointSources).toContain(Coordinate); expect(pointSources).toContain(Point); const polygonSources = TypeMapping.getSourceTypeForGeoType('Polygon'); expect(polygonSources).toContain(SmallCircle); expect(polygonSources).toContain(Triangle); }); it('should return empty array for unknown GeoJSON type', () => { const sources = TypeMapping.getSourceTypeForGeoType('UnknownType'); expect(sources).toHaveLength(0); }); }); describe('Mapping Access', () => { it('should return all mappings', () => { const allMappings = TypeMapping.getAllMappings(); expect(allMappings.size).toBeGreaterThan(0); expect(allMappings instanceof Map).toBe(true); }); it('should return copy of mappings to prevent modification', () => { const mappings1 = TypeMapping.getAllMappings(); const mappings2 = TypeMapping.getAllMappings(); expect(mappings1).not.toBe(mappings2); expect([...mappings1.entries()]).toEqual([...mappings2.entries()]); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { // it('should handle undefined type registration', () => { // expect(() => { // TypeMapping.registerMapping(undefined as any, { type: "Point", coordinates: [] }); // }).toThrow(); // }); // it('should handle null type registration', () => { // expect(() => { // TypeMapping.registerMapping(null as any, { type: "Point", coordinates: [] }); // }).toThrow(); // }); it('should handle registration with empty GeoType', () => { class CustomType {} expect(() => { TypeMapping.registerMapping(CustomType, {} as any); }).toThrow(); }); }); describe('Type Validation', () => { it('should validate GeoJSON types on registration', () => { class CustomType {} const validTypes = ["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"]; validTypes.forEach(type => { expect(() => { TypeMapping.registerMapping(CustomType, { type, coordinates: [] }); }).not.toThrow(); }); }); it('should reject invalid GeoJSON types', () => { class CustomType {} const invalidTypes = ["Invalid", "Circle", "Rectangle", ""]; invalidTypes.forEach(type => { expect(() => { TypeMapping.registerMapping(CustomType, { type, coordinates: [] } as any); }).toThrow(); }); }); }); });
|   +-- core
|   |   +-- coordinate
|   |   |   --- CoordinateSystem.test.d.ts: export {};
|   |   |   --- CoordinateSystem.test.js: // CoordinateSystem test file import { assertCoordinateNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, NORTH_POLE, SOUTH_POLE, EQUATOR_PRIME, EQUATOR_180 } from '../../__fixtures__/coordinates.js'; import { describe, it, expect } from 'vitest'; import { CoordinateSystem, Point, Coordinate } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; describe('CoordinateSystem', () => { describe('Coordinate to Point Conversion', () => { it('should convert equator point', () => { const point = CoordinateSystem.fromCoordinate(EQUATOR_PRIME); expect(point.X).toBeCloseTo(0); expect(point.Y).toBeCloseTo(0); }); it('should convert North Pole', () => { const point = CoordinateSystem.fromCoordinate(NORTH_POLE); expect(point.X).toBeCloseTo(0); expect(point.Y).toBeCloseTo(Math.PI / 2); }); it('should convert South Pole', () => { const point = CoordinateSystem.fromCoordinate(SOUTH_POLE); expect(point.X).toBeCloseTo(0); expect(point.Y).toBeCloseTo(-Math.PI / 2); }); it('should convert date line points', () => { const point = CoordinateSystem.fromCoordinate(EQUATOR_180); expect(point.X).toBeCloseTo(Math.PI); expect(point.Y).toBeCloseTo(0); }); it('should convert arbitrary point', () => { const point = CoordinateSystem.fromCoordinate(LONDON); expect(point.X).toBeCloseTo(-0.1278 * Math.PI / 180); expect(point.Y).toBeCloseTo(51.5074 * Math.PI / 180); }); }); describe('Point to Coordinate Conversion', () => { it('should convert origin point', () => { const point = Point.at(0, 0); const coord = CoordinateSystem.fromPoint(point); expect(coord.latitude).toBeCloseTo(0); expect(coord.longitude).toBeCloseTo(0); }); it('should convert pole point', () => { const point = Point.at(0, Math.PI / 2); const coord = CoordinateSystem.fromPoint(point); expect(coord.latitude).toBeCloseTo(90); expect(coord.longitude).toBeCloseTo(0); }); it('should convert arbitrary point', () => { const point = Point.at(-0.1278 * Math.PI / 180, 51.5074 * Math.PI / 180); const coord = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(coord, LONDON); }); }); describe('Round Trip Conversions', () => { const testPoints = [ LONDON, PARIS, NORTH_POLE, SOUTH_POLE, EQUATOR_PRIME, EQUATOR_180 ]; testPoints.forEach(original => { it(`should preserve ${original.toString()} in round trip`, () => { const point = CoordinateSystem.fromCoordinate(original); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, original); }); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle 180/-180 longitude equivalence', () => { const pos180 = new Coordinate(0, 180); const neg180 = new Coordinate(0, -180); const point1 = CoordinateSystem.fromCoordinate(pos180); const point2 = CoordinateSystem.fromCoordinate(neg180); expect(point1.X).toBeCloseTo(point2.X); expect(point1.Y).toBeCloseTo(point2.Y); }); it('should handle points near poles', () => { const nearNorthPole = new Coordinate(89.9999, 0); const point = CoordinateSystem.fromCoordinate(nearNorthPole); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, nearNorthPole); }); it('should handle points near date line', () => { const nearDateLine = new Coordinate(0, 179.9999); const point = CoordinateSystem.fromCoordinate(nearDateLine); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, nearDateLine); }); }); describe('Numerical Precision', () => { it('should maintain precision for small angles', () => { const smallAngle = new Coordinate(0.0001, 0.0001); const point = CoordinateSystem.fromCoordinate(smallAngle); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, smallAngle, 0.0000001); }); it('should handle angles close to limits', () => { const nearLimit = new Coordinate(89.9999999, 179.9999999); const point = CoordinateSystem.fromCoordinate(nearLimit); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, nearLimit, 0.0000001); }); }); });
|   |   |   --- CoordinateSystem.test.ts: // CoordinateSystem test file import { assertCoordinateNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, NORTH_POLE, SOUTH_POLE, EQUATOR_PRIME, EQUATOR_180 } from '../../__fixtures__/coordinates.js'; import { describe, it, expect } from 'vitest'; import { CoordinateSystem, Point, Coordinate } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; describe('CoordinateSystem', () => { describe('Coordinate to Point Conversion', () => { it('should convert equator point', () => { const point = CoordinateSystem.fromCoordinate(EQUATOR_PRIME); expect(point.X).toBeCloseTo(0); expect(point.Y).toBeCloseTo(0); }); it('should convert North Pole', () => { const point = CoordinateSystem.fromCoordinate(NORTH_POLE); expect(point.X).toBeCloseTo(0); expect(point.Y).toBeCloseTo(Math.PI / 2); }); it('should convert South Pole', () => { const point = CoordinateSystem.fromCoordinate(SOUTH_POLE); expect(point.X).toBeCloseTo(0); expect(point.Y).toBeCloseTo(-Math.PI / 2); }); it('should convert date line points', () => { const point = CoordinateSystem.fromCoordinate(EQUATOR_180); expect(point.X).toBeCloseTo(Math.PI); expect(point.Y).toBeCloseTo(0); }); it('should convert arbitrary point', () => { const point = CoordinateSystem.fromCoordinate(LONDON); expect(point.X).toBeCloseTo(-0.1278 * Math.PI / 180); expect(point.Y).toBeCloseTo(51.5074 * Math.PI / 180); }); }); describe('Point to Coordinate Conversion', () => { it('should convert origin point', () => { const point = Point.at(0, 0); const coord = CoordinateSystem.fromPoint(point); expect(coord.latitude).toBeCloseTo(0); expect(coord.longitude).toBeCloseTo(0); }); it('should convert pole point', () => { const point = Point.at(0, Math.PI / 2); const coord = CoordinateSystem.fromPoint(point); expect(coord.latitude).toBeCloseTo(90); expect(coord.longitude).toBeCloseTo(0); }); it('should convert arbitrary point', () => { const point = Point.at( -0.1278 * Math.PI / 180, 51.5074 * Math.PI / 180 ); const coord = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(coord, LONDON); }); }); describe('Round Trip Conversions', () => { const testPoints = [ LONDON, PARIS, NORTH_POLE, SOUTH_POLE, EQUATOR_PRIME, EQUATOR_180 ]; testPoints.forEach(original => { it(`should preserve ${original.toString()} in round trip`, () => { const point = CoordinateSystem.fromCoordinate(original); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, original); }); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle 180/-180 longitude equivalence', () => { const pos180 = new Coordinate(0, 180); const neg180 = new Coordinate(0, -180); const point1 = CoordinateSystem.fromCoordinate(pos180); const point2 = CoordinateSystem.fromCoordinate(neg180); expect(point1.X).toBeCloseTo(point2.X); expect(point1.Y).toBeCloseTo(point2.Y); }); it('should handle points near poles', () => { const nearNorthPole = new Coordinate(89.9999, 0); const point = CoordinateSystem.fromCoordinate(nearNorthPole); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, nearNorthPole); }); it('should handle points near date line', () => { const nearDateLine = new Coordinate(0, 179.9999); const point = CoordinateSystem.fromCoordinate(nearDateLine); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, nearDateLine); }); }); describe('Numerical Precision', () => { it('should maintain precision for small angles', () => { const smallAngle = new Coordinate(0.0001, 0.0001); const point = CoordinateSystem.fromCoordinate(smallAngle); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, smallAngle, 0.0000001); }); it('should handle angles close to limits', () => { const nearLimit = new Coordinate(89.9999999, 179.9999999); const point = CoordinateSystem.fromCoordinate(nearLimit); const roundTrip = CoordinateSystem.fromPoint(point); assertCoordinateNearlyEqual(roundTrip, nearLimit, 0.0000001); }); }); });
|   |   +-- errors
|   |   |   --- GeoConversionError.test.d.ts: export {};
|   |   |   --- GeoConversionError.test.js: // GeoConversionError test file import { describe, it, expect } from 'vitest'; import { GeoConversionError, GeoError } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; describe('GeoConversionError', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create error with all parameters', () => { const error = new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON', new Error('Cause')); expect(error.message).toBe('Conversion failed'); expect(error.sourceType).toBe('Coordinate'); expect(error.targetType).toBe('GeoJSON'); expect(error.cause).toBeInstanceOf(Error); }); it('should create error without cause', () => { const error = new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON'); expect(error.message).toBe('Conversion failed'); expect(error.sourceType).toBe('Coordinate'); expect(error.targetType).toBe('GeoJSON'); expect(error.cause).toBeUndefined(); }); }); describe('Error Properties', () => { it('should have correct name', () => { const error = new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON'); expect(error.name).toBe('GeoConversionError'); }); it('should have correct inheritance chain', () => { const error = new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON'); expect(error).toBeInstanceOf(Error); expect(error).toBeInstanceOf(GeoError); expect(error).toBeInstanceOf(GeoConversionError); }); it('should expose source and target types', () => { const error = new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON'); expect(error.sourceType).toBe('Coordinate'); expect(error.targetType).toBe('GeoJSON'); }); }); describe('Usage Patterns', () => { it('should work in try-catch block', () => { expect(() => { throw new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON'); }).toThrow(GeoConversionError); }); it('should maintain error chain with cause', () => { const cause = new Error('Original error'); const error = new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON', cause); expect(error.cause).toBe(cause); expect(error.message).toBe('Conversion failed'); }); }); describe(TEST_CATEGORIES.ERROR_HANDLING, () => { it('should handle empty strings', () => { const error = new GeoConversionError('', '', ''); expect(error.message).toBe(''); expect(error.sourceType).toBe(''); expect(error.targetType).toBe(''); }); it('should handle undefined cause', () => { const error = new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON', undefined); expect(error.cause).toBeUndefined(); }); it('should handle non-Error cause', () => { const error = new GeoConversionError('Conversion failed', 'Coordinate', 'GeoJSON', 'Not an error'); expect(error.cause).toBe('Not an error'); }); }); });
|   |   |   --- GeoConversionError.test.ts: // GeoConversionError test file import { describe, it, expect } from 'vitest'; import { GeoConversionError, GeoError } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; describe('GeoConversionError', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create error with all parameters', () => { const error = new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON', new Error('Cause') ); expect(error.message).toBe('Conversion failed'); expect(error.sourceType).toBe('Coordinate'); expect(error.targetType).toBe('GeoJSON'); expect(error.cause).toBeInstanceOf(Error); }); it('should create error without cause', () => { const error = new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON' ); expect(error.message).toBe('Conversion failed'); expect(error.sourceType).toBe('Coordinate'); expect(error.targetType).toBe('GeoJSON'); expect(error.cause).toBeUndefined(); }); }); describe('Error Properties', () => { it('should have correct name', () => { const error = new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON' ); expect(error.name).toBe('GeoConversionError'); }); it('should have correct inheritance chain', () => { const error = new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON' ); expect(error).toBeInstanceOf(Error); expect(error).toBeInstanceOf(GeoError); expect(error).toBeInstanceOf(GeoConversionError); }); it('should expose source and target types', () => { const error = new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON' ); expect(error.sourceType).toBe('Coordinate'); expect(error.targetType).toBe('GeoJSON'); }); }); describe('Usage Patterns', () => { it('should work in try-catch block', () => { expect(() => { throw new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON' ); }).toThrow(GeoConversionError); }); it('should maintain error chain with cause', () => { const cause = new Error('Original error'); const error = new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON', cause ); expect(error.cause).toBe(cause); expect(error.message).toBe('Conversion failed'); }); }); describe(TEST_CATEGORIES.ERROR_HANDLING, () => { it('should handle empty strings', () => { const error = new GeoConversionError('', '', ''); expect(error.message).toBe(''); expect(error.sourceType).toBe(''); expect(error.targetType).toBe(''); }); it('should handle undefined cause', () => { const error = new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON', undefined ); expect(error.cause).toBeUndefined(); }); it('should handle non-Error cause', () => { const error = new GeoConversionError( 'Conversion failed', 'Coordinate', 'GeoJSON', 'Not an error' as any ); expect(error.cause).toBe('Not an error'); }); }); });
|   |   |   --- GeoError.test.d.ts: export {};
|   |   |   --- GeoError.test.js: // GeoError test file import { describe, it, expect } from 'vitest'; import { GeoError } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; // Create a concrete implementation of GeoError for testing class TestGeoError extends GeoError { constructor(message, cause) { super(message, cause); } } describe('GeoError', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create error with message', () => { const message = 'Test error message'; const error = new TestGeoError(message); expect(error.message).toBe(message); expect(error.name).toBe('TestGeoError'); expect(error instanceof Error).toBe(true); expect(error instanceof GeoError).toBe(true); }); it('should create error with message and cause', () => { const message = 'Test error message'; const cause = new Error('Cause error'); const error = new TestGeoError(message, cause); expect(error.message).toBe(message); expect(error.cause).toBe(cause); }); }); describe('Error Properties', () => { it('should have correct name', () => { const error = new TestGeoError('Test error'); expect(error.name).toBe('TestGeoError'); }); it('should have correct inheritance chain', () => { const error = new TestGeoError('Test error'); expect(error).toBeInstanceOf(Error); expect(error).toBeInstanceOf(GeoError); expect(error).toBeInstanceOf(TestGeoError); }); it('should be throwable', () => { expect(() => { throw new TestGeoError('Test error'); }).toThrow(TestGeoError); }); }); describe('Stack Trace', () => { it('should maintain stack trace', () => { const error = new TestGeoError('Test error'); expect(error.stack).toBeDefined(); }); it('should include cause in stack trace when provided', () => { const cause = new Error('Cause error'); const error = new TestGeoError('Test error', cause); expect(error.stack).toContain('Test error'); expect(error.cause).toBe(cause); }); }); describe(TEST_CATEGORIES.ERROR_HANDLING, () => { it('should handle empty message', () => { const error = new TestGeoError(''); expect(error.message).toBe(''); }); it('should handle undefined cause', () => { const error = new TestGeoError('Test error', undefined); expect(error.cause).toBeUndefined(); }); it('should handle non-Error cause', () => { const error = new TestGeoError('Test error', 'Not an error'); expect(error.cause).toBe('Not an error'); }); }); });
|   |   |   --- GeoError.test.ts: // GeoError test file import { describe, it, expect } from 'vitest'; import { GeoError } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; // Create a concrete implementation of GeoError for testing class TestGeoError extends GeoError { constructor(message: string, cause?: Error) { super(message, cause); } } describe('GeoError', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create error with message', () => { const message = 'Test error message'; const error = new TestGeoError(message); expect(error.message).toBe(message); expect(error.name).toBe('TestGeoError'); expect(error instanceof Error).toBe(true); expect(error instanceof GeoError).toBe(true); }); it('should create error with message and cause', () => { const message = 'Test error message'; const cause = new Error('Cause error'); const error = new TestGeoError(message, cause); expect(error.message).toBe(message); expect(error.cause).toBe(cause); }); }); describe('Error Properties', () => { it('should have correct name', () => { const error = new TestGeoError('Test error'); expect(error.name).toBe('TestGeoError'); }); it('should have correct inheritance chain', () => { const error = new TestGeoError('Test error'); expect(error).toBeInstanceOf(Error); expect(error).toBeInstanceOf(GeoError); expect(error).toBeInstanceOf(TestGeoError); }); it('should be throwable', () => { expect(() => { throw new TestGeoError('Test error'); }).toThrow(TestGeoError); }); }); describe('Stack Trace', () => { it('should maintain stack trace', () => { const error = new TestGeoError('Test error'); expect(error.stack).toBeDefined(); }); it('should include cause in stack trace when provided', () => { const cause = new Error('Cause error'); const error = new TestGeoError('Test error', cause); expect(error.stack).toContain('Test error'); expect(error.cause).toBe(cause); }); }); describe(TEST_CATEGORIES.ERROR_HANDLING, () => { it('should handle empty message', () => { const error = new TestGeoError(''); expect(error.message).toBe(''); }); it('should handle undefined cause', () => { const error = new TestGeoError('Test error', undefined); expect(error.cause).toBeUndefined(); }); it('should handle non-Error cause', () => { const error = new TestGeoError('Test error', 'Not an error' as any); expect(error.cause).toBe('Not an error'); }); }); });
|   |   |   --- GeoValidationError.test.d.ts: export {};
|   |   |   --- GeoValidationError.test.js: // GeoValidationError test file import { describe, it, expect } from 'vitest'; import { GeoValidationError, GeoError } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; describe('GeoValidationError', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create error with all parameters', () => { const error = new GeoValidationError('Invalid coordinate', 'latitude', 91, new Error('Cause')); expect(error.message).toBe('Invalid coordinate'); expect(error.validationType).toBe('latitude'); expect(error.invalidValue).toBe(91); expect(error.cause).toBeInstanceOf(Error); }); it('should create error without cause', () => { const error = new GeoValidationError('Invalid coordinate', 'latitude', 91); expect(error.message).toBe('Invalid coordinate'); expect(error.validationType).toBe('latitude'); expect(error.invalidValue).toBe(91); expect(error.cause).toBeUndefined(); }); }); describe('Error Properties', () => { it('should have correct name', () => { const error = new GeoValidationError('Invalid coordinate', 'latitude', 91); expect(error.name).toBe('GeoValidationError'); }); it('should have correct inheritance chain', () => { const error = new GeoValidationError('Invalid coordinate', 'latitude', 91); expect(error).toBeInstanceOf(Error); expect(error).toBeInstanceOf(GeoError); expect(error).toBeInstanceOf(GeoValidationError); }); it('should expose validation details', () => { const error = new GeoValidationError('Invalid coordinate', 'latitude', 91); expect(error.validationType).toBe('latitude'); expect(error.invalidValue).toBe(91); }); }); describe('Usage with Different Types', () => { it('should handle numeric invalid values', () => { const error = new GeoValidationError('Invalid coordinate', 'latitude', 91); expect(error.invalidValue).toBe(91); }); it('should handle string invalid values', () => { const error = new GeoValidationError('Invalid coordinate', 'format', 'invalid-format'); expect(error.invalidValue).toBe('invalid-format'); }); it('should handle object invalid values', () => { const invalidObj = { lat: 91, lon: 0 }; const error = new GeoValidationError('Invalid coordinate', 'coordinate', invalidObj); expect(error.invalidValue).toBe(invalidObj); }); it('should handle array invalid values', () => { const invalidArray = [91, 0]; const error = new GeoValidationError('Invalid coordinate', 'coordinates', invalidArray); expect(error.invalidValue).toBe(invalidArray); }); }); describe(TEST_CATEGORIES.ERROR_HANDLING, () => { it('should handle empty strings', () => { const error = new GeoValidationError('', '', ''); expect(error.message).toBe(''); expect(error.validationType).toBe(''); expect(error.invalidValue).toBe(''); }); it('should handle undefined cause', () => { const error = new GeoValidationError('Invalid coordinate', 'latitude', 91, undefined); expect(error.cause).toBeUndefined(); }); it('should handle non-Error cause', () => { const error = new GeoValidationError('Invalid coordinate', 'latitude', 91, 'Not an error'); expect(error.cause).toBe('Not an error'); }); it('should handle null invalid values', () => { const error = new GeoValidationError('Invalid coordinate', 'coordinate', null); expect(error.invalidValue).toBeNull(); }); it('should handle undefined invalid values', () => { const error = new GeoValidationError('Invalid coordinate', 'coordinate', undefined); expect(error.invalidValue).toBeUndefined(); }); }); });
|   |   |   --- GeoValidationError.test.ts: // GeoValidationError test file import { describe, it, expect } from 'vitest'; import { GeoValidationError, GeoError } from '../../../src/index.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; describe('GeoValidationError', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create error with all parameters', () => { const error = new GeoValidationError( 'Invalid coordinate', 'latitude', 91, new Error('Cause') ); expect(error.message).toBe('Invalid coordinate'); expect(error.validationType).toBe('latitude'); expect(error.invalidValue).toBe(91); expect(error.cause).toBeInstanceOf(Error); }); it('should create error without cause', () => { const error = new GeoValidationError( 'Invalid coordinate', 'latitude', 91 ); expect(error.message).toBe('Invalid coordinate'); expect(error.validationType).toBe('latitude'); expect(error.invalidValue).toBe(91); expect(error.cause).toBeUndefined(); }); }); describe('Error Properties', () => { it('should have correct name', () => { const error = new GeoValidationError( 'Invalid coordinate', 'latitude', 91 ); expect(error.name).toBe('GeoValidationError'); }); it('should have correct inheritance chain', () => { const error = new GeoValidationError( 'Invalid coordinate', 'latitude', 91 ); expect(error).toBeInstanceOf(Error); expect(error).toBeInstanceOf(GeoError); expect(error).toBeInstanceOf(GeoValidationError); }); it('should expose validation details', () => { const error = new GeoValidationError( 'Invalid coordinate', 'latitude', 91 ); expect(error.validationType).toBe('latitude'); expect(error.invalidValue).toBe(91); }); }); describe('Usage with Different Types', () => { it('should handle numeric invalid values', () => { const error = new GeoValidationError( 'Invalid coordinate', 'latitude', 91 ); expect(error.invalidValue).toBe(91); }); it('should handle string invalid values', () => { const error = new GeoValidationError( 'Invalid coordinate', 'format', 'invalid-format' ); expect(error.invalidValue).toBe('invalid-format'); }); it('should handle object invalid values', () => { const invalidObj = { lat: 91, lon: 0 }; const error = new GeoValidationError( 'Invalid coordinate', 'coordinate', invalidObj ); expect(error.invalidValue).toBe(invalidObj); }); it('should handle array invalid values', () => { const invalidArray = [91, 0]; const error = new GeoValidationError( 'Invalid coordinate', 'coordinates', invalidArray ); expect(error.invalidValue).toBe(invalidArray); }); }); describe(TEST_CATEGORIES.ERROR_HANDLING, () => { it('should handle empty strings', () => { const error = new GeoValidationError('', '', ''); expect(error.message).toBe(''); expect(error.validationType).toBe(''); expect(error.invalidValue).toBe(''); }); it('should handle undefined cause', () => { const error = new GeoValidationError( 'Invalid coordinate', 'latitude', 91, undefined ); expect(error.cause).toBeUndefined(); }); it('should handle non-Error cause', () => { const error = new GeoValidationError( 'Invalid coordinate', 'latitude', 91, 'Not an error' as any ); expect(error.cause).toBe('Not an error'); }); it('should handle null invalid values', () => { const error = new GeoValidationError( 'Invalid coordinate', 'coordinate', null ); expect(error.invalidValue).toBeNull(); }); it('should handle undefined invalid values', () => { const error = new GeoValidationError( 'Invalid coordinate', 'coordinate', undefined ); expect(error.invalidValue).toBeUndefined(); }); }); });
|   |   \-- models
|   |       --- Angle.test.d.ts: export {};
|   |       --- Angle.test.js: import { describe, it, expect } from 'vitest'; import { Angle } from '../../../src/core/models/Angle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { Arc } from '../../../src/core/models/Arc.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertAngleNearlyEqual } from '../../__helpers__/assertions.js'; import { RIGHT_ANGLE, STRAIGHT_ANGLE, FULL_CIRCLE, EQUILATERAL, NEGATIVE, OVER_360 } from '../../__fixtures__/angles.js'; describe('Angle', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create angle with degrees', () => { const angle = new Angle(90); expect(angle.degrees).toBe(90); }); it('should allow negative angles', () => { const angle = new Angle(-45); expect(angle.degrees).toBe(-45); }); it('should allow angles over 360', () => { const angle = new Angle(720); expect(angle.degrees).toBe(720); }); }); describe('Conversions', () => { it('should convert degrees to radians', () => { const angle = RIGHT_ANGLE; expect(angle.toRadians()).toBeCloseTo(Math.PI / 2, 10); }); it('should normalize angles to 0-360 range', () => { const cases = [ { input: 0, expected: 0 }, { input: 360, expected: 0 }, { input: 720, expected: 0 }, { input: -90, expected: 270 }, { input: -360, expected: 0 }, { input: 45, expected: 45 }, { input: 405, expected: 45 } ]; cases.forEach(({ input, expected }) => { const angle = new Angle(input); expect(angle.normalize()).toBe(expected); }); }); }); describe('Static Methods', () => { it('should define angle using Law of Sines', () => { // Setup triangle with known angles and sides const arcA = new Distance(5); const arcB = new Distance(7); const arcC = new Distance(9); const angleC = new Angle(60); // Calculate using Law of Sines const angleA = Angle.defineBy(Arc.onSphere(), Arc.onSphere(), angleC, arcA, arcB, arcC); // The result should satisfy the Law of Sines const sinA = Math.sin(angleA.toRadians()); const sinC = Math.sin(angleC.toRadians()); const ratio = (arcA.inMeters() * sinC) / (arcC.inMeters() * sinA); expect(ratio).toBeCloseTo(1, 5); }); it('should define angle using Law of Cosines', () => { // Setup triangle with known sides const arcA = new Distance(5); const arcB = new Distance(7); const arcC = new Distance(9); // Calculate using Law of Cosines const angleC = Angle.defineBy(Arc.onSphere(), Arc.onSphere(), Arc.onSphere(), arcA, arcB, arcC); // Verify using Law of Cosines formula const cosC = (Math.pow(arcA.inMeters(), 2) + Math.pow(arcB.inMeters(), 2) - Math.pow(arcC.inMeters(), 2)) / (2 * arcA.inMeters() * arcB.inMeters()); const expectedAngle = new Angle(Math.acos(cosC) * 180 / Math.PI); assertAngleNearlyEqual(angleC, expectedAngle); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle 0 degrees', () => { const angle = new Angle(0); expect(angle.degrees).toBe(0); expect(angle.toRadians()).toBe(0); }); it('should handle 360 degrees', () => { const angle = new Angle(360); expect(angle.degrees).toBe(360); expect(angle.toRadians()).toBeCloseTo(2 * Math.PI, 10); }); it('should handle negative angles', () => { const angle = NEGATIVE; // -45 degrees expect(angle.normalize()).toBe(315); }); it('should handle angles over 360', () => { const angle = OVER_360; // 400 degrees expect(angle.normalize()).toBe(40); }); }); describe('String Representation', () => { it('should format angle correctly', () => { const angle = new Angle(45.5); expect(angle.toString()).toBe('Angle(45.5 degrees)'); }); }); describe(TEST_CATEGORIES.REAL_WORLD, () => { it('should handle right angle', () => { assertAngleNearlyEqual(RIGHT_ANGLE, new Angle(90)); }); it('should handle straight angle', () => { assertAngleNearlyEqual(STRAIGHT_ANGLE, new Angle(180)); }); it('should handle full circle', () => { assertAngleNearlyEqual(FULL_CIRCLE, new Angle(360)); }); it('should handle equilateral triangle angle', () => { assertAngleNearlyEqual(EQUILATERAL, new Angle(60)); }); }); });
|   |       --- Angle.test.ts: import { describe, it, expect } from 'vitest'; import { Angle } from '../../../src/core/models/Angle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { Arc } from '../../../src/core/models/Arc.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertAngleNearlyEqual } from '../../__helpers__/assertions.js'; import { RIGHT_ANGLE, STRAIGHT_ANGLE, FULL_CIRCLE, EQUILATERAL, ACUTE, OBTUSE, NEGATIVE, OVER_360 } from '../../__fixtures__/angles.js'; describe('Angle', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create angle with degrees', () => { const angle = new Angle(90); expect(angle.degrees).toBe(90); }); it('should allow negative angles', () => { const angle = new Angle(-45); expect(angle.degrees).toBe(-45); }); it('should allow angles over 360', () => { const angle = new Angle(720); expect(angle.degrees).toBe(720); }); }); describe('Conversions', () => { it('should convert degrees to radians', () => { const angle = RIGHT_ANGLE; expect(angle.toRadians()).toBeCloseTo(Math.PI / 2, 10); }); it('should normalize angles to 0-360 range', () => { const cases = [ { input: 0, expected: 0 }, { input: 360, expected: 0 }, { input: 720, expected: 0 }, { input: -90, expected: 270 }, { input: -360, expected: 0 }, { input: 45, expected: 45 }, { input: 405, expected: 45 } ]; cases.forEach(({ input, expected }) => { const angle = new Angle(input); expect(angle.normalize()).toBe(expected); }); }); }); describe('Static Methods', () => { it('should define angle using Law of Sines', () => { // Setup triangle with known angles and sides const arcA = new Distance(5); const arcB = new Distance(7); const arcC = new Distance(9); const angleC = new Angle(60); // Calculate using Law of Sines const angleA = Angle.defineBy( Arc.onSphere(), Arc.onSphere(), angleC, arcA, arcB, arcC ); // The result should satisfy the Law of Sines const sinA = Math.sin(angleA.toRadians()); const sinC = Math.sin(angleC.toRadians()); const ratio = (arcA.inMeters() * sinC) / (arcC.inMeters() * sinA); expect(ratio).toBeCloseTo(1, 5); }); it('should define angle using Law of Cosines', () => { // Setup triangle with known sides const arcA = new Distance(5); const arcB = new Distance(7); const arcC = new Distance(9); // Calculate using Law of Cosines const angleC = Angle.defineBy( Arc.onSphere(), Arc.onSphere(), Arc.onSphere(), arcA, arcB, arcC ); // Verify using Law of Cosines formula const cosC = ( Math.pow(arcA.inMeters(), 2) + Math.pow(arcB.inMeters(), 2) - Math.pow(arcC.inMeters(), 2) ) / (2 * arcA.inMeters() * arcB.inMeters()); const expectedAngle = new Angle(Math.acos(cosC) * 180 / Math.PI); assertAngleNearlyEqual(angleC, expectedAngle); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle 0 degrees', () => { const angle = new Angle(0); expect(angle.degrees).toBe(0); expect(angle.toRadians()).toBe(0); }); it('should handle 360 degrees', () => { const angle = new Angle(360); expect(angle.degrees).toBe(360); expect(angle.toRadians()).toBeCloseTo(2 * Math.PI, 10); }); it('should handle negative angles', () => { const angle = NEGATIVE; // -45 degrees expect(angle.normalize()).toBe(315); }); it('should handle angles over 360', () => { const angle = OVER_360; // 400 degrees expect(angle.normalize()).toBe(40); }); }); describe('String Representation', () => { it('should format angle correctly', () => { const angle = new Angle(45.5); expect(angle.toString()).toBe('Angle(45.5 degrees)'); }); }); describe(TEST_CATEGORIES.REAL_WORLD, () => { it('should handle right angle', () => { assertAngleNearlyEqual(RIGHT_ANGLE, new Angle(90)); }); it('should handle straight angle', () => { assertAngleNearlyEqual(STRAIGHT_ANGLE, new Angle(180)); }); it('should handle full circle', () => { assertAngleNearlyEqual(FULL_CIRCLE, new Angle(360)); }); it('should handle equilateral triangle angle', () => { assertAngleNearlyEqual(EQUILATERAL, new Angle(60)); }); }); });
|   |       --- Arc.test.d.ts: export {};
|   |       --- Arc.test.js: // Arc test file import { describe, it, expect } from 'vitest'; import { Arc } from '../../../src/core/models/Arc.js'; import { Angle } from '../../../src/core/models/Angle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertCoordinateNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, NEW_YORK, TOKYO, EQUATOR_PRIME, NORTH_POLE } from '../../__fixtures__/coordinates.js'; import { EARTH_RADIUS, LONDON_TO_PARIS, ZERO_DISTANCE } from '../../__fixtures__/distances.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; describe('Arc', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create arc on sphere with default radius', () => { const arc = Arc.onSphere(); const circumference = arc.length(); assertDistanceNearlyEqual(circumference, Distance.fromKilometers(2 * Math.PI * 6371), 1000); }); it('should create arc on sphere with custom radius', () => { const radius = Distance.fromKilometers(1000); const arc = Arc.onSphere(radius); const circumference = arc.length(); assertDistanceNearlyEqual(circumference, Distance.fromKilometers(2 * Math.PI * 1000), 1); }); it('should create arc from two points', () => { const arc = Arc.fromPoints(LONDON, PARIS); const length = arc.length(); assertDistanceNearlyEqual(length, LONDON_TO_PARIS, 1000); }); it('should create arc with central angle', () => { const angle = new Angle(90); // Quarter circle const arc = Arc.onSphere(EARTH_RADIUS, angle); const length = arc.length(); assertDistanceNearlyEqual(length, Distance.fromKilometers(Math.PI * 6371 / 2), 1); }); }); describe('Length Calculations', () => { it('should calculate zero length for same point', () => { const arc = Arc.fromPoints(LONDON, LONDON); assertDistanceNearlyEqual(arc.length(), ZERO_DISTANCE); }); it('should calculate length of quarter earth circumference', () => { const arc = Arc.fromPoints(EQUATOR_PRIME, NORTH_POLE); assertDistanceNearlyEqual(arc.length(), Distance.fromKilometers(10000), // ~10,000 km (quarter Earth circumference) 100); }); it('should calculate length of major city pairs', () => { const testCases = [ { start: LONDON, end: PARIS, expectedKm: 344 }, { start: NEW_YORK, end: TOKYO, expectedKm: 10838 } ]; testCases.forEach(({ start, end, expectedKm }) => { const arc = Arc.fromPoints(start, end); assertDistanceNearlyEqual(arc.length(), Distance.fromKilometers(expectedKm), 100); }); }); }); describe('Interpolation', () => { it('should interpolate midpoint', () => { const arc = Arc.fromPoints(LONDON, PARIS); const midpoint = arc.interpolate(0.5); expect(midpoint).toBeDefined(); if (midpoint) { // Verify midpoint is roughly equidistant from both endpoints const toStart = Arc.fromPoints(midpoint, LONDON).length(); const toEnd = Arc.fromPoints(midpoint, PARIS).length(); assertDistanceNearlyEqual(toStart, toEnd, 1); } }); it('should return start point for fraction 0', () => { const arc = Arc.fromPoints(LONDON, PARIS); const point = arc.interpolate(0); expect(point).toBeDefined(); if (point) { assertCoordinateNearlyEqual(point, LONDON); } }); it('should return end point for fraction 1', () => { const arc = Arc.fromPoints(LONDON, PARIS); const point = arc.interpolate(1); expect(point).toBeDefined(); if (point) { assertCoordinateNearlyEqual(point, PARIS); } }); it('should throw error for invalid fractions', () => { const arc = Arc.fromPoints(LONDON, PARIS); expect(() => arc.interpolate(-0.1)).toThrow(); expect(() => arc.interpolate(1.1)).toThrow(); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle antipodal points', () => { const arc = Arc.fromPoints(new Coordinate(0, 0), new Coordinate(0, 180)); assertDistanceNearlyEqual(arc.length(), Distance.fromKilometers(20000), // ~20,000 km (half Earth circumference) 100); }); it('should handle tiny arcs', () => { const start = LONDON; const end = new Coordinate(LONDON.latitude + 0.0001, LONDON.longitude + 0.0001); const arc = Arc.fromPoints(start, end); expect(arc.length().inMeters()).toBeLessThan(100); }); }); });
|   |       --- Arc.test.ts: // Arc test file import { describe, it, expect } from 'vitest'; import { Arc } from '../../../src/core/models/Arc.js'; import { Angle } from '../../../src/core/models/Angle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertCoordinateNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, NEW_YORK, TOKYO, EQUATOR_PRIME, NORTH_POLE } from '../../__fixtures__/coordinates.js'; import { EARTH_RADIUS, LONDON_TO_PARIS, TINY_DISTANCE, ZERO_DISTANCE } from '../../__fixtures__/distances.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; describe('Arc', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create arc on sphere with default radius', () => { const arc = Arc.onSphere(); const circumference = arc.length(); assertDistanceNearlyEqual( circumference, Distance.fromKilometers(2 * Math.PI * 6371), 1000 ); }); it('should create arc on sphere with custom radius', () => { const radius = Distance.fromKilometers(1000); const arc = Arc.onSphere(radius); const circumference = arc.length(); assertDistanceNearlyEqual( circumference, Distance.fromKilometers(2 * Math.PI * 1000), 1 ); }); it('should create arc from two points', () => { const arc = Arc.fromPoints(LONDON, PARIS); const length = arc.length(); assertDistanceNearlyEqual(length, LONDON_TO_PARIS, 1000); }); it('should create arc with central angle', () => { const angle = new Angle(90); // Quarter circle const arc = Arc.onSphere(EARTH_RADIUS, angle); const length = arc.length(); assertDistanceNearlyEqual( length, Distance.fromKilometers(Math.PI * 6371 / 2), 1 ); }); }); describe('Length Calculations', () => { it('should calculate zero length for same point', () => { const arc = Arc.fromPoints(LONDON, LONDON); assertDistanceNearlyEqual(arc.length(), ZERO_DISTANCE); }); it('should calculate length of quarter earth circumference', () => { const arc = Arc.fromPoints(EQUATOR_PRIME, NORTH_POLE); assertDistanceNearlyEqual( arc.length(), Distance.fromKilometers(10000), // ~10,000 km (quarter Earth circumference) 100 ); }); it('should calculate length of major city pairs', () => { const testCases = [ { start: LONDON, end: PARIS, expectedKm: 344 }, { start: NEW_YORK, end: TOKYO, expectedKm: 10838 } ]; testCases.forEach(({ start, end, expectedKm }) => { const arc = Arc.fromPoints(start, end); assertDistanceNearlyEqual( arc.length(), Distance.fromKilometers(expectedKm), 100 ); }); }); }); describe('Interpolation', () => { it('should interpolate midpoint', () => { const arc = Arc.fromPoints(LONDON, PARIS); const midpoint = arc.interpolate(0.5); expect(midpoint).toBeDefined(); if (midpoint) { // Verify midpoint is roughly equidistant from both endpoints const toStart = Arc.fromPoints(midpoint, LONDON).length(); const toEnd = Arc.fromPoints(midpoint, PARIS).length(); assertDistanceNearlyEqual(toStart, toEnd, 1); } }); it('should return start point for fraction 0', () => { const arc = Arc.fromPoints(LONDON, PARIS); const point = arc.interpolate(0); expect(point).toBeDefined(); if (point) { assertCoordinateNearlyEqual(point, LONDON); } }); it('should return end point for fraction 1', () => { const arc = Arc.fromPoints(LONDON, PARIS); const point = arc.interpolate(1); expect(point).toBeDefined(); if (point) { assertCoordinateNearlyEqual(point, PARIS); } }); it('should throw error for invalid fractions', () => { const arc = Arc.fromPoints(LONDON, PARIS); expect(() => arc.interpolate(-0.1)).toThrow(); expect(() => arc.interpolate(1.1)).toThrow(); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle antipodal points', () => { const arc = Arc.fromPoints( new Coordinate(0, 0), new Coordinate(0, 180) ); assertDistanceNearlyEqual( arc.length(), Distance.fromKilometers(20000), // ~20,000 km (half Earth circumference) 100 ); }); it('should handle tiny arcs', () => { const start = LONDON; const end = new Coordinate( LONDON.latitude + 0.0001, LONDON.longitude + 0.0001 ); const arc = Arc.fromPoints(start, end); expect(arc.length().inMeters()).toBeLessThan(100); }); }); });
|   |       --- Azimuth.test.d.ts: export {};
|   |       --- Azimuth.test.js: export {}; // Azimuth test file
|   |       --- Azimuth.test.ts: // Azimuth test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- Bearing.test.d.ts: export {};
|   |       --- Bearing.test.js: // Bearing test file import { describe, it, expect } from 'vitest'; import { Azimuth } from '../../../src/core/models/Azimuth.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertAngleNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, NEW_YORK, TOKYO, NORTH_POLE, SOUTH_POLE, EQUATOR_PRIME, QUAD_1, QUAD_2, QUAD_3, QUAD_4 } from '../../__fixtures__/coordinates.js'; import { NORTH, EAST, SOUTH, WEST } from '../../__fixtures__/angles.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; import { Angle } from '../../../src/core/models/Angle.js'; describe('Azimuth', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create azimuth between two points', () => { const azimuth = Azimuth.from(LONDON).to(PARIS); expect(azimuth).toBeDefined(); }); }); describe('Forward Azimuth', () => { it('should calculate forward azimuth between major cities', () => { const testCases = [ { start: LONDON, end: PARIS, expectedDegrees: 117 // Approximate }, { start: NEW_YORK, end: TOKYO, expectedDegrees: 333 // Approximate } ]; testCases.forEach(({ start, end, expectedDegrees }) => { const azimuth = Azimuth.from(start).to(end); assertAngleNearlyEqual(azimuth.forward(), new Angle(expectedDegrees), 1); }); }); it('should calculate cardinal directions from equator', () => { // Test points 1 degree in each cardinal direction from equator const north = new Coordinate(1, 0); const east = new Coordinate(0, 1); const south = new Coordinate(-1, 0); const west = new Coordinate(0, -1); assertAngleNearlyEqual(Azimuth.from(EQUATOR_PRIME).to(north).forward(), NORTH); assertAngleNearlyEqual(Azimuth.from(EQUATOR_PRIME).to(east).forward(), EAST); assertAngleNearlyEqual(Azimuth.from(EQUATOR_PRIME).to(south).forward(), SOUTH); assertAngleNearlyEqual(Azimuth.from(EQUATOR_PRIME).to(west).forward(), WEST); }); }); describe('Reverse Azimuth', () => { it('should calculate reverse azimuth as forward + 180°', () => { const testPoints = [ [LONDON, PARIS], [NEW_YORK, TOKYO], [QUAD_1, QUAD_3], [QUAD_2, QUAD_4] ]; testPoints.forEach(([start, end]) => { const azimuth = Azimuth.from(start).to(end); const forward = azimuth.forward().degrees; const reverse = azimuth.reverse().degrees; const diff = Math.abs((reverse - forward + 180) % 360); expect(diff).toBeLessThan(0.1); }); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle poles', () => { // All directions from North Pole are south const fromNorthPole = Azimuth.from(NORTH_POLE).to(LONDON); assertAngleNearlyEqual(fromNorthPole.forward(), SOUTH); // All directions from South Pole are north const fromSouthPole = Azimuth.from(SOUTH_POLE).to(LONDON); assertAngleNearlyEqual(fromSouthPole.forward(), NORTH); }); it('should handle antipodal points', () => { const point1 = new Coordinate(0, 0); const point2 = new Coordinate(0, 180); const azimuth = Azimuth.from(point1).to(point2); assertAngleNearlyEqual(azimuth.forward(), EAST); }); it('should handle same point', () => { const azimuth = Azimuth.from(LONDON).to(LONDON); expect(azimuth.forward().degrees).toBeDefined(); }); }); describe('String Representation', () => { it('should format azimuth correctly', () => { const azimuth = Azimuth.from(LONDON).to(PARIS); expect(azimuth.toString()).toBe(`Azimuth(${LONDON} → ${PARIS})`); }); }); });
|   |       --- Bearing.test.ts: // Bearing test file import { describe, it, expect } from 'vitest'; import { Azimuth } from '../../../src/core/models/Azimuth.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertAngleNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, NEW_YORK, TOKYO, NORTH_POLE, SOUTH_POLE, EQUATOR_PRIME, QUAD_1, QUAD_2, QUAD_3, QUAD_4 } from '../../__fixtures__/coordinates.js'; import { NORTH, EAST, SOUTH, WEST } from '../../__fixtures__/angles.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; import { Angle } from '../../../src/core/models/Angle.js'; describe('Azimuth', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create azimuth between two points', () => { const azimuth = Azimuth.from(LONDON).to(PARIS); expect(azimuth).toBeDefined(); }); }); describe('Forward Azimuth', () => { it('should calculate forward azimuth between major cities', () => { const testCases = [ { start: LONDON, end: PARIS, expectedDegrees: 117 // Approximate }, { start: NEW_YORK, end: TOKYO, expectedDegrees: 333 // Approximate } ]; testCases.forEach(({ start, end, expectedDegrees }) => { const azimuth = Azimuth.from(start).to(end); assertAngleNearlyEqual( azimuth.forward(), new Angle(expectedDegrees), 1 ); }); }); it('should calculate cardinal directions from equator', () => { // Test points 1 degree in each cardinal direction from equator const north = new Coordinate(1, 0); const east = new Coordinate(0, 1); const south = new Coordinate(-1, 0); const west = new Coordinate(0, -1); assertAngleNearlyEqual( Azimuth.from(EQUATOR_PRIME).to(north).forward(), NORTH ); assertAngleNearlyEqual( Azimuth.from(EQUATOR_PRIME).to(east).forward(), EAST ); assertAngleNearlyEqual( Azimuth.from(EQUATOR_PRIME).to(south).forward(), SOUTH ); assertAngleNearlyEqual( Azimuth.from(EQUATOR_PRIME).to(west).forward(), WEST ); }); }); describe('Reverse Azimuth', () => { it('should calculate reverse azimuth as forward + 180°', () => { const testPoints = [ [LONDON, PARIS], [NEW_YORK, TOKYO], [QUAD_1, QUAD_3], [QUAD_2, QUAD_4] ]; testPoints.forEach(([start, end]) => { const azimuth = Azimuth.from(start).to(end); const forward = azimuth.forward().degrees; const reverse = azimuth.reverse().degrees; const diff = Math.abs((reverse - forward + 180) % 360); expect(diff).toBeLessThan(0.1); }); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle poles', () => { // All directions from North Pole are south const fromNorthPole = Azimuth.from(NORTH_POLE).to(LONDON); assertAngleNearlyEqual(fromNorthPole.forward(), SOUTH); // All directions from South Pole are north const fromSouthPole = Azimuth.from(SOUTH_POLE).to(LONDON); assertAngleNearlyEqual(fromSouthPole.forward(), NORTH); }); it('should handle antipodal points', () => { const point1 = new Coordinate(0, 0); const point2 = new Coordinate(0, 180); const azimuth = Azimuth.from(point1).to(point2); assertAngleNearlyEqual(azimuth.forward(), EAST); }); it('should handle same point', () => { const azimuth = Azimuth.from(LONDON).to(LONDON); expect(azimuth.forward().degrees).toBeDefined(); }); }); describe('String Representation', () => { it('should format azimuth correctly', () => { const azimuth = Azimuth.from(LONDON).to(PARIS); expect(azimuth.toString()).toBe( `Azimuth(${LONDON} → ${PARIS})` ); }); }); });
|   |       --- Coordinate.test.d.ts: export {};
|   |       --- Coordinate.test.js: // Coordinate test file import { describe, it, expect } from 'vitest'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; import { ERROR_MESSAGES, TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertCoordinateNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, TOKYO, MOUNT_EVEREST } from '../../__fixtures__/coordinates.js'; describe('Coordinate', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create a valid coordinate', () => { const coord = new Coordinate(51.5074, -0.1278); expect(coord.latitude).toBe(51.5074); expect(coord.longitude).toBe(-0.1278); expect(coord.altitude).toBeUndefined(); }); it('should create a coordinate with altitude', () => { const coord = new Coordinate(27.9881, 86.9250, 8848); expect(coord.latitude).toBe(27.9881); expect(coord.longitude).toBe(86.9250); expect(coord.altitude).toBe(8848); }); it('should create coordinate using static factory method', () => { const coord = Coordinate.at(51.5074, -0.1278); expect(coord.latitude).toBe(51.5074); expect(coord.longitude).toBe(-0.1278); }); }); describe(TEST_CATEGORIES.VALIDATION, () => { it('should throw error for latitude below -90', () => { expect(() => new Coordinate(-91, 0)) .toThrow(ERROR_MESSAGES.INVALID_LATITUDE); }); it('should throw error for latitude above 90', () => { expect(() => new Coordinate(91, 0)) .toThrow(ERROR_MESSAGES.INVALID_LATITUDE); }); it('should throw error for longitude below -180', () => { expect(() => new Coordinate(0, -181)) .toThrow(ERROR_MESSAGES.INVALID_LONGITUDE); }); it('should throw error for longitude above 180', () => { expect(() => new Coordinate(0, 181)) .toThrow(ERROR_MESSAGES.INVALID_LONGITUDE); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle North Pole', () => { const coord = new Coordinate(90, 0); expect(coord.latitude).toBe(90); expect(coord.longitude).toBe(0); }); it('should handle South Pole', () => { const coord = new Coordinate(-90, 0); expect(coord.latitude).toBe(-90); expect(coord.longitude).toBe(0); }); it('should handle International Date Line', () => { const coord1 = new Coordinate(0, 180); const coord2 = new Coordinate(0, -180); expect(coord1.longitude).toBe(180); expect(coord2.longitude).toBe(-180); }); }); describe('Equality', () => { it('should correctly compare equal coordinates', () => { const coord1 = new Coordinate(51.5074, -0.1278); const coord2 = new Coordinate(51.5074, -0.1278); expect(coord1.equals(coord2)).toBe(true); }); it('should correctly compare unequal coordinates', () => { const coord1 = new Coordinate(51.5074, -0.1278); const coord2 = new Coordinate(51.5074, -0.1279); expect(coord1.equals(coord2)).toBe(false); }); it('should handle altitude in equality comparison', () => { const coord1 = new Coordinate(27.9881, 86.9250, 8848); const coord2 = new Coordinate(27.9881, 86.9250); expect(coord1.equals(coord2)).toBe(false); }); }); describe('String Representation', () => { it('should format coordinate without altitude', () => { const coord = LONDON; expect(coord.toString()).toBe('(51.5074°, -0.1278°)'); }); it('should format coordinate with altitude', () => { const coord = MOUNT_EVEREST; expect(coord.toString()).toBe('(27.9881°, 86.925°, 8848m)'); }); }); describe(TEST_CATEGORIES.REAL_WORLD, () => { it('should correctly represent London coordinates', () => { assertCoordinateNearlyEqual(LONDON, new Coordinate(51.5074, -0.1278)); }); it('should correctly represent Tokyo coordinates', () => { assertCoordinateNearlyEqual(TOKYO, new Coordinate(35.6762, 139.6503)); }); }); });
|   |       --- Coordinate.test.ts: // Coordinate test file import { describe, it, expect } from 'vitest'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; import { ERROR_MESSAGES, TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertCoordinateNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, TOKYO, NORTH_POLE, SOUTH_POLE, MOUNT_EVEREST } from '../../__fixtures__/coordinates.js'; describe('Coordinate', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create a valid coordinate', () => { const coord = new Coordinate(51.5074, -0.1278); expect(coord.latitude).toBe(51.5074); expect(coord.longitude).toBe(-0.1278); expect(coord.altitude).toBeUndefined(); }); it('should create a coordinate with altitude', () => { const coord = new Coordinate(27.9881, 86.9250, 8848); expect(coord.latitude).toBe(27.9881); expect(coord.longitude).toBe(86.9250); expect(coord.altitude).toBe(8848); }); it('should create coordinate using static factory method', () => { const coord = Coordinate.at(51.5074, -0.1278); expect(coord.latitude).toBe(51.5074); expect(coord.longitude).toBe(-0.1278); }); }); describe(TEST_CATEGORIES.VALIDATION, () => { it('should throw error for latitude below -90', () => { expect(() => new Coordinate(-91, 0)) .toThrow(ERROR_MESSAGES.INVALID_LATITUDE); }); it('should throw error for latitude above 90', () => { expect(() => new Coordinate(91, 0)) .toThrow(ERROR_MESSAGES.INVALID_LATITUDE); }); it('should throw error for longitude below -180', () => { expect(() => new Coordinate(0, -181)) .toThrow(ERROR_MESSAGES.INVALID_LONGITUDE); }); it('should throw error for longitude above 180', () => { expect(() => new Coordinate(0, 181)) .toThrow(ERROR_MESSAGES.INVALID_LONGITUDE); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle North Pole', () => { const coord = new Coordinate(90, 0); expect(coord.latitude).toBe(90); expect(coord.longitude).toBe(0); }); it('should handle South Pole', () => { const coord = new Coordinate(-90, 0); expect(coord.latitude).toBe(-90); expect(coord.longitude).toBe(0); }); it('should handle International Date Line', () => { const coord1 = new Coordinate(0, 180); const coord2 = new Coordinate(0, -180); expect(coord1.longitude).toBe(180); expect(coord2.longitude).toBe(-180); }); }); describe('Equality', () => { it('should correctly compare equal coordinates', () => { const coord1 = new Coordinate(51.5074, -0.1278); const coord2 = new Coordinate(51.5074, -0.1278); expect(coord1.equals(coord2)).toBe(true); }); it('should correctly compare unequal coordinates', () => { const coord1 = new Coordinate(51.5074, -0.1278); const coord2 = new Coordinate(51.5074, -0.1279); expect(coord1.equals(coord2)).toBe(false); }); it('should handle altitude in equality comparison', () => { const coord1 = new Coordinate(27.9881, 86.9250, 8848); const coord2 = new Coordinate(27.9881, 86.9250); expect(coord1.equals(coord2)).toBe(false); }); }); describe('String Representation', () => { it('should format coordinate without altitude', () => { const coord = LONDON; expect(coord.toString()).toBe('(51.5074°, -0.1278°)'); }); it('should format coordinate with altitude', () => { const coord = MOUNT_EVEREST; expect(coord.toString()).toBe('(27.9881°, 86.925°, 8848m)'); }); }); describe(TEST_CATEGORIES.REAL_WORLD, () => { it('should correctly represent London coordinates', () => { assertCoordinateNearlyEqual( LONDON, new Coordinate(51.5074, -0.1278) ); }); it('should correctly represent Tokyo coordinates', () => { assertCoordinateNearlyEqual( TOKYO, new Coordinate(35.6762, 139.6503) ); }); }); });
|   |       --- Distance.test.d.ts: export {};
|   |       --- Distance.test.js: import { describe, it, expect } from 'vitest'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual } from '../../__helpers__/assertions.js'; import { ONE_KILOMETER, ONE_MILE, LONDON_TO_PARIS } from '../../__fixtures__/distances.js'; describe('Distance', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create distance from meters', () => { const distance = new Distance(1000); expect(distance.inMeters()).toBe(1000); }); it('should create distance from kilometers', () => { const distance = Distance.fromKilometers(1); expect(distance.inMeters()).toBe(1000); }); it('should create distance from miles', () => { const distance = Distance.fromMiles(1); expect(distance.inMeters()).toBeCloseTo(1609.344, 2); }); it('should create distance from nautical miles', () => { const distance = Distance.fromNauticalMiles(1); expect(distance.inMeters()).toBeCloseTo(1852, 2); }); it('should create distance from feet', () => { const distance = Distance.fromFeet(5280); assertDistanceNearlyEqual(distance, ONE_MILE); }); }); describe('Conversions', () => { it('should convert to kilometers', () => { const distance = new Distance(1000); expect(distance.inKilometers()).toBe(1); }); it('should convert to miles', () => { const distance = new Distance(1609.344); expect(distance.inMiles()).toBeCloseTo(1, 5); }); it('should convert to nautical miles', () => { const distance = new Distance(1852); expect(distance.inNauticalMiles()).toBeCloseTo(1, 5); }); it('should convert to feet', () => { const distance = ONE_MILE; expect(distance.inFeet()).toBeCloseTo(5280, 1); }); it('should convert to yards', () => { const distance = ONE_MILE; expect(distance.inYards()).toBeCloseTo(1760, 1); }); }); describe('Formatting', () => { it('should format with default units', () => { const distance = ONE_KILOMETER; expect(distance.toString()).toBe('1.00 km'); }); it('should format with specified units', () => { const distance = ONE_KILOMETER; expect(distance.toFormat('km')).toBe('1.00 km'); expect(distance.toFormat('mi')).toMatch(/0.62 mi/); expect(distance.toFormat('nm')).toMatch(/0.54 nm/); expect(distance.toFormat('m')).toBe('1000.00 m'); }); }); describe(TEST_CATEGORIES.REAL_WORLD, () => { it('should calculate London to Paris distance', () => { assertDistanceNearlyEqual(LONDON_TO_PARIS, Distance.fromKilometers(344), 1000 // 1km tolerance for real-world distance ); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle zero distance', () => { const distance = new Distance(0); expect(distance.inMeters()).toBe(0); expect(distance.inKilometers()).toBe(0); expect(distance.inMiles()).toBe(0); }); it('should handle very small distances', () => { const distance = new Distance(0.0001); expect(distance.inMeters()).toBeCloseTo(0.0001, 10); }); it('should handle very large distances', () => { const largeDistance = Distance.fromKilometers(1e6); expect(largeDistance.inKilometers()).toBe(1e6); }); }); });
|   |       --- Distance.test.ts: import { describe, it, expect } from 'vitest'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual } from '../../__helpers__/assertions.js'; import { ONE_KILOMETER, ONE_MILE, ONE_NAUTICAL_MILE, LONDON_TO_PARIS } from '../../__fixtures__/distances.js'; describe('Distance', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create distance from meters', () => { const distance = new Distance(1000); expect(distance.inMeters()).toBe(1000); }); it('should create distance from kilometers', () => { const distance = Distance.fromKilometers(1); expect(distance.inMeters()).toBe(1000); }); it('should create distance from miles', () => { const distance = Distance.fromMiles(1); expect(distance.inMeters()).toBeCloseTo(1609.344, 2); }); it('should create distance from nautical miles', () => { const distance = Distance.fromNauticalMiles(1); expect(distance.inMeters()).toBeCloseTo(1852, 2); }); it('should create distance from feet', () => { const distance = Distance.fromFeet(5280); assertDistanceNearlyEqual(distance, ONE_MILE); }); }); describe('Conversions', () => { it('should convert to kilometers', () => { const distance = new Distance(1000); expect(distance.inKilometers()).toBe(1); }); it('should convert to miles', () => { const distance = new Distance(1609.344); expect(distance.inMiles()).toBeCloseTo(1, 5); }); it('should convert to nautical miles', () => { const distance = new Distance(1852); expect(distance.inNauticalMiles()).toBeCloseTo(1, 5); }); it('should convert to feet', () => { const distance = ONE_MILE; expect(distance.inFeet()).toBeCloseTo(5280, 1); }); it('should convert to yards', () => { const distance = ONE_MILE; expect(distance.inYards()).toBeCloseTo(1760, 1); }); }); describe('Formatting', () => { it('should format with default units', () => { const distance = ONE_KILOMETER; expect(distance.toString()).toBe('1.00 km'); }); it('should format with specified units', () => { const distance = ONE_KILOMETER; expect(distance.toFormat('km')).toBe('1.00 km'); expect(distance.toFormat('mi')).toMatch(/0.62 mi/); expect(distance.toFormat('nm')).toMatch(/0.54 nm/); expect(distance.toFormat('m')).toBe('1000.00 m'); }); }); describe(TEST_CATEGORIES.REAL_WORLD, () => { it('should calculate London to Paris distance', () => { assertDistanceNearlyEqual( LONDON_TO_PARIS, Distance.fromKilometers(344), 1000 // 1km tolerance for real-world distance ); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle zero distance', () => { const distance = new Distance(0); expect(distance.inMeters()).toBe(0); expect(distance.inKilometers()).toBe(0); expect(distance.inMiles()).toBe(0); }); it('should handle very small distances', () => { const distance = new Distance(0.0001); expect(distance.inMeters()).toBeCloseTo(0.0001, 10); }); it('should handle very large distances', () => { const largeDistance = Distance.fromKilometers(1e6); expect(largeDistance.inKilometers()).toBe(1e6); }); }); });
|   |       --- GreatCircle.test.d.ts: export {};
|   |       --- GreatCircle.test.js: import { describe, it, expect } from 'vitest'; import { GreatCircle } from '../../../src/core/models/GreatCircle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertCoordinateNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, TOKYO } from '../../__fixtures__/coordinates.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; describe('GreatCircle', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create great circle using factory method', () => { const circle = GreatCircle.from(LONDON).to(PARIS); expect(circle).toBeDefined(); expect(circle.toString()).toBe(`GreatCircle(${LONDON} → ${PARIS})`); }); it('should allow custom sphere radius', () => { const customRadius = Distance.fromKilometers(2000); const circle = GreatCircle.from(LONDON) .to(PARIS) .withSphere(customRadius); expect(circle).toBeDefined(); }); }); describe('Distance Calculations', () => { it('should calculate correct distance between points', () => { const circle = GreatCircle.from(LONDON).to(PARIS); const distance = circle.distance(); assertDistanceNearlyEqual(distance, Distance.fromKilometers(344), // ~344km from London to Paris 1000 // 1km tolerance ); }); it('should handle zero distance', () => { const circle = GreatCircle.from(LONDON).to(LONDON); const distance = circle.distance(); expect(distance.inMeters()).toBe(0); }); it('should handle antipodal points', () => { const antipode = new Coordinate(-LONDON.latitude, LONDON.longitude + 180); const circle = GreatCircle.from(LONDON).to(antipode); const distance = circle.distance(); expect(distance.inKilometers()).toBeCloseTo(20000, -1); // ~20,000km }); }); describe('Point Generation', () => { it('should generate points with specified spacing', () => { const circle = GreatCircle.from(LONDON).to(TOKYO); const spacing = Distance.fromKilometers(500); const points = circle.generatePoints({ spacing }); // Verify point spacing for (let i = 1; i < points.length; i++) { const segmentDistance = GreatCircle.from(points[i - 1]) .to(points[i]) .distance(); expect(segmentDistance.inKilometers()) .toBeLessThanOrEqual(spacing.inKilometers() * 1.1); } }); it('should respect minimum points parameter', () => { const circle = GreatCircle.from(LONDON).to(PARIS); const minPoints = 10; const points = circle.generatePoints({ minPoints }); expect(points.length).toBeGreaterThanOrEqual(minPoints); }); it('should respect maximum points parameter', () => { const circle = GreatCircle.from(LONDON).to(TOKYO); const maxPoints = 50; const points = circle.generatePoints({ maxPoints }); expect(points.length).toBeLessThanOrEqual(maxPoints); }); }); describe('Interpolation', () => { it('should interpolate midpoint', () => { const circle = GreatCircle.from(LONDON).to(PARIS); const midpoint = circle.interpolate(0.5); expect(midpoint).toBeDefined(); if (!midpoint) { throw new Error('Failed to interpolate midpoint'); } // Check midpoint is equidistant from endpoints const distToStart = GreatCircle.from(LONDON) .to(midpoint) .distance(); const distToEnd = GreatCircle.from(midpoint) .to(PARIS) .distance(); assertDistanceNearlyEqual(distToStart, distToEnd, 1); }); it('should handle fraction limits', () => { const circle = GreatCircle.from(LONDON).to(PARIS); const start = circle.interpolate(0); expect(start).toBeDefined(); if (start) { assertCoordinateNearlyEqual(start, LONDON); } const end = circle.interpolate(1); expect(end).toBeDefined(); if (end) { assertCoordinateNearlyEqual(end, PARIS); } }); it('should throw error for invalid fractions', () => { const circle = GreatCircle.from(LONDON).to(PARIS); expect(() => circle.interpolate(-0.1)).toThrow(); expect(() => circle.interpolate(1.1)).toThrow(); }); }); describe('Circle Extension', () => { it('should extend great circle by distance', () => { const original = GreatCircle.from(LONDON).to(PARIS); const extension = Distance.fromKilometers(100); const extended = original.extend(extension); const totalDistance = extended.distance(); // Calculate expected distance const expectedDistance = new Distance(original.distance().inMeters() + extension.inMeters()); assertDistanceNearlyEqual(totalDistance, expectedDistance, 1); }); it('should maintain bearing when extending', () => { const original = GreatCircle.from(LONDON).to(PARIS); const extension = Distance.fromKilometers(100); const extended = original.extend(extension); const endPoint = extended.interpolate(1); expect(endPoint).toBeDefined(); if (!endPoint) { throw new Error('Failed to get end point'); } // New end point should be further from start but in same direction const newDistance = GreatCircle.from(LONDON) .to(endPoint) .distance(); expect(newDistance.inMeters()) .toBeGreaterThan(original.distance().inMeters()); }); }); describe('Edge Cases', () => { it('should handle date line crossing', () => { const point1 = new Coordinate(0, 179); const point2 = new Coordinate(0, -179); const circle = GreatCircle.from(point1).to(point2); // Distance should be small despite longitude difference expect(circle.distance().inKilometers()).toBeLessThan(300); // Interpolated points should form a continuous path const points = circle.generatePoints({ minPoints: 10 }); for (let i = 1; i < points.length; i++) { const segmentDistance = GreatCircle.from(points[i - 1]) .to(points[i]) .distance(); expect(segmentDistance.inKilometers()).toBeLessThan(100); } }); it('should handle points at poles', () => { const northPole = new Coordinate(90, 0); const circle = GreatCircle.from(LONDON).to(northPole); const midpoint = circle.interpolate(0.5); expect(midpoint).toBeDefined(); if (midpoint) { // Midpoint should be between start and pole latitudes expect(midpoint.latitude).toBeGreaterThan(LONDON.latitude); expect(midpoint.latitude).toBeLessThan(90); } }); it('should handle points on same meridian', () => { const point1 = new Coordinate(0, 0); const point2 = new Coordinate(45, 0); const circle = GreatCircle.from(point1).to(point2); const midpoint = circle.interpolate(0.5); expect(midpoint).toBeDefined(); if (midpoint) { expect(midpoint.longitude).toBe(0); expect(midpoint.latitude).toBe(22.5); } }); }); });
|   |       --- GreatCircle.test.ts: import { describe, it, expect } from 'vitest'; import { GreatCircle } from '../../../src/core/models/GreatCircle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertCoordinateNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, EQUATOR_PRIME, TOKYO } from '../../__fixtures__/coordinates.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; describe('GreatCircle', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create great circle using factory method', () => { const circle = GreatCircle.from(LONDON).to(PARIS); expect(circle).toBeDefined(); expect(circle.toString()).toBe(`GreatCircle(${LONDON} → ${PARIS})`); }); it('should allow custom sphere radius', () => { const customRadius = Distance.fromKilometers(2000); const circle = GreatCircle.from(LONDON) .to(PARIS) .withSphere(customRadius); expect(circle).toBeDefined(); }); }); describe('Distance Calculations', () => { it('should calculate correct distance between points', () => { const circle = GreatCircle.from(LONDON).to(PARIS); const distance = circle.distance(); assertDistanceNearlyEqual( distance, Distance.fromKilometers(344), // ~344km from London to Paris 1000 // 1km tolerance ); }); it('should handle zero distance', () => { const circle = GreatCircle.from(LONDON).to(LONDON); const distance = circle.distance(); expect(distance.inMeters()).toBe(0); }); it('should handle antipodal points', () => { const antipode = new Coordinate(-LONDON.latitude, LONDON.longitude + 180); const circle = GreatCircle.from(LONDON).to(antipode); const distance = circle.distance(); expect(distance.inKilometers()).toBeCloseTo(20000, -1); // ~20,000km }); }); describe('Point Generation', () => { it('should generate points with specified spacing', () => { const circle = GreatCircle.from(LONDON).to(TOKYO); const spacing = Distance.fromKilometers(500); const points = circle.generatePoints({ spacing }); // Verify point spacing for (let i = 1; i < points.length; i++) { const segmentDistance = GreatCircle.from(points[i-1]) .to(points[i]) .distance(); expect(segmentDistance.inKilometers()) .toBeLessThanOrEqual(spacing.inKilometers() * 1.1); } }); it('should respect minimum points parameter', () => { const circle = GreatCircle.from(LONDON).to(PARIS); const minPoints = 10; const points = circle.generatePoints({ minPoints }); expect(points.length).toBeGreaterThanOrEqual(minPoints); }); it('should respect maximum points parameter', () => { const circle = GreatCircle.from(LONDON).to(TOKYO); const maxPoints = 50; const points = circle.generatePoints({ maxPoints }); expect(points.length).toBeLessThanOrEqual(maxPoints); }); }); describe('Interpolation', () => { it('should interpolate midpoint', () => { const circle = GreatCircle.from(LONDON).to(PARIS); const midpoint = circle.interpolate(0.5); expect(midpoint).toBeDefined(); if (!midpoint) { throw new Error('Failed to interpolate midpoint'); } // Check midpoint is equidistant from endpoints const distToStart = GreatCircle.from(LONDON) .to(midpoint) .distance(); const distToEnd = GreatCircle.from(midpoint) .to(PARIS) .distance(); assertDistanceNearlyEqual(distToStart, distToEnd, 1); }); it('should handle fraction limits', () => { const circle = GreatCircle.from(LONDON).to(PARIS); const start = circle.interpolate(0); expect(start).toBeDefined(); if (start) { assertCoordinateNearlyEqual(start, LONDON); } const end = circle.interpolate(1); expect(end).toBeDefined(); if (end) { assertCoordinateNearlyEqual(end, PARIS); } }); it('should throw error for invalid fractions', () => { const circle = GreatCircle.from(LONDON).to(PARIS); expect(() => circle.interpolate(-0.1)).toThrow(); expect(() => circle.interpolate(1.1)).toThrow(); }); }); describe('Circle Extension', () => { it('should extend great circle by distance', () => { const original = GreatCircle.from(LONDON).to(PARIS); const extension = Distance.fromKilometers(100); const extended = original.extend(extension); const totalDistance = extended.distance(); // Calculate expected distance const expectedDistance = new Distance( original.distance().inMeters() + extension.inMeters() ); assertDistanceNearlyEqual(totalDistance, expectedDistance, 1); }); it('should maintain bearing when extending', () => { const original = GreatCircle.from(LONDON).to(PARIS); const extension = Distance.fromKilometers(100); const extended = original.extend(extension); const endPoint = extended.interpolate(1); expect(endPoint).toBeDefined(); if (!endPoint) { throw new Error('Failed to get end point'); } // New end point should be further from start but in same direction const newDistance = GreatCircle.from(LONDON) .to(endPoint) .distance(); expect(newDistance.inMeters()) .toBeGreaterThan(original.distance().inMeters()); }); }); describe('Edge Cases', () => { it('should handle date line crossing', () => { const point1 = new Coordinate(0, 179); const point2 = new Coordinate(0, -179); const circle = GreatCircle.from(point1).to(point2); // Distance should be small despite longitude difference expect(circle.distance().inKilometers()).toBeLessThan(300); // Interpolated points should form a continuous path const points = circle.generatePoints({ minPoints: 10 }); for (let i = 1; i < points.length; i++) { const segmentDistance = GreatCircle.from(points[i-1]) .to(points[i]) .distance(); expect(segmentDistance.inKilometers()).toBeLessThan(100); } }); it('should handle points at poles', () => { const northPole = new Coordinate(90, 0); const circle = GreatCircle.from(LONDON).to(northPole); const midpoint = circle.interpolate(0.5); expect(midpoint).toBeDefined(); if (midpoint) { // Midpoint should be between start and pole latitudes expect(midpoint.latitude).toBeGreaterThan(LONDON.latitude); expect(midpoint.latitude).toBeLessThan(90); } }); it('should handle points on same meridian', () => { const point1 = new Coordinate(0, 0); const point2 = new Coordinate(45, 0); const circle = GreatCircle.from(point1).to(point2); const midpoint = circle.interpolate(0.5); expect(midpoint).toBeDefined(); if (midpoint) { expect(midpoint.longitude).toBe(0); expect(midpoint.latitude).toBe(22.5); } }); }); });
|   |       --- Point.test.d.ts: export {};
|   |       --- Point.test.js: // Point test file import { describe, it, expect } from 'vitest'; import { Point } from '../../../src/core/models/Point.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { MATH_CONSTANTS } from '../../__helpers__/constants.js'; describe('Point', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create a 2D point using factory method', () => { const point = Point.at(1, 2); expect(point.X).toBe(1); expect(point.Y).toBe(2); expect(point.Z).toBeUndefined(); }); it('should create a 3D point using factory method', () => { const point = Point.at(1, 2, 3); expect(point.X).toBe(1); expect(point.Y).toBe(2); expect(point.Z).toBe(3); }); }); describe('Accessors', () => { it('should provide read-only access to coordinates', () => { const point = Point.at(1, 2, 3); expect(point.X).toBe(1); expect(point.Y).toBe(2); expect(point.Z).toBe(3); }); }); describe('Equality', () => { it('should correctly compare equal 2D points', () => { const point1 = Point.at(1, 2); const point2 = Point.at(1, 2); expect(point1.equals(point2)).toBe(true); }); it('should correctly compare equal 3D points', () => { const point1 = Point.at(1, 2, 3); const point2 = Point.at(1, 2, 3); expect(point1.equals(point2)).toBe(true); }); it('should correctly compare unequal points', () => { const point1 = Point.at(1, 2); const point2 = Point.at(1, 3); expect(point1.equals(point2)).toBe(false); }); it('should handle Z coordinate in equality comparison', () => { const point1 = Point.at(1, 2, 3); const point2 = Point.at(1, 2); expect(point1.equals(point2)).toBe(false); }); }); describe('String Representation', () => { it('should format 2D point correctly', () => { const point = Point.at(1, 2); expect(point.toString()).toBe('Point(1, 2)'); }); it('should format 3D point correctly', () => { const point = Point.at(1, 2, 3); expect(point.toString()).toBe('Point(1, 2, 3)'); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle zero coordinates', () => { const point = Point.at(0, 0, 0); expect(point.X).toBe(0); expect(point.Y).toBe(0); expect(point.Z).toBe(0); }); it('should handle very large coordinates', () => { const large = 1e10; const point = Point.at(large, large); expect(point.X).toBe(large); expect(point.Y).toBe(large); }); it('should handle very small coordinates', () => { const small = MATH_CONSTANTS.EPSILON; const point = Point.at(small, small); expect(point.X).toBe(small); expect(point.Y).toBe(small); }); }); });
|   |       --- Point.test.ts: // Point test file import { describe, it, expect } from 'vitest'; import { Point } from '../../../src/core/models/Point.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { MATH_CONSTANTS } from '../../__helpers__/constants.js'; describe('Point', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create a 2D point using factory method', () => { const point = Point.at(1, 2); expect(point.X).toBe(1); expect(point.Y).toBe(2); expect(point.Z).toBeUndefined(); }); it('should create a 3D point using factory method', () => { const point = Point.at(1, 2, 3); expect(point.X).toBe(1); expect(point.Y).toBe(2); expect(point.Z).toBe(3); }); }); describe('Accessors', () => { it('should provide read-only access to coordinates', () => { const point = Point.at(1, 2, 3); expect(point.X).toBe(1); expect(point.Y).toBe(2); expect(point.Z).toBe(3); }); }); describe('Equality', () => { it('should correctly compare equal 2D points', () => { const point1 = Point.at(1, 2); const point2 = Point.at(1, 2); expect(point1.equals(point2)).toBe(true); }); it('should correctly compare equal 3D points', () => { const point1 = Point.at(1, 2, 3); const point2 = Point.at(1, 2, 3); expect(point1.equals(point2)).toBe(true); }); it('should correctly compare unequal points', () => { const point1 = Point.at(1, 2); const point2 = Point.at(1, 3); expect(point1.equals(point2)).toBe(false); }); it('should handle Z coordinate in equality comparison', () => { const point1 = Point.at(1, 2, 3); const point2 = Point.at(1, 2); expect(point1.equals(point2)).toBe(false); }); }); describe('String Representation', () => { it('should format 2D point correctly', () => { const point = Point.at(1, 2); expect(point.toString()).toBe('Point(1, 2)'); }); it('should format 3D point correctly', () => { const point = Point.at(1, 2, 3); expect(point.toString()).toBe('Point(1, 2, 3)'); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle zero coordinates', () => { const point = Point.at(0, 0, 0); expect(point.X).toBe(0); expect(point.Y).toBe(0); expect(point.Z).toBe(0); }); it('should handle very large coordinates', () => { const large = 1e10; const point = Point.at(large, large); expect(point.X).toBe(large); expect(point.Y).toBe(large); }); it('should handle very small coordinates', () => { const small = MATH_CONSTANTS.EPSILON; const point = Point.at(small, small); expect(point.X).toBe(small); expect(point.Y).toBe(small); }); }); });
|   |       --- Polygon.test.d.ts: export {};
|   |       --- Polygon.test.js: export {}; // Polygon test file
|   |       --- Polygon.test.ts: // Polygon test file // Replace <TestName> with something appropriate, or leave as-is import { describe, it, expect } from 'vitest'; describe('<TestName> (placeholder)', () => { it('should have tests in the future', () => { expect(true).toBe(true); }); });
|   |       --- SmallCircle.test.d.ts: export {};
|   |       --- SmallCircle.test.js: import { describe, it, expect } from 'vitest'; import { SmallCircle } from '../../../src/core/models/SmallCircle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { Sphere } from '../../../src/core/models/Sphere.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertAreaNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, EQUATOR_PRIME, NORTH_POLE, CIRCLE_CENTER } from '../../__fixtures__/coordinates.js'; import { ONE_KILOMETER, TINY_DISTANCE } from '../../__fixtures__/distances.js'; import { GreatCircle } from '../../../src/core/models/GreatCircle.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; describe('SmallCircle', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create small circle using factory method', () => { const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER); expect(circle).toBeDefined(); }); it('should allow custom sphere radius', () => { const customSphere = new Sphere(); const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER) .withSphere(customSphere); expect(circle).toBeDefined(); }); }); describe('Radius Handling', () => { it('should retrieve radius using getRadius', () => { const radius = ONE_KILOMETER; const circle = SmallCircle.withCenter(CIRCLE_CENTER).radius(radius); assertDistanceNearlyEqual(circle.getRadius(), radius); }); it('should throw error for zero radius', () => { expect(() => { SmallCircle.withCenter(CIRCLE_CENTER) .radius(Distance.fromMeters(0)); }).toThrow(); }); it('should throw error for negative radius', () => { expect(() => { SmallCircle.withCenter(CIRCLE_CENTER) .radius(Distance.fromMeters(-100)); }).toThrow(); }); }); describe('Sphere Customization', () => { it('should use custom sphere radius for calculations', () => { const customRadius = Distance.fromKilometers(2000); const circleRadius = Distance.fromKilometers(100); // Create circle with custom sphere radius const circle = SmallCircle.withCenter(EQUATOR_PRIME) .radius(circleRadius) .withSphere(new Sphere()); // Pass the radius via getRadius // Test with custom radius const sphereRadius = Sphere.getRadius(customRadius); // Create standard circle for comparison const standardCircle = SmallCircle.withCenter(EQUATOR_PRIME) .radius(circleRadius); // Area and circumference should reflect custom sphere radius expect(circle.area()).not.toBe(standardCircle.area()); expect(circle.circumference().inMeters()) .not.toBe(standardCircle.circumference().inMeters()); // Additional verification assertDistanceNearlyEqual(Sphere.getRadius(customRadius), customRadius); }); }); describe('Circumference Calculations', () => { it('should calculate circumference for various radiuses', () => { const testCases = [ { radius: Distance.fromKilometers(1), expected: Distance.fromKilometers(2 * Math.PI) }, { radius: Distance.fromKilometers(10), expected: Distance.fromKilometers(20 * Math.PI) }, { radius: Distance.fromKilometers(100), expected: Distance.fromKilometers(200 * Math.PI) } ]; testCases.forEach(({ radius, expected }) => { const circle = SmallCircle.withCenter(EQUATOR_PRIME) .radius(radius); assertDistanceNearlyEqual(circle.circumference(), expected, radius.inMeters() * 0.01 // 1% tolerance ); }); }); it('should handle tiny circles', () => { const circle = SmallCircle.withCenter(LONDON) .radius(TINY_DISTANCE); expect(circle.circumference().inMeters()) .toBeLessThan(TINY_DISTANCE.inMeters() * 2 * Math.PI * 1.1); }); }); describe('Area Calculations', () => { it('should calculate area for various radiuses', () => { const testCases = [ { radius: Distance.fromKilometers(1), expected: Math.PI // ~3.14 km² }, { radius: Distance.fromKilometers(10), expected: 100 * Math.PI // ~314 km² }, { radius: Distance.fromKilometers(100), expected: 10000 * Math.PI // ~31,416 km² } ]; testCases.forEach(({ radius, expected }) => { const circle = SmallCircle.withCenter(EQUATOR_PRIME) .radius(radius); assertAreaNearlyEqual(circle.area(), expected, expected * 0.01 // 1% tolerance ); }); }); }); describe('Point Generation', () => { it('should generate specified number of points', () => { const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER); const numPoints = 100; const points = circle.generatePoints(numPoints); expect(points.length).toBe(numPoints); // Verify all points are approximately at the specified radius points.forEach(point => { const distance = GreatCircle.from(CIRCLE_CENTER) .to(point) .distance(); assertDistanceNearlyEqual(distance, ONE_KILOMETER, ONE_KILOMETER.inMeters() * 0.01 // 1% tolerance ); }); }); it('should generate evenly spaced points', () => { const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER); const points = circle.generatePoints(4); // Check consecutive points are equally spaced const distances = []; for (let i = 0; i < points.length; i++) { const nextPoint = points[(i + 1) % points.length]; distances.push(GreatCircle.from(points[i]) .to(nextPoint) .distance() .inMeters()); } const avgDistance = distances.reduce((a, b) => a + b) / distances.length; distances.forEach(dist => { expect(Math.abs(dist - avgDistance) / avgDistance) .toBeLessThan(0.01); // 1% tolerance }); }); }); describe('Latitude Effects', () => { it('should maintain consistent properties at different latitudes', () => { const radius = ONE_KILOMETER; const testLatitudes = [-60, -30, 0, 30, 60]; const circles = testLatitudes.map(lat => SmallCircle.withCenter(new Coordinate(lat, 0)).radius(radius)); // Area should be the same regardless of latitude const areas = circles.map(c => c.area()); const avgArea = areas.reduce((a, b) => a + b) / areas.length; areas.forEach(area => { expect(Math.abs(area - avgArea) / avgArea).toBeLessThan(0.01); }); // Generate points and check they maintain radius circles.forEach(circle => { const points = circle.generatePoints(8); points.forEach(point => { const distance = GreatCircle.from(CIRCLE_CENTER) .to(point) .distance(); assertDistanceNearlyEqual(distance, radius); }); }); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle circles at poles', () => { const circle = SmallCircle.withCenter(NORTH_POLE) .radius(ONE_KILOMETER); const points = circle.generatePoints(4); points.forEach(point => { expect(point.latitude).toBeLessThan(90); expect(point.latitude).toBeGreaterThan(89); }); }); it('should handle circles crossing date line', () => { const center = new Coordinate(0, 179.5); const circle = SmallCircle.withCenter(center) .radius(Distance.fromKilometers(100)); const points = circle.generatePoints(100); // Verify some points cross the date line const hasPositive = points.some(p => p.longitude > 0); const hasNegative = points.some(p => p.longitude < 0); expect(hasPositive && hasNegative).toBe(true); }); it('should handle tiny circles', () => { const circle = SmallCircle.withCenter(LONDON) .radius(TINY_DISTANCE); const points = circle.generatePoints(4); points.forEach(point => { const distance = GreatCircle.from(LONDON) .to(point) .distance(); expect(distance.inMeters()) .toBeLessThan(TINY_DISTANCE.inMeters() * 1.1); }); }); }); describe('String Representation', () => { it('should format small circle correctly', () => { const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER); expect(circle.toString()).toBe(`SmallCircle(center: ${CIRCLE_CENTER}, radius: ${ONE_KILOMETER})`); }); }); });
|   |       --- SmallCircle.test.ts: import { describe, it, expect } from 'vitest'; import { SmallCircle } from '../../../src/core/models/SmallCircle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { Sphere } from '../../../src/core/models/Sphere.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertCoordinateNearlyEqual, assertAreaNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, EQUATOR_PRIME, NORTH_POLE, CIRCLE_CENTER, CIRCLE_POINT } from '../../__fixtures__/coordinates.js'; import { EARTH_RADIUS, ONE_KILOMETER, TINY_DISTANCE } from '../../__fixtures__/distances.js'; import { GreatCircle } from '../../../src/core/models/GreatCircle.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; describe('SmallCircle', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create small circle using factory method', () => { const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER); expect(circle).toBeDefined(); }); it('should allow custom sphere radius', () => { const customSphere = new Sphere(); const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER) .withSphere(customSphere); expect(circle).toBeDefined(); }); }); describe('Radius Handling', () => { it('should retrieve radius using getRadius', () => { const radius = ONE_KILOMETER; const circle = SmallCircle.withCenter(CIRCLE_CENTER).radius(radius); assertDistanceNearlyEqual(circle.getRadius(), radius); }); it('should throw error for zero radius', () => { expect(() => { SmallCircle.withCenter(CIRCLE_CENTER) .radius(Distance.fromMeters(0)); }).toThrow(); }); it('should throw error for negative radius', () => { expect(() => { SmallCircle.withCenter(CIRCLE_CENTER) .radius(Distance.fromMeters(-100)); }).toThrow(); }); }); describe('Sphere Customization', () => { it('should use custom sphere radius for calculations', () => { const customRadius = Distance.fromKilometers(2000); const circleRadius = Distance.fromKilometers(100); // Create circle with custom sphere radius const circle = SmallCircle.withCenter(EQUATOR_PRIME) .radius(circleRadius) .withSphere(new Sphere()); // Pass the radius via getRadius // Test with custom radius const sphereRadius = Sphere.getRadius(customRadius); // Create standard circle for comparison const standardCircle = SmallCircle.withCenter(EQUATOR_PRIME) .radius(circleRadius); // Area and circumference should reflect custom sphere radius expect(circle.area()).not.toBe(standardCircle.area()); expect(circle.circumference().inMeters()) .not.toBe(standardCircle.circumference().inMeters()); // Additional verification assertDistanceNearlyEqual( Sphere.getRadius(customRadius), customRadius ); }); }); describe('Circumference Calculations', () => { it('should calculate circumference for various radiuses', () => { const testCases = [ { radius: Distance.fromKilometers(1), expected: Distance.fromKilometers(2 * Math.PI) }, { radius: Distance.fromKilometers(10), expected: Distance.fromKilometers(20 * Math.PI) }, { radius: Distance.fromKilometers(100), expected: Distance.fromKilometers(200 * Math.PI) } ]; testCases.forEach(({ radius, expected }) => { const circle = SmallCircle.withCenter(EQUATOR_PRIME) .radius(radius); assertDistanceNearlyEqual( circle.circumference(), expected, radius.inMeters() * 0.01 // 1% tolerance ); }); }); it('should handle tiny circles', () => { const circle = SmallCircle.withCenter(LONDON) .radius(TINY_DISTANCE); expect(circle.circumference().inMeters()) .toBeLessThan(TINY_DISTANCE.inMeters() * 2 * Math.PI * 1.1); }); }); describe('Area Calculations', () => { it('should calculate area for various radiuses', () => { const testCases = [ { radius: Distance.fromKilometers(1), expected: Math.PI // ~3.14 km² }, { radius: Distance.fromKilometers(10), expected: 100 * Math.PI // ~314 km² }, { radius: Distance.fromKilometers(100), expected: 10000 * Math.PI // ~31,416 km² } ]; testCases.forEach(({ radius, expected }) => { const circle = SmallCircle.withCenter(EQUATOR_PRIME) .radius(radius); assertAreaNearlyEqual( circle.area(), expected, expected * 0.01 // 1% tolerance ); }); }); }); describe('Point Generation', () => { it('should generate specified number of points', () => { const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER); const numPoints = 100; const points = circle.generatePoints(numPoints); expect(points.length).toBe(numPoints); // Verify all points are approximately at the specified radius points.forEach(point => { const distance = GreatCircle.from(CIRCLE_CENTER) .to(point) .distance(); assertDistanceNearlyEqual( distance, ONE_KILOMETER, ONE_KILOMETER.inMeters() * 0.01 // 1% tolerance ); }); }); it('should generate evenly spaced points', () => { const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER); const points = circle.generatePoints(4); // Check consecutive points are equally spaced const distances: number[] = []; for (let i = 0; i < points.length; i++) { const nextPoint = points[(i + 1) % points.length]; distances.push( GreatCircle.from(points[i]) .to(nextPoint) .distance() .inMeters() ); } const avgDistance = distances.reduce((a, b) => a + b) / distances.length; distances.forEach(dist => { expect(Math.abs(dist - avgDistance) / avgDistance) .toBeLessThan(0.01); // 1% tolerance }); }); }); describe('Latitude Effects', () => { it('should maintain consistent properties at different latitudes', () => { const radius = ONE_KILOMETER; const testLatitudes = [-60, -30, 0, 30, 60]; const circles = testLatitudes.map(lat => SmallCircle.withCenter(new Coordinate(lat, 0)).radius(radius) ); // Area should be the same regardless of latitude const areas = circles.map(c => c.area()); const avgArea = areas.reduce((a, b) => a + b) / areas.length; areas.forEach(area => { expect(Math.abs(area - avgArea) / avgArea).toBeLessThan(0.01); }); // Generate points and check they maintain radius circles.forEach(circle => { const points = circle.generatePoints(8); points.forEach(point => { const distance = GreatCircle.from(CIRCLE_CENTER) .to(point) .distance(); assertDistanceNearlyEqual(distance, radius); }); }); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle circles at poles', () => { const circle = SmallCircle.withCenter(NORTH_POLE) .radius(ONE_KILOMETER); const points = circle.generatePoints(4); points.forEach(point => { expect(point.latitude).toBeLessThan(90); expect(point.latitude).toBeGreaterThan(89); }); }); it('should handle circles crossing date line', () => { const center = new Coordinate(0, 179.5); const circle = SmallCircle.withCenter(center) .radius(Distance.fromKilometers(100)); const points = circle.generatePoints(100); // Verify some points cross the date line const hasPositive = points.some(p => p.longitude > 0); const hasNegative = points.some(p => p.longitude < 0); expect(hasPositive && hasNegative).toBe(true); }); it('should handle tiny circles', () => { const circle = SmallCircle.withCenter(LONDON) .radius(TINY_DISTANCE); const points = circle.generatePoints(4); points.forEach(point => { const distance = GreatCircle.from(LONDON) .to(point) .distance(); expect(distance.inMeters()) .toBeLessThan(TINY_DISTANCE.inMeters() * 1.1); }); }); }); describe('String Representation', () => { it('should format small circle correctly', () => { const circle = SmallCircle.withCenter(CIRCLE_CENTER) .radius(ONE_KILOMETER); expect(circle.toString()).toBe( `SmallCircle(center: ${CIRCLE_CENTER}, radius: ${ONE_KILOMETER})` ); }); }); });
|   |       --- Sphere.test.d.ts: export {};
|   |       --- Sphere.test.js: // Sphere test file import { describe, it, expect } from 'vitest'; import { Sphere } from '../../../src/core/models/Sphere.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual } from '../../__helpers__/assertions.js'; import { EARTH_RADIUS, TINY_DISTANCE } from '../../__fixtures__/distances.js'; describe('Sphere', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should use default Earth radius when no radius provided', () => { const radius = Sphere.getRadius(); assertDistanceNearlyEqual(radius, EARTH_RADIUS); }); it('should use custom radius when provided', () => { const customRadius = Distance.fromKilometers(2000); const radius = Sphere.getRadius(customRadius); assertDistanceNearlyEqual(radius, customRadius); }); }); describe('Surface Area Calculations', () => { it('should calculate surface area with default radius', () => { const area = Sphere.surfaceAreaFromRadius(EARTH_RADIUS); const expected = 4 * Math.PI * Math.pow(EARTH_RADIUS.inKilometers(), 2); expect(area).toBeCloseTo(expected); }); it('should calculate surface area with custom radius', () => { const customRadius = Distance.fromKilometers(2000); const area = Sphere.surfaceAreaFromRadius(customRadius); const expected = 4 * Math.PI * Math.pow(customRadius.inKilometers(), 2); expect(area).toBeCloseTo(expected); }); it('should calculate surface area for small radius', () => { const smallRadius = Distance.fromKilometers(1); const area = Sphere.surfaceAreaFromRadius(smallRadius); const expected = 4 * Math.PI; // 4πr² where r=1 expect(area).toBeCloseTo(expected); }); }); describe('Volume Calculations', () => { it('should calculate volume with default radius', () => { const volume = Sphere.volumeFromRadius(EARTH_RADIUS); const expected = (4 / 3) * Math.PI * Math.pow(EARTH_RADIUS.inKilometers(), 3); expect(volume).toBeCloseTo(expected); }); it('should calculate volume with custom radius', () => { const customRadius = Distance.fromKilometers(2000); const volume = Sphere.volumeFromRadius(customRadius); const expected = (4 / 3) * Math.PI * Math.pow(customRadius.inKilometers(), 3); expect(volume).toBeCloseTo(expected); }); it('should calculate volume for small radius', () => { const smallRadius = Distance.fromKilometers(1); const volume = Sphere.volumeFromRadius(smallRadius); const expected = (4 / 3) * Math.PI; // (4/3)πr³ where r=1 expect(volume).toBeCloseTo(expected); }); }); describe('Radius Validation', () => { it('should handle undefined radius by using Earth radius', () => { const radius = Sphere.getRadius(undefined); assertDistanceNearlyEqual(radius, EARTH_RADIUS); }); it('should handle zero radius', () => { const zeroRadius = Distance.fromKilometers(0); const radius = Sphere.getRadius(zeroRadius); expect(radius.inMeters()).toBe(0); }); it('should handle very small radius', () => { const radius = Sphere.getRadius(TINY_DISTANCE); assertDistanceNearlyEqual(radius, TINY_DISTANCE); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle very large radius', () => { const largeRadius = Distance.fromKilometers(1e6); // 1 million km const area = Sphere.surfaceAreaFromRadius(largeRadius); const volume = Sphere.volumeFromRadius(largeRadius); expect(area).toBeGreaterThan(0); expect(volume).toBeGreaterThan(0); expect(Number.isFinite(area)).toBe(true); expect(Number.isFinite(volume)).toBe(true); }); it('should handle very small radius calculations', () => { const tinyRadius = TINY_DISTANCE; const area = Sphere.surfaceAreaFromRadius(tinyRadius); const volume = Sphere.volumeFromRadius(tinyRadius); expect(area).toBeGreaterThan(0); expect(volume).toBeGreaterThan(0); }); it('should maintain precision for small values', () => { const smallRadius = new Distance(0.1); // Changed from fromMeters const area = Sphere.surfaceAreaFromRadius(smallRadius); const volume = Sphere.volumeFromRadius(smallRadius); expect(area).toBeGreaterThan(0); expect(volume).toBeGreaterThan(0); expect(area).toBeLessThan(1); expect(volume).toBeLessThan(1); }); }); describe('Unit Consistency', () => { it('should maintain consistent units in calculations', () => { const radiusInKm = Distance.fromKilometers(1000); const radiusInM = new Distance(1000000); // Changed from fromMeters const areaFromKm = Sphere.surfaceAreaFromRadius(radiusInKm); const areaFromM = Sphere.surfaceAreaFromRadius(radiusInM); expect(areaFromKm).toBeCloseTo(areaFromM); }); }); describe('Mathematical Properties', () => { it('should maintain sphere volume to surface area relationship', () => { const radius = Distance.fromKilometers(1000); const volume = Sphere.volumeFromRadius(radius); const area = Sphere.surfaceAreaFromRadius(radius); // Volume = (r/3) * Surface Area for a sphere const volumeFromArea = (radius.inKilometers() / 3) * area; expect(volume).toBeCloseTo(volumeFromArea); }); it('should follow scaling laws', () => { const radius1 = Distance.fromKilometers(1000); const radius2 = Distance.fromKilometers(2000); const area1 = Sphere.surfaceAreaFromRadius(radius1); const area2 = Sphere.surfaceAreaFromRadius(radius2); // Area should scale with square of radius expect(area2 / area1).toBeCloseTo(4); // (2000/1000)^2 = 4 }); }); });
|   |       --- Sphere.test.ts: // Sphere test file import { describe, it, expect } from 'vitest'; import { Sphere } from '../../../src/core/models/Sphere.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual } from '../../__helpers__/assertions.js'; import { EARTH_RADIUS, ONE_KILOMETER, TINY_DISTANCE } from '../../__fixtures__/distances.js'; describe('Sphere', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should use default Earth radius when no radius provided', () => { const radius = Sphere.getRadius(); assertDistanceNearlyEqual(radius, EARTH_RADIUS); }); it('should use custom radius when provided', () => { const customRadius = Distance.fromKilometers(2000); const radius = Sphere.getRadius(customRadius); assertDistanceNearlyEqual(radius, customRadius); }); }); describe('Surface Area Calculations', () => { it('should calculate surface area with default radius', () => { const area = Sphere.surfaceAreaFromRadius(EARTH_RADIUS); const expected = 4 * Math.PI * Math.pow(EARTH_RADIUS.inKilometers(), 2); expect(area).toBeCloseTo(expected); }); it('should calculate surface area with custom radius', () => { const customRadius = Distance.fromKilometers(2000); const area = Sphere.surfaceAreaFromRadius(customRadius); const expected = 4 * Math.PI * Math.pow(customRadius.inKilometers(), 2); expect(area).toBeCloseTo(expected); }); it('should calculate surface area for small radius', () => { const smallRadius = Distance.fromKilometers(1); const area = Sphere.surfaceAreaFromRadius(smallRadius); const expected = 4 * Math.PI; // 4πr² where r=1 expect(area).toBeCloseTo(expected); }); }); describe('Volume Calculations', () => { it('should calculate volume with default radius', () => { const volume = Sphere.volumeFromRadius(EARTH_RADIUS); const expected = (4/3) * Math.PI * Math.pow(EARTH_RADIUS.inKilometers(), 3); expect(volume).toBeCloseTo(expected); }); it('should calculate volume with custom radius', () => { const customRadius = Distance.fromKilometers(2000); const volume = Sphere.volumeFromRadius(customRadius); const expected = (4/3) * Math.PI * Math.pow(customRadius.inKilometers(), 3); expect(volume).toBeCloseTo(expected); }); it('should calculate volume for small radius', () => { const smallRadius = Distance.fromKilometers(1); const volume = Sphere.volumeFromRadius(smallRadius); const expected = (4/3) * Math.PI; // (4/3)πr³ where r=1 expect(volume).toBeCloseTo(expected); }); }); describe('Radius Validation', () => { it('should handle undefined radius by using Earth radius', () => { const radius = Sphere.getRadius(undefined); assertDistanceNearlyEqual(radius, EARTH_RADIUS); }); it('should handle zero radius', () => { const zeroRadius = Distance.fromKilometers(0); const radius = Sphere.getRadius(zeroRadius); expect(radius.inMeters()).toBe(0); }); it('should handle very small radius', () => { const radius = Sphere.getRadius(TINY_DISTANCE); assertDistanceNearlyEqual(radius, TINY_DISTANCE); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle very large radius', () => { const largeRadius = Distance.fromKilometers(1e6); // 1 million km const area = Sphere.surfaceAreaFromRadius(largeRadius); const volume = Sphere.volumeFromRadius(largeRadius); expect(area).toBeGreaterThan(0); expect(volume).toBeGreaterThan(0); expect(Number.isFinite(area)).toBe(true); expect(Number.isFinite(volume)).toBe(true); }); it('should handle very small radius calculations', () => { const tinyRadius = TINY_DISTANCE; const area = Sphere.surfaceAreaFromRadius(tinyRadius); const volume = Sphere.volumeFromRadius(tinyRadius); expect(area).toBeGreaterThan(0); expect(volume).toBeGreaterThan(0); }); it('should maintain precision for small values', () => { const smallRadius = new Distance(0.1); // Changed from fromMeters const area = Sphere.surfaceAreaFromRadius(smallRadius); const volume = Sphere.volumeFromRadius(smallRadius); expect(area).toBeGreaterThan(0); expect(volume).toBeGreaterThan(0); expect(area).toBeLessThan(1); expect(volume).toBeLessThan(1); }); }); describe('Unit Consistency', () => { it('should maintain consistent units in calculations', () => { const radiusInKm = Distance.fromKilometers(1000); const radiusInM = new Distance(1000000); // Changed from fromMeters const areaFromKm = Sphere.surfaceAreaFromRadius(radiusInKm); const areaFromM = Sphere.surfaceAreaFromRadius(radiusInM); expect(areaFromKm).toBeCloseTo(areaFromM); }); }); describe('Mathematical Properties', () => { it('should maintain sphere volume to surface area relationship', () => { const radius = Distance.fromKilometers(1000); const volume = Sphere.volumeFromRadius(radius); const area = Sphere.surfaceAreaFromRadius(radius); // Volume = (r/3) * Surface Area for a sphere const volumeFromArea = (radius.inKilometers() / 3) * area; expect(volume).toBeCloseTo(volumeFromArea); }); it('should follow scaling laws', () => { const radius1 = Distance.fromKilometers(1000); const radius2 = Distance.fromKilometers(2000); const area1 = Sphere.surfaceAreaFromRadius(radius1); const area2 = Sphere.surfaceAreaFromRadius(radius2); // Area should scale with square of radius expect(area2 / area1).toBeCloseTo(4); // (2000/1000)^2 = 4 }); }); });
|   |       --- SphericalTrigonometry.test.d.ts: export {};
|   |       --- SphericalTrigonometry.test.js: // SphericalTrigonometry test file import { describe, it, expect } from 'vitest'; import { SphericalTrigonometry } from '../../../src/core/models/SphericalTrigonometry.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { Angle } from '../../../src/core/models/Angle.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual } from '../../__helpers__/assertions.js'; import { RIGHT_ANGLE, EQUILATERAL } from '../../__fixtures__/angles.js'; describe('SphericalTrigonometry', () => { describe('Law of Cosines', () => { it('should calculate third side of right triangle', () => { const arcA = Distance.fromKilometers(1000); const arcB = Distance.fromKilometers(1000); const angleC = RIGHT_ANGLE; const arcC = SphericalTrigonometry.lawOfCosines(arcA, arcB, angleC); // For right triangle, c² ≈ a² + b² for small triangles const expectedC = Math.sqrt(Math.pow(arcA.inMeters(), 2) + Math.pow(arcB.inMeters(), 2)); expect(arcC.inMeters()).toBeCloseTo(expectedC, -2); // Less precise for large distances }); it('should calculate side of equilateral triangle', () => { const arcA = Distance.fromKilometers(1000); const arcB = Distance.fromKilometers(1000); const angleC = EQUILATERAL; const arcC = SphericalTrigonometry.lawOfCosines(arcA, arcB, angleC); // For equilateral triangle, all sides should be equal assertDistanceNearlyEqual(arcC, arcA); assertDistanceNearlyEqual(arcC, arcB); }); it('should handle zero angle', () => { const arcA = Distance.fromKilometers(1000); const arcB = Distance.fromKilometers(1000); const angleC = new Angle(0); const arcC = SphericalTrigonometry.lawOfCosines(arcA, arcB, angleC); // For zero angle, c = |a - b| const expected = Math.abs(arcA.inMeters() - arcB.inMeters()); expect(arcC.inMeters()).toBeCloseTo(expected); }); }); describe('Law of Sines', () => { it('should calculate side using known angle and side', () => { const angleA = new Angle(30); const angleB = new Angle(60); const arcC = Distance.fromKilometers(1000); const arcA = SphericalTrigonometry.lawOfSines(angleA, angleB, arcC); // Check using law of sines ratio const sinA = Math.sin(angleA.toRadians()); const sinB = Math.sin(angleB.toRadians()); const ratio = arcA.inMeters() / arcC.inMeters(); expect(ratio).toBeCloseTo(sinA / sinB, 5); }); it('should handle right angle', () => { const angleA = new Angle(30); const angleB = RIGHT_ANGLE; const arcC = Distance.fromKilometers(1000); const arcA = SphericalTrigonometry.lawOfSines(angleA, angleB, arcC); // For right triangle, sin(A) = a/c const sinA = Math.sin(angleA.toRadians()); const ratio = arcA.inMeters() / arcC.inMeters(); expect(ratio).toBeCloseTo(sinA, 5); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle very small angles', () => { const angleA = new Angle(0.0001); const angleB = new Angle(0.0002); const arcC = Distance.fromKilometers(1); const arcA = SphericalTrigonometry.lawOfSines(angleA, angleB, arcC); expect(arcA.inMeters()).toBeGreaterThan(0); }); it('should handle very small distances', () => { const arcA = new Distance(0.1); // Direct meters constructor const arcB = new Distance(0.1); // Direct meters constructor const angleC = new Angle(60); const arcC = SphericalTrigonometry.lawOfCosines(arcA, arcB, angleC); expect(arcC.inMeters()).toBeGreaterThan(0); }); }); describe('Numerical Stability', () => { it('should maintain precision for small values', () => { const arcA = new Distance(1); // Direct meters constructor const arcB = new Distance(1); // Direct meters constructor const angleC = new Angle(1); const arcC = SphericalTrigonometry.lawOfCosines(arcA, arcB, angleC); expect(arcC.inMeters()).toBeGreaterThan(0); expect(arcC.inMeters()).toBeLessThan(3); // Triangle inequality }); it('should handle nearly equal distances', () => { const arcA = Distance.fromKilometers(1000); const arcB = Distance.fromKilometers(1000.000001); const angleC = new Angle(60); const arcC = SphericalTrigonometry.lawOfCosines(arcA, arcB, angleC); expect(arcC.inMeters()).toBeGreaterThan(0); }); }); });
|   |       --- SphericalTrigonometry.test.ts: // SphericalTrigonometry test file import { describe, it, expect } from 'vitest'; import { SphericalTrigonometry } from '../../../src/core/models/SphericalTrigonometry.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { Angle } from '../../../src/core/models/Angle.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertAngleNearlyEqual } from '../../__helpers__/assertions.js'; import { RIGHT_ANGLE, EQUILATERAL } from '../../__fixtures__/angles.js'; describe('SphericalTrigonometry', () => { describe('Law of Cosines', () => { it('should calculate third side of right triangle', () => { const arcA = Distance.fromKilometers(1000); const arcB = Distance.fromKilometers(1000); const angleC = RIGHT_ANGLE; const arcC = SphericalTrigonometry.lawOfCosines( arcA, arcB, angleC ); // For right triangle, c² ≈ a² + b² for small triangles const expectedC = Math.sqrt( Math.pow(arcA.inMeters(), 2) + Math.pow(arcB.inMeters(), 2) ); expect(arcC.inMeters()).toBeCloseTo(expectedC, -2); // Less precise for large distances }); it('should calculate side of equilateral triangle', () => { const arcA = Distance.fromKilometers(1000); const arcB = Distance.fromKilometers(1000); const angleC = EQUILATERAL; const arcC = SphericalTrigonometry.lawOfCosines( arcA, arcB, angleC ); // For equilateral triangle, all sides should be equal assertDistanceNearlyEqual(arcC, arcA); assertDistanceNearlyEqual(arcC, arcB); }); it('should handle zero angle', () => { const arcA = Distance.fromKilometers(1000); const arcB = Distance.fromKilometers(1000); const angleC = new Angle(0); const arcC = SphericalTrigonometry.lawOfCosines( arcA, arcB, angleC ); // For zero angle, c = |a - b| const expected = Math.abs(arcA.inMeters() - arcB.inMeters()); expect(arcC.inMeters()).toBeCloseTo(expected); }); }); describe('Law of Sines', () => { it('should calculate side using known angle and side', () => { const angleA = new Angle(30); const angleB = new Angle(60); const arcC = Distance.fromKilometers(1000); const arcA = SphericalTrigonometry.lawOfSines( angleA, angleB, arcC ); // Check using law of sines ratio const sinA = Math.sin(angleA.toRadians()); const sinB = Math.sin(angleB.toRadians()); const ratio = arcA.inMeters() / arcC.inMeters(); expect(ratio).toBeCloseTo(sinA / sinB, 5); }); it('should handle right angle', () => { const angleA = new Angle(30); const angleB = RIGHT_ANGLE; const arcC = Distance.fromKilometers(1000); const arcA = SphericalTrigonometry.lawOfSines( angleA, angleB, arcC ); // For right triangle, sin(A) = a/c const sinA = Math.sin(angleA.toRadians()); const ratio = arcA.inMeters() / arcC.inMeters(); expect(ratio).toBeCloseTo(sinA, 5); }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle very small angles', () => { const angleA = new Angle(0.0001); const angleB = new Angle(0.0002); const arcC = Distance.fromKilometers(1); const arcA = SphericalTrigonometry.lawOfSines( angleA, angleB, arcC ); expect(arcA.inMeters()).toBeGreaterThan(0); }); it('should handle very small distances', () => { const arcA = new Distance(0.1); // Direct meters constructor const arcB = new Distance(0.1); // Direct meters constructor const angleC = new Angle(60); const arcC = SphericalTrigonometry.lawOfCosines( arcA, arcB, angleC ); expect(arcC.inMeters()).toBeGreaterThan(0); }); }); describe('Numerical Stability', () => { it('should maintain precision for small values', () => { const arcA = new Distance(1); // Direct meters constructor const arcB = new Distance(1); // Direct meters constructor const angleC = new Angle(1); const arcC = SphericalTrigonometry.lawOfCosines( arcA, arcB, angleC ); expect(arcC.inMeters()).toBeGreaterThan(0); expect(arcC.inMeters()).toBeLessThan(3); // Triangle inequality }); it('should handle nearly equal distances', () => { const arcA = Distance.fromKilometers(1000); const arcB = Distance.fromKilometers(1000.000001); const angleC = new Angle(60); const arcC = SphericalTrigonometry.lawOfCosines( arcA, arcB, angleC ); expect(arcC.inMeters()).toBeGreaterThan(0); }); }); });
|   |       --- Triangle.test.d.ts: export {};
|   |       --- Triangle.test.js: // Triangle test file import { describe, it, expect } from 'vitest'; import { Triangle } from '../../../src/core/models/Triangle.js'; import { Angle } from '../../../src/core/models/Angle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertAngleNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, NEW_YORK, TRIANGLE_VERTEX_1, TRIANGLE_VERTEX_2, TRIANGLE_VERTEX_3 } from '../../__fixtures__/coordinates.js'; import { EARTH_RADIUS } from '../../__fixtures__/distances.js'; import { EQUILATERAL, RIGHT_ANGLE } from '../../__fixtures__/angles.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; describe('Triangle', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create triangle using factory method', () => { const triangle = Triangle.from(TRIANGLE_VERTEX_1) .to(TRIANGLE_VERTEX_2) .and(TRIANGLE_VERTEX_3); expect(triangle).toBeDefined(); }); it('should throw error for invalid vertex count', () => { expect(() => { new Triangle([TRIANGLE_VERTEX_1, TRIANGLE_VERTEX_2]); }).toThrow(); }); }); describe('Area Calculations', () => { it('should calculate area of right triangle', () => { // Create a right triangle at equator const v1 = new Coordinate(0, 0); const v2 = new Coordinate(0, 1); const v3 = new Coordinate(1, 0); const triangle = Triangle.from(v1).to(v2).and(v3); // Area should be non-zero and reasonable const area = triangle.area(); expect(area).toBeGreaterThan(0); expect(area).toBeLessThan(12000); // rough maximum possible area }); it('should calculate area of equilateral triangle', () => { // Create an equilateral triangle const center = new Coordinate(0, 0); const radius = Distance.fromKilometers(1000); const angles = [0, 120, 240].map(deg => new Angle(deg)); const vertices = angles.map(angle => { const lat = Math.asin(Math.sin(radius.inMeters() / EARTH_RADIUS.inMeters()) * Math.cos(angle.toRadians())); const lon = Math.atan2(Math.sin(angle.toRadians()) * Math.sin(radius.inMeters() / EARTH_RADIUS.inMeters()) * Math.cos(center.latitude * Math.PI / 180), Math.cos(radius.inMeters() / EARTH_RADIUS.inMeters()) - Math.sin(center.latitude * Math.PI / 180) * Math.sin(lat)); return new Coordinate(lat * 180 / Math.PI, lon * 180 / Math.PI); }); const triangle = Triangle.from(vertices[0]) .to(vertices[1]) .and(vertices[2]); const area = triangle.area(); expect(area).toBeGreaterThan(0); // All angles should be 60 degrees const triangleAngles = triangle.angles(); angles.forEach(angle => { assertAngleNearlyEqual(triangleAngles[0], EQUILATERAL); }); }); }); describe('Perimeter Calculations', () => { it('should calculate perimeter', () => { const triangle = Triangle.from(LONDON) .to(PARIS) .and(NEW_YORK); const perimeter = triangle.perimeter(); const sides = triangle.sides(); // Perimeter should equal sum of sides const sumOfSides = new Distance(sides.reduce((sum, side) => sum + side.inMeters(), 0)); assertDistanceNearlyEqual(perimeter, sumOfSides); }); }); describe('Angle Calculations', () => { it('should calculate angles', () => { const triangle = Triangle.from(LONDON) .to(PARIS) .and(NEW_YORK); const angles = triangle.angles(); expect(angles).toHaveLength(3); // Sum of angles in spherical triangle should be > 180° const sumOfAngles = angles.reduce((sum, angle) => sum + angle.degrees, 0); expect(sumOfAngles).toBeGreaterThan(180); expect(sumOfAngles).toBeLessThan(540); // Maximum possible is 540° }); it('should calculate right angle in right triangle', () => { // Create a right triangle at equator const v1 = new Coordinate(0, 0); const v2 = new Coordinate(0, 1); const v3 = new Coordinate(1, 0); const triangle = Triangle.from(v1).to(v2).and(v3); const angles = triangle.angles(); // One angle should be approximately 90° const hasRightAngle = angles.some(angle => Math.abs(angle.degrees - 90) < 1); expect(hasRightAngle).toBe(true); }); }); describe('Side Calculations', () => { it('should calculate sides', () => { const triangle = Triangle.from(LONDON) .to(PARIS) .and(NEW_YORK); const sides = triangle.sides(); expect(sides).toHaveLength(3); // All sides should be positive sides.forEach(side => { expect(side.inMeters()).toBeGreaterThan(0); }); // Triangle inequality: sum of any two sides > third side for (let i = 0; i < 3; i++) { const sum = sides[(i + 1) % 3].inMeters() + sides[(i + 2) % 3].inMeters(); expect(sum).toBeGreaterThan(sides[i].inMeters()); } }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle degenerate triangles', () => { // Three points on equator 120° apart const vertices = [0, 120, 240].map(lon => new Coordinate(0, lon)); const triangle = Triangle.from(vertices[0]) .to(vertices[1]) .and(vertices[2]); const area = triangle.area(); expect(area).toBeGreaterThan(0); // All angles should be equal const angles = triangle.angles(); const firstAngle = angles[0].degrees; angles.forEach(angle => { expect(Math.abs(angle.degrees - firstAngle)) .toBeLessThan(1); }); }); it('should handle triangles crossing date line', () => { const triangle = Triangle.from(new Coordinate(0, 179)).to(new Coordinate(0, -179)).and(new Coordinate(1, 180)); const area = triangle.area(); expect(area).toBeGreaterThan(0); expect(area).toBeLessThan(1000); // Should be small }); it('should handle triangles including poles', () => { const triangle = Triangle.from(new Coordinate(90, 0) // North pole ).to(new Coordinate(0, 0) // Equator at prime meridian ).and(new Coordinate(0, 90) // Equator at 90°E ); const area = triangle.area(); expect(area).toBeGreaterThan(0); const angles = triangle.angles(); // At pole, angle should be 90° assertAngleNearlyEqual(angles[0], RIGHT_ANGLE); }); }); describe('String Representation', () => { it('should format triangle correctly', () => { const triangle = Triangle.from(TRIANGLE_VERTEX_1) .to(TRIANGLE_VERTEX_2) .and(TRIANGLE_VERTEX_3); expect(triangle.toString()).toBe(`Triangle(${TRIANGLE_VERTEX_1} → ${TRIANGLE_VERTEX_2} → ${TRIANGLE_VERTEX_3})`); }); }); });
|   |       --- Triangle.test.ts: // Triangle test file import { describe, it, expect } from 'vitest'; import { Triangle } from '../../../src/core/models/Triangle.js'; import { Angle } from '../../../src/core/models/Angle.js'; import { Distance } from '../../../src/core/models/Distance.js'; import { TEST_CATEGORIES } from '../../__helpers__/constants.js'; import { assertDistanceNearlyEqual, assertAngleNearlyEqual, assertAreaNearlyEqual } from '../../__helpers__/assertions.js'; import { LONDON, PARIS, NEW_YORK, TRIANGLE_VERTEX_1, TRIANGLE_VERTEX_2, TRIANGLE_VERTEX_3 } from '../../__fixtures__/coordinates.js'; import { EARTH_RADIUS } from '../../__fixtures__/distances.js'; import { EQUILATERAL, RIGHT_ANGLE } from '../../__fixtures__/angles.js'; import { Coordinate } from '../../../src/core/models/Coordinate.js'; describe('Triangle', () => { describe(TEST_CATEGORIES.CONSTRUCTOR, () => { it('should create triangle using factory method', () => { const triangle = Triangle.from(TRIANGLE_VERTEX_1) .to(TRIANGLE_VERTEX_2) .and(TRIANGLE_VERTEX_3); expect(triangle).toBeDefined(); }); it('should throw error for invalid vertex count', () => { expect(() => { new Triangle([TRIANGLE_VERTEX_1, TRIANGLE_VERTEX_2] as any); }).toThrow(); }); }); describe('Area Calculations', () => { it('should calculate area of right triangle', () => { // Create a right triangle at equator const v1 = new Coordinate(0, 0); const v2 = new Coordinate(0, 1); const v3 = new Coordinate(1, 0); const triangle = Triangle.from(v1).to(v2).and(v3); // Area should be non-zero and reasonable const area = triangle.area(); expect(area).toBeGreaterThan(0); expect(area).toBeLessThan(12000); // rough maximum possible area }); it('should calculate area of equilateral triangle', () => { // Create an equilateral triangle const center = new Coordinate(0, 0); const radius = Distance.fromKilometers(1000); const angles = [0, 120, 240].map(deg => new Angle(deg)); const vertices = angles.map(angle => { const lat = Math.asin(Math.sin(radius.inMeters() / EARTH_RADIUS.inMeters()) * Math.cos(angle.toRadians())); const lon = Math.atan2( Math.sin(angle.toRadians()) * Math.sin(radius.inMeters() / EARTH_RADIUS.inMeters()) * Math.cos(center.latitude * Math.PI / 180), Math.cos(radius.inMeters() / EARTH_RADIUS.inMeters()) - Math.sin(center.latitude * Math.PI / 180) * Math.sin(lat) ); return new Coordinate(lat * 180 / Math.PI, lon * 180 / Math.PI); }); const triangle = Triangle.from(vertices[0]) .to(vertices[1]) .and(vertices[2]); const area = triangle.area(); expect(area).toBeGreaterThan(0); // All angles should be 60 degrees const triangleAngles = triangle.angles(); angles.forEach(angle => { assertAngleNearlyEqual(triangleAngles[0], EQUILATERAL); }); }); }); describe('Perimeter Calculations', () => { it('should calculate perimeter', () => { const triangle = Triangle.from(LONDON) .to(PARIS) .and(NEW_YORK); const perimeter = triangle.perimeter(); const sides = triangle.sides(); // Perimeter should equal sum of sides const sumOfSides = new Distance( sides.reduce((sum, side) => sum + side.inMeters(), 0) ); assertDistanceNearlyEqual(perimeter, sumOfSides); }); }); describe('Angle Calculations', () => { it('should calculate angles', () => { const triangle = Triangle.from(LONDON) .to(PARIS) .and(NEW_YORK); const angles = triangle.angles(); expect(angles).toHaveLength(3); // Sum of angles in spherical triangle should be > 180° const sumOfAngles = angles.reduce( (sum, angle) => sum + angle.degrees, 0 ); expect(sumOfAngles).toBeGreaterThan(180); expect(sumOfAngles).toBeLessThan(540); // Maximum possible is 540° }); it('should calculate right angle in right triangle', () => { // Create a right triangle at equator const v1 = new Coordinate(0, 0); const v2 = new Coordinate(0, 1); const v3 = new Coordinate(1, 0); const triangle = Triangle.from(v1).to(v2).and(v3); const angles = triangle.angles(); // One angle should be approximately 90° const hasRightAngle = angles.some( angle => Math.abs(angle.degrees - 90) < 1 ); expect(hasRightAngle).toBe(true); }); }); describe('Side Calculations', () => { it('should calculate sides', () => { const triangle = Triangle.from(LONDON) .to(PARIS) .and(NEW_YORK); const sides = triangle.sides(); expect(sides).toHaveLength(3); // All sides should be positive sides.forEach(side => { expect(side.inMeters()).toBeGreaterThan(0); }); // Triangle inequality: sum of any two sides > third side for (let i = 0; i < 3; i++) { const sum = sides[(i + 1) % 3].inMeters() + sides[(i + 2) % 3].inMeters(); expect(sum).toBeGreaterThan(sides[i].inMeters()); } }); }); describe(TEST_CATEGORIES.EDGE_CASES, () => { it('should handle degenerate triangles', () => { // Three points on equator 120° apart const vertices = [0, 120, 240].map(lon => new Coordinate(0, lon) ); const triangle = Triangle.from(vertices[0]) .to(vertices[1]) .and(vertices[2]); const area = triangle.area(); expect(area).toBeGreaterThan(0); // All angles should be equal const angles = triangle.angles(); const firstAngle = angles[0].degrees; angles.forEach(angle => { expect(Math.abs(angle.degrees - firstAngle)) .toBeLessThan(1); }); }); it('should handle triangles crossing date line', () => { const triangle = Triangle.from( new Coordinate(0, 179) ).to( new Coordinate(0, -179) ).and( new Coordinate(1, 180) ); const area = triangle.area(); expect(area).toBeGreaterThan(0); expect(area).toBeLessThan(1000); // Should be small }); it('should handle triangles including poles', () => { const triangle = Triangle.from( new Coordinate(90, 0) // North pole ).to( new Coordinate(0, 0) // Equator at prime meridian ).and( new Coordinate(0, 90) // Equator at 90°E ); const area = triangle.area(); expect(area).toBeGreaterThan(0); const angles = triangle.angles(); // At pole, angle should be 90° assertAngleNearlyEqual(angles[0], RIGHT_ANGLE); }); }); describe('String Representation', () => { it('should format triangle correctly', () => { const triangle = Triangle.from(TRIANGLE_VERTEX_1) .to(TRIANGLE_VERTEX_2) .and(TRIANGLE_VERTEX_3); expect(triangle.toString()).toBe( `Triangle(${TRIANGLE_VERTEX_1} → ${TRIANGLE_VERTEX_2} → ${TRIANGLE_VERTEX_3})` ); }); }); });
|   \-- integration
|       --- geojson-conversion.test.d.ts: export {};
|       --- geojson-conversion.test.js: import { describe, it, expect } from 'vitest'; import { TypeConverter } from '../../src/adapters/geojson/TypeConverter.js'; import { Coordinate } from '../../src/core/models/Coordinate.js'; import { GreatCircle } from '../../src/core/models/GreatCircle.js'; import { SmallCircle } from '../../src/core/models/SmallCircle.js'; import { Triangle } from '../../src/core/models/Triangle.js'; import { Distance } from '../../src/core/models/Distance.js'; import { LONDON, PARIS, NEW_YORK, TOKYO } from '../__fixtures__/coordinates.js'; describe('GeoJSON Integration', () => { describe('Route Planning Data Exchange', () => { it('should convert complex route to GeoJSON and back', () => { // Create a multi-leg route const waypoints = [LONDON, PARIS, NEW_YORK, TOKYO]; const routes = []; // Generate route segments for (let i = 0; i < waypoints.length - 1; i++) { const route = GreatCircle.from(waypoints[i]).to(waypoints[i + 1]); routes.push(route); } // Convert to GeoJSON const features = routes.map(route => TypeConverter.toFeature(route)); // Convert back to routes const reconvertedRoutes = features.map(feature => TypeConverter.fromFeature(feature)); expect(reconvertedRoutes.length).toBe(routes.length); reconvertedRoutes.forEach(route => { expect(route).toBeInstanceOf(GreatCircle); }); }); it('should preserve route properties in conversion', () => { // Create route with specific properties const route = GreatCircle.from(LONDON).to(TOKYO); const distance = route.distance(); // Convert to GeoJSON const feature = TypeConverter.toFeature(route); // Verify properties are preserved expect(feature.properties.distance).toBeDefined(); expect(feature.properties.distance).toBeCloseTo(distance.inMeters(), -2); // Convert back and verify const reconverted = TypeConverter.fromFeature(feature); expect(reconverted.distance().inMeters()).toBeCloseTo(distance.inMeters(), -2); }); }); describe('Area Coverage Export/Import', () => { it('should convert search patterns to GeoJSON and back', () => { // Create search pattern with circles and triangles const center = new Coordinate(40.7128, -74.006); const searchCircle = SmallCircle.withCenter(center) .radius(Distance.fromKilometers(10)); const points = searchCircle.generatePoints(3); const searchTriangle = Triangle.from(points[0]) .to(points[1]) .and(points[2]); // Convert both to GeoJSON const circleFeature = TypeConverter.toFeature(searchCircle); const triangleFeature = TypeConverter.toFeature(searchTriangle); // Convert back const reconvertedCircle = TypeConverter.fromFeature(circleFeature); const reconvertedTriangle = TypeConverter.fromFeature(triangleFeature); expect(reconvertedCircle).toBeInstanceOf(SmallCircle); expect(reconvertedTriangle).toBeInstanceOf(Triangle); }); it('should handle collection of search areas', () => { // Create multiple search areas const areas = []; const baseCenter = new Coordinate(40.7128, -74.006); // Generate 3 overlapping search circles for (let i = 0; i < 3; i++) { const center = new Coordinate(baseCenter.latitude + (i * 0.01), baseCenter.longitude + (i * 0.01)); areas.push(SmallCircle.withCenter(center) .radius(Distance.fromKilometers(5))); } // Convert all to GeoJSON const features = areas.map(area => TypeConverter.toFeature(area)); // Convert back const reconverted = features.map(feature => TypeConverter.fromFeature(feature)); expect(reconverted.length).toBe(areas.length); reconverted.forEach(area => { expect(area).toBeInstanceOf(SmallCircle); }); }); }); describe('Data Validation and Error Handling', () => { it('should handle invalid GeoJSON input', () => { const invalidFeatures = [ { type: 'Feature', geometry: null, properties: {} }, { type: 'Feature', geometry: { type: 'Unknown' }, properties: {} }, { type: 'Feature', geometry: { type: 'Point', coordinates: null }, properties: {} } ]; invalidFeatures.forEach(feature => { expect(() => TypeConverter.fromFeature(feature)).toThrow(); }); }); it('should validate coordinate ranges', () => { const invalidCoordinates = [ { type: 'Point', coordinates: [181, 0] }, { type: 'Point', coordinates: [0, 91] }, { type: 'Point', coordinates: [-181, -91] } ]; invalidCoordinates.forEach(geometry => { expect(() => TypeConverter.fromFeature({ type: 'Feature', geometry, properties: {} })).toThrow(); }); }); }); describe('Complex Data Structures', () => { it('should handle nested geometry collections', () => { // Create a complex search and rescue pattern const center = new Coordinate(40.7128, -74.006); const searchArea = SmallCircle.withCenter(center) .radius(Distance.fromKilometers(10)); // Generate search pattern const perimeterPoints = searchArea.generatePoints(8); const searchPatterns = []; // Create spokes from center to perimeter perimeterPoints.forEach(point => { searchPatterns.push(GreatCircle.from(center).to(point)); }); // Create perimeter segments perimeterPoints.forEach((point, i) => { const nextPoint = perimeterPoints[(i + 1) % perimeterPoints.length]; searchPatterns.push(GreatCircle.from(point).to(nextPoint)); }); const features = searchPatterns.map(pattern => TypeConverter.toFeature(pattern)); // Convert back const reconverted = features.map(feature => TypeConverter.fromFeature(feature)); expect(reconverted.length).toBe(searchPatterns.length); reconverted.forEach(pattern => { expect(pattern).toBeDefined(); }); }); it('should preserve complex properties during conversion', () => { const route = GreatCircle.from(LONDON).to(TOKYO); const originalFeature = TypeConverter.toFeature(route); // Add complex properties originalFeature.properties = { distance: route.distance().inMeters(), waypoints: [ { name: 'London', coordinates: [LONDON.longitude, LONDON.latitude] }, { name: 'Tokyo', coordinates: [TOKYO.longitude, TOKYO.latitude] } ], metadata: { created: new Date().toISOString(), type: 'flight-route', settings: { altitude: 35000, speed: 500 } } }; // Convert back const reconvertedRoute = TypeConverter.fromFeature(originalFeature); const reconvertedFeature = TypeConverter.toFeature(reconvertedRoute); // Verify complex properties are preserved expect(reconvertedFeature.properties.waypoints).toBeDefined(); expect(reconvertedFeature.properties.metadata).toBeDefined(); expect(reconvertedFeature.properties.metadata.settings).toBeDefined(); }); }); describe('Batch Processing', () => { it('should handle bulk conversions', () => { // Create a mix of geometric objects const geometries = [ LONDON, GreatCircle.from(LONDON).to(PARIS), SmallCircle.withCenter(LONDON).radius(Distance.fromKilometers(10)), Triangle.from(LONDON).to(PARIS).and(NEW_YORK) // Triangle ]; // Batch convert to GeoJSON const features = geometries.map(geo => TypeConverter.toFeature(geo)); // Batch convert back const reconverted = features.map(feature => TypeConverter.fromFeature(feature)); expect(reconverted.length).toBe(geometries.length); expect(reconverted[0]).toBeInstanceOf(Coordinate); expect(reconverted[1]).toBeInstanceOf(GreatCircle); expect(reconverted[2]).toBeInstanceOf(SmallCircle); expect(reconverted[3]).toBeInstanceOf(Triangle); }); it('should handle collection conversion', () => { // Create a collection of similar objects const routes = [ GreatCircle.from(LONDON).to(PARIS), GreatCircle.from(PARIS).to(NEW_YORK), GreatCircle.from(NEW_YORK).to(TOKYO) ]; // Convert collection to GeoJSON const collection = { type: 'FeatureCollection', features: routes.map(route => TypeConverter.toFeature(route)) }; // Convert each feature back const reconvertedRoutes = collection.features.map(feature => TypeConverter.fromFeature(feature)); expect(reconvertedRoutes.length).toBe(routes.length); reconvertedRoutes.forEach(route => { expect(route).toBeInstanceOf(GreatCircle); }); }); }); });
|       --- geojson-conversion.test.ts: import { describe, it, expect } from 'vitest'; import { TypeConverter } from '../../src/adapters/geojson/TypeConverter.js'; import { Coordinate } from '../../src/core/models/Coordinate.js'; import { GreatCircle } from '../../src/core/models/GreatCircle.js'; import { SmallCircle } from '../../src/core/models/SmallCircle.js'; import { Triangle } from '../../src/core/models/Triangle.js'; import { Distance } from '../../src/core/models/Distance.js'; import { LONDON, PARIS, NEW_YORK, TOKYO } from '../__fixtures__/coordinates.js'; describe('GeoJSON Integration', () => { describe('Route Planning Data Exchange', () => { it('should convert complex route to GeoJSON and back', () => { // Create a multi-leg route const waypoints = [LONDON, PARIS, NEW_YORK, TOKYO]; const routes: GreatCircle[] = []; // Generate route segments for (let i = 0; i < waypoints.length - 1; i++) { const route = GreatCircle.from(waypoints[i]).to(waypoints[i + 1]); routes.push(route); } // Convert to GeoJSON const features = routes.map(route => TypeConverter.toFeature(route)); // Convert back to routes const reconvertedRoutes = features.map(feature => TypeConverter.fromFeature(feature) ); expect(reconvertedRoutes.length).toBe(routes.length); reconvertedRoutes.forEach(route => { expect(route).toBeInstanceOf(GreatCircle); }); }); it('should preserve route properties in conversion', () => { // Create route with specific properties const route = GreatCircle.from(LONDON).to(TOKYO); const distance = route.distance(); // Convert to GeoJSON const feature = TypeConverter.toFeature(route); // Verify properties are preserved expect(feature.properties.distance).toBeDefined(); expect(feature.properties.distance).toBeCloseTo( distance.inMeters(), -2 ); // Convert back and verify const reconverted = TypeConverter.fromFeature(feature) as GreatCircle; expect(reconverted.distance().inMeters()).toBeCloseTo( distance.inMeters(), -2 ); }); }); describe('Area Coverage Export/Import', () => { it('should convert search patterns to GeoJSON and back', () => { // Create search pattern with circles and triangles const center = new Coordinate(40.7128, -74.006); const searchCircle = SmallCircle.withCenter(center) .radius(Distance.fromKilometers(10)); const points = searchCircle.generatePoints(3); const searchTriangle = Triangle.from(points[0]) .to(points[1]) .and(points[2]); // Convert both to GeoJSON const circleFeature = TypeConverter.toFeature(searchCircle); const triangleFeature = TypeConverter.toFeature(searchTriangle); // Convert back const reconvertedCircle = TypeConverter.fromFeature(circleFeature); const reconvertedTriangle = TypeConverter.fromFeature(triangleFeature); expect(reconvertedCircle).toBeInstanceOf(SmallCircle); expect(reconvertedTriangle).toBeInstanceOf(Triangle); }); it('should handle collection of search areas', () => { // Create multiple search areas const areas: SmallCircle[] = []; // <-- Type added here const baseCenter = new Coordinate(40.7128, -74.006); // Generate 3 overlapping search circles for (let i = 0; i < 3; i++) { const center = new Coordinate( baseCenter.latitude + (i * 0.01), baseCenter.longitude + (i * 0.01) ); areas.push( SmallCircle.withCenter(center) .radius(Distance.fromKilometers(5)) ); } // Convert all to GeoJSON const features = areas.map(area => TypeConverter.toFeature(area)); // Convert back const reconverted = features.map(feature => TypeConverter.fromFeature(feature) ); expect(reconverted.length).toBe(areas.length); reconverted.forEach(area => { expect(area).toBeInstanceOf(SmallCircle); }); }); }); describe('Data Validation and Error Handling', () => { it('should handle invalid GeoJSON input', () => { const invalidFeatures = [ { type: 'Feature', geometry: null, properties: {} }, { type: 'Feature', geometry: { type: 'Unknown' }, properties: {} }, { type: 'Feature', geometry: { type: 'Point', coordinates: null }, properties: {} } ]; invalidFeatures.forEach(feature => { expect(() => TypeConverter.fromFeature(feature as any)).toThrow(); }); }); it('should validate coordinate ranges', () => { const invalidCoordinates = [ { type: 'Point', coordinates: [181, 0] }, { type: 'Point', coordinates: [0, 91] }, { type: 'Point', coordinates: [-181, -91] } ]; invalidCoordinates.forEach(geometry => { expect(() => TypeConverter.fromFeature({ type: 'Feature', geometry, properties: {} } as any)).toThrow(); }); }); }); describe('Complex Data Structures', () => { it('should handle nested geometry collections', () => { // Create a complex search and rescue pattern const center = new Coordinate(40.7128, -74.006); const searchArea = SmallCircle.withCenter(center) .radius(Distance.fromKilometers(10)); // Generate search pattern const perimeterPoints = searchArea.generatePoints(8); const searchPatterns: GreatCircle[] = []; // Create spokes from center to perimeter perimeterPoints.forEach(point => { searchPatterns.push(GreatCircle.from(center).to(point)); }); // Create perimeter segments perimeterPoints.forEach((point, i) => { const nextPoint = perimeterPoints[(i + 1) % perimeterPoints.length]; searchPatterns.push(GreatCircle.from(point).to(nextPoint)); }); const features = searchPatterns.map(pattern => TypeConverter.toFeature(pattern) ); // Convert back const reconverted = features.map(feature => TypeConverter.fromFeature(feature) ); expect(reconverted.length).toBe(searchPatterns.length); reconverted.forEach(pattern => { expect(pattern).toBeDefined(); }); }); it('should preserve complex properties during conversion', () => { const route = GreatCircle.from(LONDON).to(TOKYO); const originalFeature = TypeConverter.toFeature(route); // Add complex properties originalFeature.properties = { distance: route.distance().inMeters(), waypoints: [ { name: 'London', coordinates: [LONDON.longitude, LONDON.latitude] }, { name: 'Tokyo', coordinates: [TOKYO.longitude, TOKYO.latitude] } ], metadata: { created: new Date().toISOString(), type: 'flight-route', settings: { altitude: 35000, speed: 500 } } }; // Convert back const reconvertedRoute = TypeConverter.fromFeature(originalFeature); const reconvertedFeature = TypeConverter.toFeature(reconvertedRoute); // Verify complex properties are preserved expect(reconvertedFeature.properties.waypoints).toBeDefined(); expect(reconvertedFeature.properties.metadata).toBeDefined(); expect(reconvertedFeature.properties.metadata.settings).toBeDefined(); }); }); describe('Batch Processing', () => { it('should handle bulk conversions', () => { // Create a mix of geometric objects const geometries = [ LONDON, // Coordinate GreatCircle.from(LONDON).to(PARIS), // GreatCircle SmallCircle.withCenter(LONDON).radius(Distance.fromKilometers(10)), // SmallCircle Triangle.from(LONDON).to(PARIS).and(NEW_YORK) // Triangle ]; // Batch convert to GeoJSON const features = geometries.map(geo => TypeConverter.toFeature(geo)); // Batch convert back const reconverted = features.map(feature => TypeConverter.fromFeature(feature) ); expect(reconverted.length).toBe(geometries.length); expect(reconverted[0]).toBeInstanceOf(Coordinate); expect(reconverted[1]).toBeInstanceOf(GreatCircle); expect(reconverted[2]).toBeInstanceOf(SmallCircle); expect(reconverted[3]).toBeInstanceOf(Triangle); }); it('should handle collection conversion', () => { // Create a collection of similar objects const routes = [ GreatCircle.from(LONDON).to(PARIS), GreatCircle.from(PARIS).to(NEW_YORK), GreatCircle.from(NEW_YORK).to(TOKYO) ]; // Convert collection to GeoJSON const collection = { type: 'FeatureCollection', features: routes.map(route => TypeConverter.toFeature(route)) }; // Convert each feature back const reconvertedRoutes = collection.features.map(feature => TypeConverter.fromFeature(feature) ); expect(reconvertedRoutes.length).toBe(routes.length); reconvertedRoutes.forEach(route => { expect(route).toBeInstanceOf(GreatCircle); }); }); }); });
|       --- geometric-calculations.test.d.ts: export {};
|       --- geometric-calculations.test.js: import { describe, it, expect } from 'vitest'; import { Coordinate } from '../../src/core/models/Coordinate.js'; import { GreatCircle } from '../../src/core/models/GreatCircle.js'; import { SmallCircle } from '../../src/core/models/SmallCircle.js'; import { Triangle } from '../../src/core/models/Triangle.js'; import { Distance } from '../../src/core/models/Distance.js'; import { Azimuth } from '../../src/core/models/Azimuth.js'; import { Bearing } from '../../src/core/models/Bearing.js'; import { LONDON, NEW_YORK, TOKYO } from '../__fixtures__/coordinates.js'; describe('Geometric Calculations Integration', () => { describe('Flight Route Planning', () => { it('should calculate great circle route with waypoints', () => { // Flight from London to Tokyo with waypoint at Dubai const dubai = new Coordinate(25.2532, 55.3657); // Calculate route segments const leg1 = GreatCircle.from(LONDON).to(dubai); const leg2 = GreatCircle.from(dubai).to(TOKYO); // Generate waypoints along route const waypoints1 = leg1.generatePoints({ spacing: Distance.fromKilometers(500) }); const waypoints2 = leg2.generatePoints({ spacing: Distance.fromKilometers(500) }); // Calculate total distance const totalDistance = new Distance(leg1.distance().inMeters() + leg2.distance().inMeters()); // Verify reasonable results expect(waypoints1.length).toBeGreaterThan(5); expect(waypoints2.length).toBeGreaterThan(5); expect(totalDistance.inKilometers()).toBeGreaterThan(5000); }); it('should handle flight path restrictions', () => { // Simulate restricted airspace as a small circle const restrictedZone = SmallCircle.withCenter(new Coordinate(50.0, 40.0)).radius(Distance.fromKilometers(500)); // Calculate route points const route = GreatCircle.from(LONDON).to(TOKYO); const waypoints = route.generatePoints({ spacing: Distance.fromKilometers(100) }); // Check if any waypoint intersects with restricted zone const intersections = waypoints.filter(point => { const distanceToCenter = GreatCircle.from(restrictedZone.getCenter()) .to(point) .distance(); return distanceToCenter.inMeters() <= restrictedZone.getRadius().inMeters(); }); // Store intersection points for potential rerouting expect(intersections.length).toBeDefined(); }); }); describe('Maritime Navigation', () => { it('should calculate shipping route with heading changes', () => { // New York to Rotterdam shipping route const rotterdam = new Coordinate(51.9225, 4.4792); const route = GreatCircle.from(NEW_YORK).to(rotterdam); // Calculate initial and final bearings const initialBearing = Bearing.from(NEW_YORK).to(rotterdam).initial(); const finalBearing = Bearing.from(NEW_YORK).to(rotterdam).final(); // Generate navigation points every 100km const navPoints = route.generatePoints({ spacing: Distance.fromKilometers(100) }); // Calculate heading at each point const headings = navPoints.map((point, i) => { if (i === navPoints.length - 1) return finalBearing; return Azimuth.from(point).to(navPoints[i + 1]).forward(); }); // Verify reasonable results expect(navPoints.length).toBeGreaterThan(10); expect(headings.length).toBe(navPoints.length); expect(Math.abs(headings[0].degrees - initialBearing.degrees)) .toBeLessThan(1); }); it('should handle emergency diversion scenarios', () => { // Original route: NY to Rotterdam const rotterdam = new Coordinate(51.9225, 4.4792); const originalRoute = GreatCircle.from(NEW_YORK).to(rotterdam); // Emergency port: Halifax const halifax = new Coordinate(44.6488, -63.5752); // Calculate diversion const diversionRoute = GreatCircle.from(originalRoute.interpolate(0.3)).to(halifax); // Calculate new total distance const distanceToEmergency = diversionRoute.distance(); // Verify reasonable results expect(distanceToEmergency.inKilometers()).toBeGreaterThan(0); expect(distanceToEmergency.inKilometers()).toBeLessThan(originalRoute.distance().inKilometers()); }); }); describe('Area Coverage Analysis', () => { it('should calculate search and rescue coverage area', () => { // Last known position const lastKnown = new Coordinate(40.7128, -74.006); // Create search patterns: expanding squares const searchRadius = Distance.fromKilometers(10); const searchCircle = SmallCircle.withCenter(lastKnown) .radius(searchRadius); // Generate perimeter points const perimeterPoints = searchCircle.generatePoints(16); // Create search triangles for area coverage const triangles = perimeterPoints.map((point, i) => { const nextPoint = perimeterPoints[(i + 1) % perimeterPoints.length]; return Triangle.from(lastKnown).to(point).and(nextPoint); }); // Calculate total search area const totalArea = triangles.reduce((sum, triangle) => sum + triangle.area(), 0); // Verify coverage expect(totalArea).toBeGreaterThan(0); expect(triangles.length).toBe(16); }); it('should handle overlapping coverage areas', () => { // Two search areas with overlap const center1 = new Coordinate(40.7128, -74.006); const center2 = new Coordinate(40.7128, -73.95); const radius = Distance.fromKilometers(5); const area1 = SmallCircle.withCenter(center1).radius(radius); const area2 = SmallCircle.withCenter(center2).radius(radius); // Calculate distance between centers const centerDistance = GreatCircle.from(center1) .to(center2) .distance(); // Check for overlap const hasOverlap = centerDistance.inMeters() < (area1.getRadius().inMeters() + area2.getRadius().inMeters()); expect(hasOverlap).toBeDefined(); expect(area1.area() + area2.area()).toBeGreaterThan(0); }); }); describe('Survey Route Planning', () => { it('should generate parallel survey lines', () => { // Survey area corners const sw = new Coordinate(40.7, -74.1); const se = new Coordinate(40.7, -73.9); const ne = new Coordinate(40.8, -73.9); const nw = new Coordinate(40.8, -74.1); // Create boundary const boundary = [sw, se, ne, nw]; // Generate parallel lines const lineSpacing = Distance.fromKilometers(0.5); const lines = []; for (let i = 0; i < 5; i++) { const start = GreatCircle.from(sw).to(se) .interpolate(i / 4); const end = GreatCircle.from(nw).to(ne) .interpolate(i / 4); lines.push(GreatCircle.from(start).to(end)); } // Calculate total survey distance const totalDistance = lines.reduce((sum, line) => sum + line.distance().inMeters(), 0); expect(lines.length).toBe(5); expect(totalDistance).toBeGreaterThan(0); }); }); });
|       --- geometric-calculations.test.ts: import { describe, it, expect } from 'vitest'; import { Coordinate } from '../../src/core/models/Coordinate.js'; import { GreatCircle } from '../../src/core/models/GreatCircle.js'; import { SmallCircle } from '../../src/core/models/SmallCircle.js'; import { Triangle } from '../../src/core/models/Triangle.js'; import { Distance } from '../../src/core/models/Distance.js'; import { Azimuth } from '../../src/core/models/Azimuth.js'; import { Bearing } from '../../src/core/models/Bearing.js'; import { LONDON, PARIS, NEW_YORK, TOKYO } from '../__fixtures__/coordinates.js'; describe('Geometric Calculations Integration', () => { describe('Flight Route Planning', () => { it('should calculate great circle route with waypoints', () => { // Flight from London to Tokyo with waypoint at Dubai const dubai = new Coordinate(25.2532, 55.3657); // Calculate route segments const leg1 = GreatCircle.from(LONDON).to(dubai); const leg2 = GreatCircle.from(dubai).to(TOKYO); // Generate waypoints along route const waypoints1 = leg1.generatePoints({ spacing: Distance.fromKilometers(500) }); const waypoints2 = leg2.generatePoints({ spacing: Distance.fromKilometers(500) }); // Calculate total distance const totalDistance = new Distance( leg1.distance().inMeters() + leg2.distance().inMeters() ); // Verify reasonable results expect(waypoints1.length).toBeGreaterThan(5); expect(waypoints2.length).toBeGreaterThan(5); expect(totalDistance.inKilometers()).toBeGreaterThan(5000); }); it('should handle flight path restrictions', () => { // Simulate restricted airspace as a small circle const restrictedZone = SmallCircle.withCenter( new Coordinate(50.0, 40.0) ).radius(Distance.fromKilometers(500)); // Calculate route points const route = GreatCircle.from(LONDON).to(TOKYO); const waypoints = route.generatePoints({ spacing: Distance.fromKilometers(100) }); // Check if any waypoint intersects with restricted zone const intersections = waypoints.filter(point => { const distanceToCenter = GreatCircle.from(restrictedZone.getCenter()) .to(point) .distance(); return distanceToCenter.inMeters() <= restrictedZone.getRadius().inMeters(); }); // Store intersection points for potential rerouting expect(intersections.length).toBeDefined(); }); }); describe('Maritime Navigation', () => { it('should calculate shipping route with heading changes', () => { // New York to Rotterdam shipping route const rotterdam = new Coordinate(51.9225, 4.4792); const route = GreatCircle.from(NEW_YORK).to(rotterdam); // Calculate initial and final bearings const initialBearing = Bearing.from(NEW_YORK).to(rotterdam).initial(); const finalBearing = Bearing.from(NEW_YORK).to(rotterdam).final(); // Generate navigation points every 100km const navPoints = route.generatePoints({ spacing: Distance.fromKilometers(100) }); // Calculate heading at each point const headings = navPoints.map((point, i) => { if (i === navPoints.length - 1) return finalBearing; return Azimuth.from(point).to(navPoints[i + 1]).forward(); }); // Verify reasonable results expect(navPoints.length).toBeGreaterThan(10); expect(headings.length).toBe(navPoints.length); expect(Math.abs(headings[0].degrees - initialBearing.degrees)) .toBeLessThan(1); }); it('should handle emergency diversion scenarios', () => { // Original route: NY to Rotterdam const rotterdam = new Coordinate(51.9225, 4.4792); const originalRoute = GreatCircle.from(NEW_YORK).to(rotterdam); // Emergency port: Halifax const halifax = new Coordinate(44.6488, -63.5752); // Calculate diversion const diversionRoute = GreatCircle.from( originalRoute.interpolate(0.3) as Coordinate ).to(halifax); // Calculate new total distance const distanceToEmergency = diversionRoute.distance(); // Verify reasonable results expect(distanceToEmergency.inKilometers()).toBeGreaterThan(0); expect(distanceToEmergency.inKilometers()).toBeLessThan( originalRoute.distance().inKilometers() ); }); }); describe('Area Coverage Analysis', () => { it('should calculate search and rescue coverage area', () => { // Last known position const lastKnown = new Coordinate(40.7128, -74.006); // Create search patterns: expanding squares const searchRadius = Distance.fromKilometers(10); const searchCircle = SmallCircle.withCenter(lastKnown) .radius(searchRadius); // Generate perimeter points const perimeterPoints = searchCircle.generatePoints(16); // Create search triangles for area coverage const triangles = perimeterPoints.map((point, i) => { const nextPoint = perimeterPoints[(i + 1) % perimeterPoints.length]; return Triangle.from(lastKnown).to(point).and(nextPoint); }); // Calculate total search area const totalArea = triangles.reduce( (sum, triangle) => sum + triangle.area(), 0 ); // Verify coverage expect(totalArea).toBeGreaterThan(0); expect(triangles.length).toBe(16); }); it('should handle overlapping coverage areas', () => { // Two search areas with overlap const center1 = new Coordinate(40.7128, -74.006); const center2 = new Coordinate(40.7128, -73.95); const radius = Distance.fromKilometers(5); const area1 = SmallCircle.withCenter(center1).radius(radius); const area2 = SmallCircle.withCenter(center2).radius(radius); // Calculate distance between centers const centerDistance = GreatCircle.from(center1) .to(center2) .distance(); // Check for overlap const hasOverlap = centerDistance.inMeters() < (area1.getRadius().inMeters() + area2.getRadius().inMeters()); expect(hasOverlap).toBeDefined(); expect(area1.area() + area2.area()).toBeGreaterThan(0); }); }); describe('Survey Route Planning', () => { it('should generate parallel survey lines', () => { // Survey area corners const sw = new Coordinate(40.7, -74.1); const se = new Coordinate(40.7, -73.9); const ne = new Coordinate(40.8, -73.9); const nw = new Coordinate(40.8, -74.1); // Create boundary const boundary = [sw, se, ne, nw]; // Generate parallel lines const lineSpacing = Distance.fromKilometers(0.5); const lines: GreatCircle[] = []; for (let i = 0; i < 5; i++) { const start = GreatCircle.from(sw).to(se) .interpolate(i/4) as Coordinate; const end = GreatCircle.from(nw).to(ne) .interpolate(i/4) as Coordinate; lines.push(GreatCircle.from(start).to(end)); } // Calculate total survey distance const totalDistance = lines.reduce( (sum, line) => sum + line.distance().inMeters(), 0 ); expect(lines.length).toBe(5); expect(totalDistance).toBeGreaterThan(0); }); }); });
--- .gitignore: # Node.js node_modules/ npm-debug.log npm-debug.log.* yarn-debug.log yarn-error.log # Environment files .env .env.local .env.development.local .env.test.local .env.production.local # Editor directories and files .vscode/ .idea/ *.sublime-workspace *.sublime-project # Operating System generated files .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db # TypeScript Compiler output /build /dist /out /*.tsbuildinfo # Logs logs *.log *.csv # Dependency directories jspm_packages/ bower_components/ # Optional eslint cache .eslintcache # Output of 'npm pack' *.tgz # Yarn Integrity file .yarn-integrity # Generated files /src/**/*.js /src/**/*.js.map /src/**/*.d.ts # Production specific .production
--- New Text Document.txt: <empty file>
--- README.md: // Readme file for the project. # Spherical Geometry API ## Overview This API provides a comprehensive toolkit for performing geometric calculations on a spherical surface, ideal for applications in navigation, astronomy, and geospatial analysis. ## Classes and Methods ### Sphere | Method | Description | |-------------------|--------------------------------------------| | `surfaceArea()` | Calculates the surface area of the sphere. | | `volume()` | Calculates the volume of the sphere. | ### Coordinate | Method | Description | |-------------------|----------------------------------------------------| | `toRadians()` | Converts the latitude and longitude to radians. | | `toString()` | Returns a string representation of the coordinate. | ### GreatCircle | Method | Description | |------------------------|----------------------------------------------------| | `calculateDistance()` | Calculates the distance between two coordinates. | | `findMidpoint()` | Finds the midpoint along the great circle path. | ### Arc | Method | Description | |------------------------|------------------------------------------| | `calculateLength()` | Calculates the length of the arc. | | `findPointAtFraction()`| Finds a point at a specified fraction along the arc. | ### Triangle | Method | Description | |------------------------|------------------------------------------| | `calculateArea()` | Calculates the area of the spherical triangle. | | `calculatePerimeter()` | Calculates the perimeter of the triangle. | ### Angle | Method | Description | |------------------------|--------------------------------------------| | `toRadians()` | Converts the angle to radians. | | `normalize()` | Normalizes the angle to the range [0, 360]. | | `add(angle: Angle)` | Adds another angle to this angle. | | `subtract(angle: Angle)` | Subtracts another angle from this angle. | ### Azimuth | Method | Description | |------------------------|--------------------------------------------| | `calculateAzimuth()` | Calculates the azimuth from start to end point. | ### Bearing | Method | Description | |-----------------------------|----------------------------------------------| | `calculateInitialBearing()` | Calculates the initial bearing from start to end point. | | `calculateFinalBearing()` | Calculates the final bearing from start to end point. | ### GeometryService | Method | Description | |----------------------------------|----------------------------------------------| | `createGreatCircle()` | Creates a great circle from two coordinates. | | `calculateSmallCircleArea()` | Calculates the area of a small circle given its radius. | | `isWithinDistanceFromGreatCircle()` | Determines if a coordinate is within a certain distance from a great circle. | ### CalculationService | Method | Description | |----------------------------------|----------------------------------------------| | `calculateDistance()` | Calculates the distance between two coordinates. | | `calculateBearing()` | Calculates the bearing between two coordinates. | | `calculateTriangleAngle()` | Calculates the angle at a vertex of a spherical triangle given three coordinates. | ### Converters | Method | Description | |----------------------------|----------------------------------------------| | `degreesToRadians(degrees)`| Converts degrees to radians. | | `radiansToDegrees(radians)`| Converts radians to degrees. | ### Validators | Method | Description | |----------------------------|----------------------------------------------| | `validateLatitude(latitude)` | Validates if the latitude is within valid range. | | `validateLongitude(longitude)` | Validates if the longitude is within valid range. |
--- package-lock.json: { "name": "@dvanauken/sphere", "version": "0.1.0-alpha.1007", "lockfileVersion": 3, "requires": true, "packages": { "": { "name": "@dvanauken/sphere", "version": "0.1.0-alpha.1007", "license": "Proprietary", "dependencies": { "typescript": "^4.5.2" }, "devDependencies": { "@typescript-eslint/eslint-plugin": "^4.33.0", "@typescript-eslint/parser": "^4.33.0", "@vitest/coverage-v8": "^1.6.0", "eslint": "^7.32.0", "rimraf": "^5.0.0", "tslib": "^2.5.2", "tsx": "^4.19.2", "vitest": "^1.6.0" }, "peerDependencies": { "@angular/core": "^16.2.0", "tslib": "^2.3.0" }, "peerDependenciesMeta": { "@angular/core": { "optional": true } } }, "node_modules/@ampproject/remapping": { "version": "2.3.0", "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz", "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==", "dev": true, "dependencies": { "@jridgewell/gen-mapping": "^0.3.5", "@jridgewell/trace-mapping": "^0.3.24" }, "engines": { "node": ">=6.0.0" } }, "node_modules/@babel/code-frame": { "version": "7.12.11", "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.12.11.tgz", "integrity": "sha512-Zt1yodBx1UcyiePMSkWnU4hPqhwq7hGi2nFL1LeA3EUl+q2LQx16MISgJ0+z7dnmgvP9QtIleuETGOiOH1RcIw==", "dev": true, "dependencies": { "@babel/highlight": "^7.10.4" } }, "node_modules/@babel/helper-string-parser": { "version": "7.25.9", "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.25.9.tgz", "integrity": "sha512-4A/SCr/2KLd5jrtOMFzaKjVtAei3+2r/NChoBNoZ3EyP/+GlhoaEGoWOZUmFmoITP7zOJyHIMm+DYRd8o3PvHA==", "dev": true, "engines": { "node": ">=6.9.0" } }, "node_modules/@babel/helper-validator-identifier": { "version": "7.25.9", "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.25.9.tgz", "integrity": "sha512-Ed61U6XJc3CVRfkERJWDz4dJwKe7iLmmJsbOGu9wSloNSFttHV0I8g6UAgb7qnK5ly5bGLPd4oXZlxCdANBOWQ==", "dev": true, "engines": { "node": ">=6.9.0" } }, "node_modules/@babel/highlight": { "version": "7.25.9", "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.25.9.tgz", "integrity": "sha512-llL88JShoCsth8fF8R4SJnIn+WLvR6ccFxu1H3FlMhDontdcmZWf2HgIZ7AIqV3Xcck1idlohrN4EUBQz6klbw==", "dev": true, "dependencies": { "@babel/helper-validator-identifier": "^7.25.9", "chalk": "^2.4.2", "js-tokens": "^4.0.0", "picocolors": "^1.0.0" }, "engines": { "node": ">=6.9.0" } }, "node_modules/@babel/highlight/node_modules/ansi-styles": { "version": "3.2.1", "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz", "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==", "dev": true, "dependencies": { "color-convert": "^1.9.0" }, "engines": { "node": ">=4" } }, "node_modules/@babel/highlight/node_modules/chalk": { "version": "2.4.2", "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz", "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==", "dev": true, "dependencies": { "ansi-styles": "^3.2.1", "escape-string-regexp": "^1.0.5", "supports-color": "^5.3.0" }, "engines": { "node": ">=4" } }, "node_modules/@babel/highlight/node_modules/color-convert": { "version": "1.9.3", "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz", "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==", "dev": true, "dependencies": { "color-name": "1.1.3" } }, "node_modules/@babel/highlight/node_modules/color-name": { "version": "1.1.3", "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz", "integrity": "sha512-72fSenhMw2HZMTVHeCA9KCmpEIbzWiQsjN+BHcBbS9vr1mtt+vJjPdksIBNUmKAW8TFUDPJK5SUU3QhE9NEXDw==", "dev": true }, "node_modules/@babel/highlight/node_modules/escape-string-regexp": { "version": "1.0.5", "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz", "integrity": "sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==", "dev": true, "engines": { "node": ">=0.8.0" } }, "node_modules/@babel/highlight/node_modules/has-flag": { "version": "3.0.0", "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz", "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==", "dev": true, "engines": { "node": ">=4" } }, "node_modules/@babel/highlight/node_modules/supports-color": { "version": "5.5.0", "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz", "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==", "dev": true, "dependencies": { "has-flag": "^3.0.0" }, "engines": { "node": ">=4" } }, "node_modules/@babel/parser": { "version": "7.26.3", "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.26.3.tgz", "integrity": "sha512-WJ/CvmY8Mea8iDXo6a7RK2wbmJITT5fN3BEkRuFlxVyNx8jOKIIhmC4fSkTcPcf8JyavbBwIe6OpiCOBXt/IcA==", "dev": true, "dependencies": { "@babel/types": "^7.26.3" }, "bin": { "parser": "bin/babel-parser.js" }, "engines": { "node": ">=6.0.0" } }, "node_modules/@babel/types": { "version": "7.26.3", "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.26.3.tgz", "integrity": "sha512-vN5p+1kl59GVKMvTHt55NzzmYVxprfJD+ql7U9NFIfKCBkYE55LYtS+WtPlaYOyzydrKI8Nezd+aZextrd+FMA==", "dev": true, "dependencies": { "@babel/helper-string-parser": "^7.25.9", "@babel/helper-validator-identifier": "^7.25.9" }, "engines": { "node": ">=6.9.0" } }, "node_modules/@bcoe/v8-coverage": { "version": "0.2.3", "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz", "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==", "dev": true }, "node_modules/@esbuild/aix-ppc64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.23.1.tgz", "integrity": "sha512-6VhYk1diRqrhBAqpJEdjASR/+WVRtfjpqKuNw11cLiaWpAT/Uu+nokB+UJnevzy/P9C/ty6AOe0dwueMrGh/iQ==", "cpu": [ "ppc64" ], "dev": true, "optional": true, "os": [ "aix" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/android-arm": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.23.1.tgz", "integrity": "sha512-uz6/tEy2IFm9RYOyvKl88zdzZfwEfKZmnX9Cj1BHjeSGNuGLuMD1kR8y5bteYmwqKm1tj8m4cb/aKEorr6fHWQ==", "cpu": [ "arm" ], "dev": true, "optional": true, "os": [ "android" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/android-arm64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.23.1.tgz", "integrity": "sha512-xw50ipykXcLstLeWH7WRdQuysJqejuAGPd30vd1i5zSyKK3WE+ijzHmLKxdiCMtH1pHz78rOg0BKSYOSB/2Khw==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "android" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/android-x64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.23.1.tgz", "integrity": "sha512-nlN9B69St9BwUoB+jkyU090bru8L0NA3yFvAd7k8dNsVH8bi9a8cUAUSEcEEgTp2z3dbEDGJGfP6VUnkQnlReg==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "android" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/darwin-arm64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.23.1.tgz", "integrity": "sha512-YsS2e3Wtgnw7Wq53XXBLcV6JhRsEq8hkfg91ESVadIrzr9wO6jJDMZnCQbHm1Guc5t/CdDiFSSfWP58FNuvT3Q==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "darwin" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/darwin-x64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.23.1.tgz", "integrity": "sha512-aClqdgTDVPSEGgoCS8QDG37Gu8yc9lTHNAQlsztQ6ENetKEO//b8y31MMu2ZaPbn4kVsIABzVLXYLhCGekGDqw==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "darwin" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/freebsd-arm64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.23.1.tgz", "integrity": "sha512-h1k6yS8/pN/NHlMl5+v4XPfikhJulk4G+tKGFIOwURBSFzE8bixw1ebjluLOjfwtLqY0kewfjLSrO6tN2MgIhA==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "freebsd" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/freebsd-x64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.23.1.tgz", "integrity": "sha512-lK1eJeyk1ZX8UklqFd/3A60UuZ/6UVfGT2LuGo3Wp4/z7eRTRYY+0xOu2kpClP+vMTi9wKOfXi2vjUpO1Ro76g==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "freebsd" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-arm": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.23.1.tgz", "integrity": "sha512-CXXkzgn+dXAPs3WBwE+Kvnrf4WECwBdfjfeYHpMeVxWE0EceB6vhWGShs6wi0IYEqMSIzdOF1XjQ/Mkm5d7ZdQ==", "cpu": [ "arm" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-arm64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.23.1.tgz", "integrity": "sha512-/93bf2yxencYDnItMYV/v116zff6UyTjo4EtEQjUBeGiVpMmffDNUyD9UN2zV+V3LRV3/on4xdZ26NKzn6754g==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-ia32": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.23.1.tgz", "integrity": "sha512-VTN4EuOHwXEkXzX5nTvVY4s7E/Krz7COC8xkftbbKRYAl96vPiUssGkeMELQMOnLOJ8k3BY1+ZY52tttZnHcXQ==", "cpu": [ "ia32" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-loong64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.23.1.tgz", "integrity": "sha512-Vx09LzEoBa5zDnieH8LSMRToj7ir/Jeq0Gu6qJ/1GcBq9GkfoEAoXvLiW1U9J1qE/Y/Oyaq33w5p2ZWrNNHNEw==", "cpu": [ "loong64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-mips64el": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.23.1.tgz", "integrity": "sha512-nrFzzMQ7W4WRLNUOU5dlWAqa6yVeI0P78WKGUo7lg2HShq/yx+UYkeNSE0SSfSure0SqgnsxPvmAUu/vu0E+3Q==", "cpu": [ "mips64el" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-ppc64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.23.1.tgz", "integrity": "sha512-dKN8fgVqd0vUIjxuJI6P/9SSSe/mB9rvA98CSH2sJnlZ/OCZWO1DJvxj8jvKTfYUdGfcq2dDxoKaC6bHuTlgcw==", "cpu": [ "ppc64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-riscv64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.23.1.tgz", "integrity": "sha512-5AV4Pzp80fhHL83JM6LoA6pTQVWgB1HovMBsLQ9OZWLDqVY8MVobBXNSmAJi//Csh6tcY7e7Lny2Hg1tElMjIA==", "cpu": [ "riscv64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-s390x": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.23.1.tgz", "integrity": "sha512-9ygs73tuFCe6f6m/Tb+9LtYxWR4c9yg7zjt2cYkjDbDpV/xVn+68cQxMXCjUpYwEkze2RcU/rMnfIXNRFmSoDw==", "cpu": [ "s390x" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/linux-x64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.23.1.tgz", "integrity": "sha512-EV6+ovTsEXCPAp58g2dD68LxoP/wK5pRvgy0J/HxPGB009omFPv3Yet0HiaqvrIrgPTBuC6wCH1LTOY91EO5hQ==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/netbsd-x64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.23.1.tgz", "integrity": "sha512-aevEkCNu7KlPRpYLjwmdcuNz6bDFiE7Z8XC4CPqExjTvrHugh28QzUXVOZtiYghciKUacNktqxdpymplil1beA==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "netbsd" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/openbsd-arm64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.23.1.tgz", "integrity": "sha512-3x37szhLexNA4bXhLrCC/LImN/YtWis6WXr1VESlfVtVeoFJBRINPJ3f0a/6LV8zpikqoUg4hyXw0sFBt5Cr+Q==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "openbsd" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/openbsd-x64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.23.1.tgz", "integrity": "sha512-aY2gMmKmPhxfU+0EdnN+XNtGbjfQgwZj43k8G3fyrDM/UdZww6xrWxmDkuz2eCZchqVeABjV5BpildOrUbBTqA==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "openbsd" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/sunos-x64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.23.1.tgz", "integrity": "sha512-RBRT2gqEl0IKQABT4XTj78tpk9v7ehp+mazn2HbUeZl1YMdaGAQqhapjGTCe7uw7y0frDi4gS0uHzhvpFuI1sA==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "sunos" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/win32-arm64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.23.1.tgz", "integrity": "sha512-4O+gPR5rEBe2FpKOVyiJ7wNDPA8nGzDuJ6gN4okSA1gEOYZ67N8JPk58tkWtdtPeLz7lBnY6I5L3jdsr3S+A6A==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "win32" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/win32-ia32": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.23.1.tgz", "integrity": "sha512-BcaL0Vn6QwCwre3Y717nVHZbAa4UBEigzFm6VdsVdT/MbZ38xoj1X9HPkZhbmaBGUD1W8vxAfffbDe8bA6AKnQ==", "cpu": [ "ia32" ], "dev": true, "optional": true, "os": [ "win32" ], "engines": { "node": ">=18" } }, "node_modules/@esbuild/win32-x64": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.23.1.tgz", "integrity": "sha512-BHpFFeslkWrXWyUPnbKm+xYYVYruCinGcftSBaa8zoF9hZO4BcSCFUvHVTtzpIY6YzUnYtuEhZ+C9iEXjxnasg==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "win32" ], "engines": { "node": ">=18" } }, "node_modules/@eslint/eslintrc": { "version": "0.4.3", "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-0.4.3.tgz", "integrity": "sha512-J6KFFz5QCYUJq3pf0mjEcCJVERbzv71PUIDczuh9JkwGEzced6CO5ADLHB1rbf/+oPBtoPfMYNOpGDzCANlbXw==", "dev": true, "dependencies": { "ajv": "^6.12.4", "debug": "^4.1.1", "espree": "^7.3.0", "globals": "^13.9.0", "ignore": "^4.0.6", "import-fresh": "^3.2.1", "js-yaml": "^3.13.1", "minimatch": "^3.0.4", "strip-json-comments": "^3.1.1" }, "engines": { "node": "^10.12.0 || >=12.0.0" } }, "node_modules/@eslint/eslintrc/node_modules/ignore": { "version": "4.0.6", "resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz", "integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==", "dev": true, "engines": { "node": ">= 4" } }, "node_modules/@humanwhocodes/config-array": { "version": "0.5.0", "resolved": "https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.5.0.tgz", "integrity": "sha512-FagtKFz74XrTl7y6HCzQpwDfXP0yhxe9lHLD1UZxjvZIcbyRz8zTFF/yYNfSfzU414eDwZ1SrO0Qvtyf+wFMQg==", "deprecated": "Use @eslint/config-array instead", "dev": true, "dependencies": { "@humanwhocodes/object-schema": "^1.2.0", "debug": "^4.1.1", "minimatch": "^3.0.4" }, "engines": { "node": ">=10.10.0" } }, "node_modules/@humanwhocodes/object-schema": { "version": "1.2.1", "resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.1.tgz", "integrity": "sha512-ZnQMnLV4e7hDlUvw8H+U8ASL02SS2Gn6+9Ac3wGGLIe7+je2AeAOxPY+izIPJDfFDb7eDjev0Us8MO1iFRN8hA==", "deprecated": "Use @eslint/object-schema instead", "dev": true }, "node_modules/@isaacs/cliui": { "version": "8.0.2", "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz", "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==", "dev": true, "dependencies": { "string-width": "^5.1.2", "string-width-cjs": "npm:string-width@^4.2.0", "strip-ansi": "^7.0.1", "strip-ansi-cjs": "npm:strip-ansi@^6.0.1", "wrap-ansi": "^8.1.0", "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0" }, "engines": { "node": ">=12" } }, "node_modules/@isaacs/cliui/node_modules/ansi-regex": { "version": "6.1.0", "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz", "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==", "dev": true, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/chalk/ansi-regex?sponsor=1" } }, "node_modules/@isaacs/cliui/node_modules/strip-ansi": { "version": "7.1.0", "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz", "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==", "dev": true, "dependencies": { "ansi-regex": "^6.0.1" }, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/chalk/strip-ansi?sponsor=1" } }, "node_modules/@istanbuljs/schema": { "version": "0.1.3", "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz", "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/@jest/schemas": { "version": "29.6.3", "resolved": "https://registry.npmjs.org/@jest/schemas/-/schemas-29.6.3.tgz", "integrity": "sha512-mo5j5X+jIZmJQveBKeS/clAueipV7KgiX1vMgCxam1RNYiqE1w62n0/tJJnHtjW8ZHcQco5gY85jA3mi0L+nSA==", "dev": true, "dependencies": { "@sinclair/typebox": "^0.27.8" }, "engines": { "node": "^14.15.0 || ^16.10.0 || >=18.0.0" } }, "node_modules/@jridgewell/gen-mapping": { "version": "0.3.8", "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.8.tgz", "integrity": "sha512-imAbBGkb+ebQyxKgzv5Hu2nmROxoDOXHh80evxdoXNOrvAnVx7zimzc1Oo5h9RlfV4vPXaE2iM5pOFbvOCClWA==", "dev": true, "dependencies": { "@jridgewell/set-array": "^1.2.1", "@jridgewell/sourcemap-codec": "^1.4.10", "@jridgewell/trace-mapping": "^0.3.24" }, "engines": { "node": ">=6.0.0" } }, "node_modules/@jridgewell/resolve-uri": { "version": "3.1.2", "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz", "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==", "dev": true, "engines": { "node": ">=6.0.0" } }, "node_modules/@jridgewell/set-array": { "version": "1.2.1", "resolved": "https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.2.1.tgz", "integrity": "sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==", "dev": true, "engines": { "node": ">=6.0.0" } }, "node_modules/@jridgewell/sourcemap-codec": { "version": "1.5.0", "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz", "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==", "dev": true }, "node_modules/@jridgewell/trace-mapping": { "version": "0.3.25", "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.25.tgz", "integrity": "sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==", "dev": true, "dependencies": { "@jridgewell/resolve-uri": "^3.1.0", "@jridgewell/sourcemap-codec": "^1.4.14" } }, "node_modules/@nodelib/fs.scandir": { "version": "2.1.5", "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz", "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==", "dev": true, "dependencies": { "@nodelib/fs.stat": "2.0.5", "run-parallel": "^1.1.9" }, "engines": { "node": ">= 8" } }, "node_modules/@nodelib/fs.stat": { "version": "2.0.5", "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz", "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==", "dev": true, "engines": { "node": ">= 8" } }, "node_modules/@nodelib/fs.walk": { "version": "1.2.8", "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz", "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==", "dev": true, "dependencies": { "@nodelib/fs.scandir": "2.1.5", "fastq": "^1.6.0" }, "engines": { "node": ">= 8" } }, "node_modules/@pkgjs/parseargs": { "version": "0.11.0", "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz", "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==", "dev": true, "optional": true, "engines": { "node": ">=14" } }, "node_modules/@rollup/rollup-android-arm-eabi": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.29.1.tgz", "integrity": "sha512-ssKhA8RNltTZLpG6/QNkCSge+7mBQGUqJRisZ2MDQcEGaK93QESEgWK2iOpIDZ7k9zPVkG5AS3ksvD5ZWxmItw==", "cpu": [ "arm" ], "dev": true, "optional": true, "os": [ "android" ] }, "node_modules/@rollup/rollup-android-arm64": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.29.1.tgz", "integrity": "sha512-CaRfrV0cd+NIIcVVN/jx+hVLN+VRqnuzLRmfmlzpOzB87ajixsN/+9L5xNmkaUUvEbI5BmIKS+XTwXsHEb65Ew==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "android" ] }, "node_modules/@rollup/rollup-darwin-arm64": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.29.1.tgz", "integrity": "sha512-2ORr7T31Y0Mnk6qNuwtyNmy14MunTAMx06VAPI6/Ju52W10zk1i7i5U3vlDRWjhOI5quBcrvhkCHyF76bI7kEw==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "darwin" ] }, "node_modules/@rollup/rollup-darwin-x64": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.29.1.tgz", "integrity": "sha512-j/Ej1oanzPjmN0tirRd5K2/nncAhS9W6ICzgxV+9Y5ZsP0hiGhHJXZ2JQ53iSSjj8m6cRY6oB1GMzNn2EUt6Ng==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "darwin" ] }, "node_modules/@rollup/rollup-freebsd-arm64": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.29.1.tgz", "integrity": "sha512-91C//G6Dm/cv724tpt7nTyP+JdN12iqeXGFM1SqnljCmi5yTXriH7B1r8AD9dAZByHpKAumqP1Qy2vVNIdLZqw==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "freebsd" ] }, "node_modules/@rollup/rollup-freebsd-x64": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.29.1.tgz", "integrity": "sha512-hEioiEQ9Dec2nIRoeHUP6hr1PSkXzQaCUyqBDQ9I9ik4gCXQZjJMIVzoNLBRGet+hIUb3CISMh9KXuCcWVW/8w==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "freebsd" ] }, "node_modules/@rollup/rollup-linux-arm-gnueabihf": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.29.1.tgz", "integrity": "sha512-Py5vFd5HWYN9zxBv3WMrLAXY3yYJ6Q/aVERoeUFwiDGiMOWsMs7FokXihSOaT/PMWUty/Pj60XDQndK3eAfE6A==", "cpu": [ "arm" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-arm-musleabihf": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.29.1.tgz", "integrity": "sha512-RiWpGgbayf7LUcuSNIbahr0ys2YnEERD4gYdISA06wa0i8RALrnzflh9Wxii7zQJEB2/Eh74dX4y/sHKLWp5uQ==", "cpu": [ "arm" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-arm64-gnu": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.29.1.tgz", "integrity": "sha512-Z80O+taYxTQITWMjm/YqNoe9d10OX6kDh8X5/rFCMuPqsKsSyDilvfg+vd3iXIqtfmp+cnfL1UrYirkaF8SBZA==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-arm64-musl": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.29.1.tgz", "integrity": "sha512-fOHRtF9gahwJk3QVp01a/GqS4hBEZCV1oKglVVq13kcK3NeVlS4BwIFzOHDbmKzt3i0OuHG4zfRP0YoG5OF/rA==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-loongarch64-gnu": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loongarch64-gnu/-/rollup-linux-loongarch64-gnu-4.29.1.tgz", "integrity": "sha512-5a7q3tnlbcg0OodyxcAdrrCxFi0DgXJSoOuidFUzHZ2GixZXQs6Tc3CHmlvqKAmOs5eRde+JJxeIf9DonkmYkw==", "cpu": [ "loong64" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-powerpc64le-gnu": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-powerpc64le-gnu/-/rollup-linux-powerpc64le-gnu-4.29.1.tgz", "integrity": "sha512-9b4Mg5Yfz6mRnlSPIdROcfw1BU22FQxmfjlp/CShWwO3LilKQuMISMTtAu/bxmmrE6A902W2cZJuzx8+gJ8e9w==", "cpu": [ "ppc64" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-riscv64-gnu": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.29.1.tgz", "integrity": "sha512-G5pn0NChlbRM8OJWpJFMX4/i8OEU538uiSv0P6roZcbpe/WfhEO+AT8SHVKfp8qhDQzaz7Q+1/ixMy7hBRidnQ==", "cpu": [ "riscv64" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-s390x-gnu": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.29.1.tgz", "integrity": "sha512-WM9lIkNdkhVwiArmLxFXpWndFGuOka4oJOZh8EP3Vb8q5lzdSCBuhjavJsw68Q9AKDGeOOIHYzYm4ZFvmWez5g==", "cpu": [ "s390x" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-x64-gnu": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.29.1.tgz", "integrity": "sha512-87xYCwb0cPGZFoGiErT1eDcssByaLX4fc0z2nRM6eMtV9njAfEE6OW3UniAoDhX4Iq5xQVpE6qO9aJbCFumKYQ==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-linux-x64-musl": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.29.1.tgz", "integrity": "sha512-xufkSNppNOdVRCEC4WKvlR1FBDyqCSCpQeMMgv9ZyXqqtKBfkw1yfGMTUTs9Qsl6WQbJnsGboWCp7pJGkeMhKA==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "linux" ] }, "node_modules/@rollup/rollup-win32-arm64-msvc": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.29.1.tgz", "integrity": "sha512-F2OiJ42m77lSkizZQLuC+jiZ2cgueWQL5YC9tjo3AgaEw+KJmVxHGSyQfDUoYR9cci0lAywv2Clmckzulcq6ig==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "win32" ] }, "node_modules/@rollup/rollup-win32-ia32-msvc": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.29.1.tgz", "integrity": "sha512-rYRe5S0FcjlOBZQHgbTKNrqxCBUmgDJem/VQTCcTnA2KCabYSWQDrytOzX7avb79cAAweNmMUb/Zw18RNd4mng==", "cpu": [ "ia32" ], "dev": true, "optional": true, "os": [ "win32" ] }, "node_modules/@rollup/rollup-win32-x64-msvc": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.29.1.tgz", "integrity": "sha512-+10CMg9vt1MoHj6x1pxyjPSMjHTIlqs8/tBztXvPAx24SKs9jwVnKqHJumlH/IzhaPUaj3T6T6wfZr8okdXaIg==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "win32" ] }, "node_modules/@sinclair/typebox": { "version": "0.27.8", "resolved": "https://registry.npmjs.org/@sinclair/typebox/-/typebox-0.27.8.tgz", "integrity": "sha512-+Fj43pSMwJs4KRrH/938Uf+uAELIgVBmQzg/q1YG10djyfA3TnrU8N8XzqCh/okZdszqBQTZf96idMfE5lnwTA==", "dev": true }, "node_modules/@types/estree": { "version": "1.0.6", "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.6.tgz", "integrity": "sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==", "dev": true }, "node_modules/@types/json-schema": { "version": "7.0.15", "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz", "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==", "dev": true }, "node_modules/@typescript-eslint/eslint-plugin": { "version": "4.33.0", "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-4.33.0.tgz", "integrity": "sha512-aINiAxGVdOl1eJyVjaWn/YcVAq4Gi/Yo35qHGCnqbWVz61g39D0h23veY/MA0rFFGfxK7TySg2uwDeNv+JgVpg==", "dev": true, "dependencies": { "@typescript-eslint/experimental-utils": "4.33.0", "@typescript-eslint/scope-manager": "4.33.0", "debug": "^4.3.1", "functional-red-black-tree": "^1.0.1", "ignore": "^5.1.8", "regexpp": "^3.1.0", "semver": "^7.3.5", "tsutils": "^3.21.0" }, "engines": { "node": "^10.12.0 || >=12.0.0" }, "funding": { "type": "opencollective", "url": "https://opencollective.com/typescript-eslint" }, "peerDependencies": { "@typescript-eslint/parser": "^4.0.0", "eslint": "^5.0.0 || ^6.0.0 || ^7.0.0" }, "peerDependenciesMeta": { "typescript": { "optional": true } } }, "node_modules/@typescript-eslint/experimental-utils": { "version": "4.33.0", "resolved": "https://registry.npmjs.org/@typescript-eslint/experimental-utils/-/experimental-utils-4.33.0.tgz", "integrity": "sha512-zeQjOoES5JFjTnAhI5QY7ZviczMzDptls15GFsI6jyUOq0kOf9+WonkhtlIhh0RgHRnqj5gdNxW5j1EvAyYg6Q==", "dev": true, "dependencies": { "@types/json-schema": "^7.0.7", "@typescript-eslint/scope-manager": "4.33.0", "@typescript-eslint/types": "4.33.0", "@typescript-eslint/typescript-estree": "4.33.0", "eslint-scope": "^5.1.1", "eslint-utils": "^3.0.0" }, "engines": { "node": "^10.12.0 || >=12.0.0" }, "funding": { "type": "opencollective", "url": "https://opencollective.com/typescript-eslint" }, "peerDependencies": { "eslint": "*" } }, "node_modules/@typescript-eslint/parser": { "version": "4.33.0", "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-4.33.0.tgz", "integrity": "sha512-ZohdsbXadjGBSK0/r+d87X0SBmKzOq4/S5nzK6SBgJspFo9/CUDJ7hjayuze+JK7CZQLDMroqytp7pOcFKTxZA==", "dev": true, "dependencies": { "@typescript-eslint/scope-manager": "4.33.0", "@typescript-eslint/types": "4.33.0", "@typescript-eslint/typescript-estree": "4.33.0", "debug": "^4.3.1" }, "engines": { "node": "^10.12.0 || >=12.0.0" }, "funding": { "type": "opencollective", "url": "https://opencollective.com/typescript-eslint" }, "peerDependencies": { "eslint": "^5.0.0 || ^6.0.0 || ^7.0.0" }, "peerDependenciesMeta": { "typescript": { "optional": true } } }, "node_modules/@typescript-eslint/scope-manager": { "version": "4.33.0", "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-4.33.0.tgz", "integrity": "sha512-5IfJHpgTsTZuONKbODctL4kKuQje/bzBRkwHE8UOZ4f89Zeddg+EGZs8PD8NcN4LdM3ygHWYB3ukPAYjvl/qbQ==", "dev": true, "dependencies": { "@typescript-eslint/types": "4.33.0", "@typescript-eslint/visitor-keys": "4.33.0" }, "engines": { "node": "^8.10.0 || ^10.13.0 || >=11.10.1" }, "funding": { "type": "opencollective", "url": "https://opencollective.com/typescript-eslint" } }, "node_modules/@typescript-eslint/types": { "version": "4.33.0", "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-4.33.0.tgz", "integrity": "sha512-zKp7CjQzLQImXEpLt2BUw1tvOMPfNoTAfb8l51evhYbOEEzdWyQNmHWWGPR6hwKJDAi+1VXSBmnhL9kyVTTOuQ==", "dev": true, "engines": { "node": "^8.10.0 || ^10.13.0 || >=11.10.1" }, "funding": { "type": "opencollective", "url": "https://opencollective.com/typescript-eslint" } }, "node_modules/@typescript-eslint/typescript-estree": { "version": "4.33.0", "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-4.33.0.tgz", "integrity": "sha512-rkWRY1MPFzjwnEVHsxGemDzqqddw2QbTJlICPD9p9I9LfsO8fdmfQPOX3uKfUaGRDFJbfrtm/sXhVXN4E+bzCA==", "dev": true, "dependencies": { "@typescript-eslint/types": "4.33.0", "@typescript-eslint/visitor-keys": "4.33.0", "debug": "^4.3.1", "globby": "^11.0.3", "is-glob": "^4.0.1", "semver": "^7.3.5", "tsutils": "^3.21.0" }, "engines": { "node": "^10.12.0 || >=12.0.0" }, "funding": { "type": "opencollective", "url": "https://opencollective.com/typescript-eslint" }, "peerDependenciesMeta": { "typescript": { "optional": true } } }, "node_modules/@typescript-eslint/visitor-keys": { "version": "4.33.0", "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-4.33.0.tgz", "integrity": "sha512-uqi/2aSz9g2ftcHWf8uLPJA70rUv6yuMW5Bohw+bwcuzaxQIHaKFZCKGoGXIrc9vkTJ3+0txM73K0Hq3d5wgIg==", "dev": true, "dependencies": { "@typescript-eslint/types": "4.33.0", "eslint-visitor-keys": "^2.0.0" }, "engines": { "node": "^8.10.0 || ^10.13.0 || >=11.10.1" }, "funding": { "type": "opencollective", "url": "https://opencollective.com/typescript-eslint" } }, "node_modules/@vitest/coverage-v8": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-1.6.0.tgz", "integrity": "sha512-KvapcbMY/8GYIG0rlwwOKCVNRc0OL20rrhFkg/CHNzncV03TE2XWvO5w9uZYoxNiMEBacAJt3unSOiZ7svePew==", "dev": true, "dependencies": { "@ampproject/remapping": "^2.2.1", "@bcoe/v8-coverage": "^0.2.3", "debug": "^4.3.4", "istanbul-lib-coverage": "^3.2.2", "istanbul-lib-report": "^3.0.1", "istanbul-lib-source-maps": "^5.0.4", "istanbul-reports": "^3.1.6", "magic-string": "^0.30.5", "magicast": "^0.3.3", "picocolors": "^1.0.0", "std-env": "^3.5.0", "strip-literal": "^2.0.0", "test-exclude": "^6.0.0" }, "funding": { "url": "https://opencollective.com/vitest" }, "peerDependencies": { "vitest": "1.6.0" } }, "node_modules/@vitest/expect": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-1.6.0.tgz", "integrity": "sha512-ixEvFVQjycy/oNgHjqsL6AZCDduC+tflRluaHIzKIsdbzkLn2U/iBnVeJwB6HsIjQBdfMR8Z0tRxKUsvFJEeWQ==", "dev": true, "dependencies": { "@vitest/spy": "1.6.0", "@vitest/utils": "1.6.0", "chai": "^4.3.10" }, "funding": { "url": "https://opencollective.com/vitest" } }, "node_modules/@vitest/runner": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/@vitest/runner/-/runner-1.6.0.tgz", "integrity": "sha512-P4xgwPjwesuBiHisAVz/LSSZtDjOTPYZVmNAnpHHSR6ONrf8eCJOFRvUwdHn30F5M1fxhqtl7QZQUk2dprIXAg==", "dev": true, "dependencies": { "@vitest/utils": "1.6.0", "p-limit": "^5.0.0", "pathe": "^1.1.1" }, "funding": { "url": "https://opencollective.com/vitest" } }, "node_modules/@vitest/snapshot": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/@vitest/snapshot/-/snapshot-1.6.0.tgz", "integrity": "sha512-+Hx43f8Chus+DCmygqqfetcAZrDJwvTj0ymqjQq4CvmpKFSTVteEOBzCusu1x2tt4OJcvBflyHUE0DZSLgEMtQ==", "dev": true, "dependencies": { "magic-string": "^0.30.5", "pathe": "^1.1.1", "pretty-format": "^29.7.0" }, "funding": { "url": "https://opencollective.com/vitest" } }, "node_modules/@vitest/spy": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/@vitest/spy/-/spy-1.6.0.tgz", "integrity": "sha512-leUTap6B/cqi/bQkXUu6bQV5TZPx7pmMBKBQiI0rJA8c3pB56ZsaTbREnF7CJfmvAS4V2cXIBAh/3rVwrrCYgw==", "dev": true, "dependencies": { "tinyspy": "^2.2.0" }, "funding": { "url": "https://opencollective.com/vitest" } }, "node_modules/@vitest/utils": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/@vitest/utils/-/utils-1.6.0.tgz", "integrity": "sha512-21cPiuGMoMZwiOHa2i4LXkMkMkCGzA+MVFV70jRwHo95dL4x/ts5GZhML1QWuy7yfp3WzK3lRvZi3JnXTYqrBw==", "dev": true, "dependencies": { "diff-sequences": "^29.6.3", "estree-walker": "^3.0.3", "loupe": "^2.3.7", "pretty-format": "^29.7.0" }, "funding": { "url": "https://opencollective.com/vitest" } }, "node_modules/acorn": { "version": "7.4.1", "resolved": "https://registry.npmjs.org/acorn/-/acorn-7.4.1.tgz", "integrity": "sha512-nQyp0o1/mNdbTO1PO6kHkwSrmgZ0MT/jCCpNiwbUjGoRN4dlBhqJtoQuCnEOKzgTVwg0ZWiCoQy6SxMebQVh8A==", "dev": true, "bin": { "acorn": "bin/acorn" }, "engines": { "node": ">=0.4.0" } }, "node_modules/acorn-jsx": { "version": "5.3.2", "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz", "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==", "dev": true, "peerDependencies": { "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0" } }, "node_modules/acorn-walk": { "version": "8.3.4", "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.4.tgz", "integrity": "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==", "dev": true, "dependencies": { "acorn": "^8.11.0" }, "engines": { "node": ">=0.4.0" } }, "node_modules/acorn-walk/node_modules/acorn": { "version": "8.14.0", "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.0.tgz", "integrity": "sha512-cl669nCJTZBsL97OF4kUQm5g5hC2uihk0NxY3WENAC0TYdILVkAyHymAntgxGkl7K+t0cXIrH5siy5S4XkFycA==", "dev": true, "bin": { "acorn": "bin/acorn" }, "engines": { "node": ">=0.4.0" } }, "node_modules/ajv": { "version": "6.12.6", "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz", "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==", "dev": true, "dependencies": { "fast-deep-equal": "^3.1.1", "fast-json-stable-stringify": "^2.0.0", "json-schema-traverse": "^0.4.1", "uri-js": "^4.2.2" }, "funding": { "type": "github", "url": "https://github.com/sponsors/epoberezkin" } }, "node_modules/ansi-colors": { "version": "4.1.3", "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.3.tgz", "integrity": "sha512-/6w/C21Pm1A7aZitlI5Ni/2J6FFQN8i1Cvz3kHABAAbw93v/NlvKdVOqz7CCWz/3iv/JplRSEEZ83XION15ovw==", "dev": true, "engines": { "node": ">=6" } }, "node_modules/ansi-regex": { "version": "5.0.1", "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz", "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/ansi-styles": { "version": "4.3.0", "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz", "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==", "dev": true, "dependencies": { "color-convert": "^2.0.1" }, "engines": { "node": ">=8" }, "funding": { "url": "https://github.com/chalk/ansi-styles?sponsor=1" } }, "node_modules/argparse": { "version": "1.0.10", "resolved": "https://registry.npmjs.org/argparse/-/argparse-1.0.10.tgz", "integrity": "sha512-o5Roy6tNG4SL/FOkCAN6RzjiakZS25RLYFrcMttJqbdd8BWrnA+fGz57iN5Pb06pvBGvl5gQ0B48dJlslXvoTg==", "dev": true, "dependencies": { "sprintf-js": "~1.0.2" } }, "node_modules/array-union": { "version": "2.1.0", "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz", "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/assertion-error": { "version": "1.1.0", "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz", "integrity": "sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==", "dev": true, "engines": { "node": "*" } }, "node_modules/astral-regex": { "version": "2.0.0", "resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz", "integrity": "sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/balanced-match": { "version": "1.0.2", "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz", "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==", "dev": true }, "node_modules/brace-expansion": { "version": "1.1.11", "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz", "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==", "dev": true, "dependencies": { "balanced-match": "^1.0.0", "concat-map": "0.0.1" } }, "node_modules/braces": { "version": "3.0.3", "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz", "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==", "dev": true, "dependencies": { "fill-range": "^7.1.1" }, "engines": { "node": ">=8" } }, "node_modules/cac": { "version": "6.7.14", "resolved": "https://registry.npmjs.org/cac/-/cac-6.7.14.tgz", "integrity": "sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/callsites": { "version": "3.1.0", "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz", "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==", "dev": true, "engines": { "node": ">=6" } }, "node_modules/chai": { "version": "4.5.0", "resolved": "https://registry.npmjs.org/chai/-/chai-4.5.0.tgz", "integrity": "sha512-RITGBfijLkBddZvnn8jdqoTypxvqbOLYQkGGxXzeFjVHvudaPw0HNFD9x928/eUwYWd2dPCugVqspGALTZZQKw==", "dev": true, "dependencies": { "assertion-error": "^1.1.0", "check-error": "^1.0.3", "deep-eql": "^4.1.3", "get-func-name": "^2.0.2", "loupe": "^2.3.6", "pathval": "^1.1.1", "type-detect": "^4.1.0" }, "engines": { "node": ">=4" } }, "node_modules/chalk": { "version": "4.1.2", "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz", "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==", "dev": true, "dependencies": { "ansi-styles": "^4.1.0", "supports-color": "^7.1.0" }, "engines": { "node": ">=10" }, "funding": { "url": "https://github.com/chalk/chalk?sponsor=1" } }, "node_modules/check-error": { "version": "1.0.3", "resolved": "https://registry.npmjs.org/check-error/-/check-error-1.0.3.tgz", "integrity": "sha512-iKEoDYaRmd1mxM90a2OEfWhjsjPpYPuQ+lMYsoxB126+t8fw7ySEO48nmDg5COTjxDI65/Y2OWpeEHk3ZOe8zg==", "dev": true, "dependencies": { "get-func-name": "^2.0.2" }, "engines": { "node": "*" } }, "node_modules/color-convert": { "version": "2.0.1", "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz", "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==", "dev": true, "dependencies": { "color-name": "~1.1.4" }, "engines": { "node": ">=7.0.0" } }, "node_modules/color-name": { "version": "1.1.4", "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz", "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==", "dev": true }, "node_modules/concat-map": { "version": "0.0.1", "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz", "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==", "dev": true }, "node_modules/confbox": { "version": "0.1.8", "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.1.8.tgz", "integrity": "sha512-RMtmw0iFkeR4YV+fUOSucriAQNb9g8zFR52MWCtl+cCZOFRNL6zeB395vPzFhEjjn4fMxXudmELnl/KF/WrK6w==", "dev": true }, "node_modules/cross-spawn": { "version": "7.0.6", "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz", "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==", "dev": true, "dependencies": { "path-key": "^3.1.0", "shebang-command": "^2.0.0", "which": "^2.0.1" }, "engines": { "node": ">= 8" } }, "node_modules/debug": { "version": "4.4.0", "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.0.tgz", "integrity": "sha512-6WTZ/IxCY/T6BALoZHaE4ctp9xm+Z5kY/pzYaCHRFeyVhojxlrm+46y68HA6hr0TcwEssoxNiDEUJQjfPZ/RYA==", "dev": true, "dependencies": { "ms": "^2.1.3" }, "engines": { "node": ">=6.0" }, "peerDependenciesMeta": { "supports-color": { "optional": true } } }, "node_modules/deep-eql": { "version": "4.1.4", "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-4.1.4.tgz", "integrity": "sha512-SUwdGfqdKOwxCPeVYjwSyRpJ7Z+fhpwIAtmCUdZIWZ/YP5R9WAsyuSgpLVDi9bjWoN2LXHNss/dk3urXtdQxGg==", "dev": true, "dependencies": { "type-detect": "^4.0.0" }, "engines": { "node": ">=6" } }, "node_modules/deep-is": { "version": "0.1.4", "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz", "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==", "dev": true }, "node_modules/diff-sequences": { "version": "29.6.3", "resolved": "https://registry.npmjs.org/diff-sequences/-/diff-sequences-29.6.3.tgz", "integrity": "sha512-EjePK1srD3P08o2j4f0ExnylqRs5B9tJjcp9t1krH2qRi8CCdsYfwe9JgSLurFBWwq4uOlipzfk5fHNvwFKr8Q==", "dev": true, "engines": { "node": "^14.15.0 || ^16.10.0 || >=18.0.0" } }, "node_modules/dir-glob": { "version": "3.0.1", "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz", "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==", "dev": true, "dependencies": { "path-type": "^4.0.0" }, "engines": { "node": ">=8" } }, "node_modules/doctrine": { "version": "3.0.0", "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz", "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==", "dev": true, "dependencies": { "esutils": "^2.0.2" }, "engines": { "node": ">=6.0.0" } }, "node_modules/eastasianwidth": { "version": "0.2.0", "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz", "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==", "dev": true }, "node_modules/emoji-regex": { "version": "9.2.2", "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz", "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==", "dev": true }, "node_modules/enquirer": { "version": "2.4.1", "resolved": "https://registry.npmjs.org/enquirer/-/enquirer-2.4.1.tgz", "integrity": "sha512-rRqJg/6gd538VHvR3PSrdRBb/1Vy2YfzHqzvbhGIQpDRKIa4FgV/54b5Q1xYSxOOwKvjXweS26E0Q+nAMwp2pQ==", "dev": true, "dependencies": { "ansi-colors": "^4.1.1", "strip-ansi": "^6.0.1" }, "engines": { "node": ">=8.6" } }, "node_modules/esbuild": { "version": "0.23.1", "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.23.1.tgz", "integrity": "sha512-VVNz/9Sa0bs5SELtn3f7qhJCDPCF5oMEl5cO9/SSinpE9hbPVvxbd572HH5AKiP7WD8INO53GgfDDhRjkylHEg==", "dev": true, "hasInstallScript": true, "bin": { "esbuild": "bin/esbuild" }, "engines": { "node": ">=18" }, "optionalDependencies": { "@esbuild/aix-ppc64": "0.23.1", "@esbuild/android-arm": "0.23.1", "@esbuild/android-arm64": "0.23.1", "@esbuild/android-x64": "0.23.1", "@esbuild/darwin-arm64": "0.23.1", "@esbuild/darwin-x64": "0.23.1", "@esbuild/freebsd-arm64": "0.23.1", "@esbuild/freebsd-x64": "0.23.1", "@esbuild/linux-arm": "0.23.1", "@esbuild/linux-arm64": "0.23.1", "@esbuild/linux-ia32": "0.23.1", "@esbuild/linux-loong64": "0.23.1", "@esbuild/linux-mips64el": "0.23.1", "@esbuild/linux-ppc64": "0.23.1", "@esbuild/linux-riscv64": "0.23.1", "@esbuild/linux-s390x": "0.23.1", "@esbuild/linux-x64": "0.23.1", "@esbuild/netbsd-x64": "0.23.1", "@esbuild/openbsd-arm64": "0.23.1", "@esbuild/openbsd-x64": "0.23.1", "@esbuild/sunos-x64": "0.23.1", "@esbuild/win32-arm64": "0.23.1", "@esbuild/win32-ia32": "0.23.1", "@esbuild/win32-x64": "0.23.1" } }, "node_modules/escape-string-regexp": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz", "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==", "dev": true, "engines": { "node": ">=10" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/eslint": { "version": "7.32.0", "resolved": "https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz", "integrity": "sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==", "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.", "dev": true, "dependencies": { "@babel/code-frame": "7.12.11", "@eslint/eslintrc": "^0.4.3", "@humanwhocodes/config-array": "^0.5.0", "ajv": "^6.10.0", "chalk": "^4.0.0", "cross-spawn": "^7.0.2", "debug": "^4.0.1", "doctrine": "^3.0.0", "enquirer": "^2.3.5", "escape-string-regexp": "^4.0.0", "eslint-scope": "^5.1.1", "eslint-utils": "^2.1.0", "eslint-visitor-keys": "^2.0.0", "espree": "^7.3.1", "esquery": "^1.4.0", "esutils": "^2.0.2", "fast-deep-equal": "^3.1.3", "file-entry-cache": "^6.0.1", "functional-red-black-tree": "^1.0.1", "glob-parent": "^5.1.2", "globals": "^13.6.0", "ignore": "^4.0.6", "import-fresh": "^3.0.0", "imurmurhash": "^0.1.4", "is-glob": "^4.0.0", "js-yaml": "^3.13.1", "json-stable-stringify-without-jsonify": "^1.0.1", "levn": "^0.4.1", "lodash.merge": "^4.6.2", "minimatch": "^3.0.4", "natural-compare": "^1.4.0", "optionator": "^0.9.1", "progress": "^2.0.0", "regexpp": "^3.1.0", "semver": "^7.2.1", "strip-ansi": "^6.0.0", "strip-json-comments": "^3.1.0", "table": "^6.0.9", "text-table": "^0.2.0", "v8-compile-cache": "^2.0.3" }, "bin": { "eslint": "bin/eslint.js" }, "engines": { "node": "^10.12.0 || >=12.0.0" }, "funding": { "url": "https://opencollective.com/eslint" } }, "node_modules/eslint-scope": { "version": "5.1.1", "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz", "integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==", "dev": true, "dependencies": { "esrecurse": "^4.3.0", "estraverse": "^4.1.1" }, "engines": { "node": ">=8.0.0" } }, "node_modules/eslint-utils": { "version": "3.0.0", "resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-3.0.0.tgz", "integrity": "sha512-uuQC43IGctw68pJA1RgbQS8/NP7rch6Cwd4j3ZBtgo4/8Flj4eGE7ZYSZRN3iq5pVUv6GPdW5Z1RFleo84uLDA==", "dev": true, "dependencies": { "eslint-visitor-keys": "^2.0.0" }, "engines": { "node": "^10.0.0 || ^12.0.0 || >= 14.0.0" }, "funding": { "url": "https://github.com/sponsors/mysticatea" }, "peerDependencies": { "eslint": ">=5" } }, "node_modules/eslint-visitor-keys": { "version": "2.1.0", "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz", "integrity": "sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==", "dev": true, "engines": { "node": ">=10" } }, "node_modules/eslint/node_modules/eslint-utils": { "version": "2.1.0", "resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-2.1.0.tgz", "integrity": "sha512-w94dQYoauyvlDc43XnGB8lU3Zt713vNChgt4EWwhXAP2XkBvndfxF0AgIqKOOasjPIPzj9JqgwkwbCYD0/V3Zg==", "dev": true, "dependencies": { "eslint-visitor-keys": "^1.1.0" }, "engines": { "node": ">=6" }, "funding": { "url": "https://github.com/sponsors/mysticatea" } }, "node_modules/eslint/node_modules/eslint-utils/node_modules/eslint-visitor-keys": { "version": "1.3.0", "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz", "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==", "dev": true, "engines": { "node": ">=4" } }, "node_modules/eslint/node_modules/ignore": { "version": "4.0.6", "resolved": "https://registry.npmjs.org/ignore/-/ignore-4.0.6.tgz", "integrity": "sha512-cyFDKrqc/YdcWFniJhzI42+AzS+gNwmUzOSFcRCQYwySuBBBy/KjuxWLZ/FHEH6Moq1NizMOBWyTcv8O4OZIMg==", "dev": true, "engines": { "node": ">= 4" } }, "node_modules/espree": { "version": "7.3.1", "resolved": "https://registry.npmjs.org/espree/-/espree-7.3.1.tgz", "integrity": "sha512-v3JCNCE64umkFpmkFGqzVKsOT0tN1Zr+ueqLZfpV1Ob8e+CEgPWa+OxCoGH3tnhimMKIaBm4m/vaRpJ/krRz2g==", "dev": true, "dependencies": { "acorn": "^7.4.0", "acorn-jsx": "^5.3.1", "eslint-visitor-keys": "^1.3.0" }, "engines": { "node": "^10.12.0 || >=12.0.0" } }, "node_modules/espree/node_modules/eslint-visitor-keys": { "version": "1.3.0", "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-1.3.0.tgz", "integrity": "sha512-6J72N8UNa462wa/KFODt/PJ3IU60SDpC3QXC1Hjc1BXXpfL2C9R5+AU7jhe0F6GREqVMh4Juu+NY7xn+6dipUQ==", "dev": true, "engines": { "node": ">=4" } }, "node_modules/esprima": { "version": "4.0.1", "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz", "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==", "dev": true, "bin": { "esparse": "bin/esparse.js", "esvalidate": "bin/esvalidate.js" }, "engines": { "node": ">=4" } }, "node_modules/esquery": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz", "integrity": "sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==", "dev": true, "dependencies": { "estraverse": "^5.1.0" }, "engines": { "node": ">=0.10" } }, "node_modules/esquery/node_modules/estraverse": { "version": "5.3.0", "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz", "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==", "dev": true, "engines": { "node": ">=4.0" } }, "node_modules/esrecurse": { "version": "4.3.0", "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz", "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==", "dev": true, "dependencies": { "estraverse": "^5.2.0" }, "engines": { "node": ">=4.0" } }, "node_modules/esrecurse/node_modules/estraverse": { "version": "5.3.0", "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz", "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==", "dev": true, "engines": { "node": ">=4.0" } }, "node_modules/estraverse": { "version": "4.3.0", "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz", "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==", "dev": true, "engines": { "node": ">=4.0" } }, "node_modules/estree-walker": { "version": "3.0.3", "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-3.0.3.tgz", "integrity": "sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==", "dev": true, "dependencies": { "@types/estree": "^1.0.0" } }, "node_modules/esutils": { "version": "2.0.3", "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz", "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==", "dev": true, "engines": { "node": ">=0.10.0" } }, "node_modules/execa": { "version": "8.0.1", "resolved": "https://registry.npmjs.org/execa/-/execa-8.0.1.tgz", "integrity": "sha512-VyhnebXciFV2DESc+p6B+y0LjSm0krU4OgJN44qFAhBY0TJ+1V61tYD2+wHusZ6F9n5K+vl8k0sTy7PEfV4qpg==", "dev": true, "dependencies": { "cross-spawn": "^7.0.3", "get-stream": "^8.0.1", "human-signals": "^5.0.0", "is-stream": "^3.0.0", "merge-stream": "^2.0.0", "npm-run-path": "^5.1.0", "onetime": "^6.0.0", "signal-exit": "^4.1.0", "strip-final-newline": "^3.0.0" }, "engines": { "node": ">=16.17" }, "funding": { "url": "https://github.com/sindresorhus/execa?sponsor=1" } }, "node_modules/fast-deep-equal": { "version": "3.1.3", "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz", "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==", "dev": true }, "node_modules/fast-glob": { "version": "3.3.2", "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.2.tgz", "integrity": "sha512-oX2ruAFQwf/Orj8m737Y5adxDQO0LAB7/S5MnxCdTNDd4p6BsyIVsv9JQsATbTSq8KHRpLwIHbVlUNatxd+1Ow==", "dev": true, "dependencies": { "@nodelib/fs.stat": "^2.0.2", "@nodelib/fs.walk": "^1.2.3", "glob-parent": "^5.1.2", "merge2": "^1.3.0", "micromatch": "^4.0.4" }, "engines": { "node": ">=8.6.0" } }, "node_modules/fast-json-stable-stringify": { "version": "2.1.0", "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz", "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==", "dev": true }, "node_modules/fast-levenshtein": { "version": "2.0.6", "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz", "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==", "dev": true }, "node_modules/fast-uri": { "version": "3.0.3", "resolved": "https://registry.npmjs.org/fast-uri/-/fast-uri-3.0.3.tgz", "integrity": "sha512-aLrHthzCjH5He4Z2H9YZ+v6Ujb9ocRuW6ZzkJQOrTxleEijANq4v1TsaPaVG1PZcuurEzrLcWRyYBYXD5cEiaw==", "dev": true }, "node_modules/fastq": { "version": "1.18.0", "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.18.0.tgz", "integrity": "sha512-QKHXPW0hD8g4UET03SdOdunzSouc9N4AuHdsX8XNcTsuz+yYFILVNIX4l9yHABMhiEI9Db0JTTIpu0wB+Y1QQw==", "dev": true, "dependencies": { "reusify": "^1.0.4" } }, "node_modules/file-entry-cache": { "version": "6.0.1", "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz", "integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==", "dev": true, "dependencies": { "flat-cache": "^3.0.4" }, "engines": { "node": "^10.12.0 || >=12.0.0" } }, "node_modules/fill-range": { "version": "7.1.1", "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz", "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==", "dev": true, "dependencies": { "to-regex-range": "^5.0.1" }, "engines": { "node": ">=8" } }, "node_modules/flat-cache": { "version": "3.2.0", "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.2.0.tgz", "integrity": "sha512-CYcENa+FtcUKLmhhqyctpclsq7QF38pKjZHsGNiSQF5r4FtoKDWabFDl3hzaEQMvT1LHEysw5twgLvpYYb4vbw==", "dev": true, "dependencies": { "flatted": "^3.2.9", "keyv": "^4.5.3", "rimraf": "^3.0.2" }, "engines": { "node": "^10.12.0 || >=12.0.0" } }, "node_modules/flat-cache/node_modules/glob": { "version": "7.2.3", "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz", "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==", "deprecated": "Glob versions prior to v9 are no longer supported", "dev": true, "dependencies": { "fs.realpath": "^1.0.0", "inflight": "^1.0.4", "inherits": "2", "minimatch": "^3.1.1", "once": "^1.3.0", "path-is-absolute": "^1.0.0" }, "engines": { "node": "*" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/flat-cache/node_modules/rimraf": { "version": "3.0.2", "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz", "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==", "deprecated": "Rimraf versions prior to v4 are no longer supported", "dev": true, "dependencies": { "glob": "^7.1.3" }, "bin": { "rimraf": "bin.js" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/flatted": { "version": "3.3.2", "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.2.tgz", "integrity": "sha512-AiwGJM8YcNOaobumgtng+6NHuOqC3A7MixFeDafM3X9cIUM+xUXoS5Vfgf+OihAYe20fxqNM9yPBXJzRtZ/4eA==", "dev": true }, "node_modules/foreground-child": { "version": "3.3.0", "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.0.tgz", "integrity": "sha512-Ld2g8rrAyMYFXBhEqMz8ZAHBi4J4uS1i/CxGMDnjyFWddMXLVcDp051DZfu+t7+ab7Wv6SMqpWmyFIj5UbfFvg==", "dev": true, "dependencies": { "cross-spawn": "^7.0.0", "signal-exit": "^4.0.1" }, "engines": { "node": ">=14" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/fs.realpath": { "version": "1.0.0", "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz", "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==", "dev": true }, "node_modules/fsevents": { "version": "2.3.3", "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz", "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==", "dev": true, "hasInstallScript": true, "optional": true, "os": [ "darwin" ], "engines": { "node": "^8.16.0 || ^10.6.0 || >=11.0.0" } }, "node_modules/functional-red-black-tree": { "version": "1.0.1", "resolved": "https://registry.npmjs.org/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz", "integrity": "sha512-dsKNQNdj6xA3T+QlADDA7mOSlX0qiMINjn0cgr+eGHGsbSHzTabcIogz2+p/iqP1Xs6EP/sS2SbqH+brGTbq0g==", "dev": true }, "node_modules/get-func-name": { "version": "2.0.2", "resolved": "https://registry.npmjs.org/get-func-name/-/get-func-name-2.0.2.tgz", "integrity": "sha512-8vXOvuE167CtIc3OyItco7N/dpRtBbYOsPsXCz7X/PMnlGjYjSGuZJgM1Y7mmew7BKf9BqvLX2tnOVy1BBUsxQ==", "dev": true, "engines": { "node": "*" } }, "node_modules/get-stream": { "version": "8.0.1", "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-8.0.1.tgz", "integrity": "sha512-VaUJspBffn/LMCJVoMvSAdmscJyS1auj5Zulnn5UoYcY531UWmdwhRWkcGKnGU93m5HSXP9LP2usOryrBtQowA==", "dev": true, "engines": { "node": ">=16" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/get-tsconfig": { "version": "4.8.1", "resolved": "https://registry.npmjs.org/get-tsconfig/-/get-tsconfig-4.8.1.tgz", "integrity": "sha512-k9PN+cFBmaLWtVz29SkUoqU5O0slLuHJXt/2P+tMVFT+phsSGXGkp9t3rQIqdz0e+06EHNGs3oM6ZX1s2zHxRg==", "dev": true, "dependencies": { "resolve-pkg-maps": "^1.0.0" }, "funding": { "url": "https://github.com/privatenumber/get-tsconfig?sponsor=1" } }, "node_modules/glob": { "version": "10.4.5", "resolved": "https://registry.npmjs.org/glob/-/glob-10.4.5.tgz", "integrity": "sha512-7Bv8RF0k6xjo7d4A/PxYLbUCfb6c+Vpd2/mB2yRDlew7Jb5hEXiCD9ibfO7wpk8i4sevK6DFny9h7EYbM3/sHg==", "dev": true, "dependencies": { "foreground-child": "^3.1.0", "jackspeak": "^3.1.2", "minimatch": "^9.0.4", "minipass": "^7.1.2", "package-json-from-dist": "^1.0.0", "path-scurry": "^1.11.1" }, "bin": { "glob": "dist/esm/bin.mjs" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/glob-parent": { "version": "5.1.2", "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz", "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==", "dev": true, "dependencies": { "is-glob": "^4.0.1" }, "engines": { "node": ">= 6" } }, "node_modules/glob/node_modules/brace-expansion": { "version": "2.0.1", "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz", "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==", "dev": true, "dependencies": { "balanced-match": "^1.0.0" } }, "node_modules/glob/node_modules/minimatch": { "version": "9.0.5", "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz", "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==", "dev": true, "dependencies": { "brace-expansion": "^2.0.1" }, "engines": { "node": ">=16 || 14 >=14.17" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/globals": { "version": "13.24.0", "resolved": "https://registry.npmjs.org/globals/-/globals-13.24.0.tgz", "integrity": "sha512-AhO5QUcj8llrbG09iWhPU2B204J1xnPeL8kQmVorSsy+Sjj1sk8gIyh6cUocGmH4L0UuhAJy+hJMRA4mgA4mFQ==", "dev": true, "dependencies": { "type-fest": "^0.20.2" }, "engines": { "node": ">=8" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/globby": { "version": "11.1.0", "resolved": "https://registry.npmjs.org/globby/-/globby-11.1.0.tgz", "integrity": "sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==", "dev": true, "dependencies": { "array-union": "^2.1.0", "dir-glob": "^3.0.1", "fast-glob": "^3.2.9", "ignore": "^5.2.0", "merge2": "^1.4.1", "slash": "^3.0.0" }, "engines": { "node": ">=10" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/has-flag": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz", "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/html-escaper": { "version": "2.0.2", "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz", "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==", "dev": true }, "node_modules/human-signals": { "version": "5.0.0", "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-5.0.0.tgz", "integrity": "sha512-AXcZb6vzzrFAUE61HnN4mpLqd/cSIwNQjtNWR0euPm6y0iqx3G4gOXaIDdtdDwZmhwe82LA6+zinmW4UBWVePQ==", "dev": true, "engines": { "node": ">=16.17.0" } }, "node_modules/ignore": { "version": "5.3.2", "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz", "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==", "dev": true, "engines": { "node": ">= 4" } }, "node_modules/import-fresh": { "version": "3.3.0", "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz", "integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==", "dev": true, "dependencies": { "parent-module": "^1.0.0", "resolve-from": "^4.0.0" }, "engines": { "node": ">=6" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/imurmurhash": { "version": "0.1.4", "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz", "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==", "dev": true, "engines": { "node": ">=0.8.19" } }, "node_modules/inflight": { "version": "1.0.6", "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz", "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==", "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.", "dev": true, "dependencies": { "once": "^1.3.0", "wrappy": "1" } }, "node_modules/inherits": { "version": "2.0.4", "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz", "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==", "dev": true }, "node_modules/is-extglob": { "version": "2.1.1", "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz", "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==", "dev": true, "engines": { "node": ">=0.10.0" } }, "node_modules/is-fullwidth-code-point": { "version": "3.0.0", "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz", "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/is-glob": { "version": "4.0.3", "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz", "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==", "dev": true, "dependencies": { "is-extglob": "^2.1.1" }, "engines": { "node": ">=0.10.0" } }, "node_modules/is-number": { "version": "7.0.0", "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz", "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==", "dev": true, "engines": { "node": ">=0.12.0" } }, "node_modules/is-stream": { "version": "3.0.0", "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-3.0.0.tgz", "integrity": "sha512-LnQR4bZ9IADDRSkvpqMGvt/tEJWclzklNgSw48V5EAaAeDd6qGvN8ei6k5p0tvxSR171VmGyHuTiAOfxAbr8kA==", "dev": true, "engines": { "node": "^12.20.0 || ^14.13.1 || >=16.0.0" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/isexe": { "version": "2.0.0", "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz", "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==", "dev": true }, "node_modules/istanbul-lib-coverage": { "version": "3.2.2", "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz", "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/istanbul-lib-report": { "version": "3.0.1", "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz", "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==", "dev": true, "dependencies": { "istanbul-lib-coverage": "^3.0.0", "make-dir": "^4.0.0", "supports-color": "^7.1.0" }, "engines": { "node": ">=10" } }, "node_modules/istanbul-lib-source-maps": { "version": "5.0.6", "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz", "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==", "dev": true, "dependencies": { "@jridgewell/trace-mapping": "^0.3.23", "debug": "^4.1.1", "istanbul-lib-coverage": "^3.0.0" }, "engines": { "node": ">=10" } }, "node_modules/istanbul-reports": { "version": "3.1.7", "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.1.7.tgz", "integrity": "sha512-BewmUXImeuRk2YY0PVbxgKAysvhRPUQE0h5QRM++nVWyubKGV0l8qQ5op8+B2DOmwSe63Jivj0BjkPQVf8fP5g==", "dev": true, "dependencies": { "html-escaper": "^2.0.0", "istanbul-lib-report": "^3.0.0" }, "engines": { "node": ">=8" } }, "node_modules/jackspeak": { "version": "3.4.3", "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz", "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==", "dev": true, "dependencies": { "@isaacs/cliui": "^8.0.2" }, "funding": { "url": "https://github.com/sponsors/isaacs" }, "optionalDependencies": { "@pkgjs/parseargs": "^0.11.0" } }, "node_modules/js-tokens": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz", "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==", "dev": true }, "node_modules/js-yaml": { "version": "3.14.1", "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-3.14.1.tgz", "integrity": "sha512-okMH7OXXJ7YrN9Ok3/SXrnu4iX9yOk+25nqX4imS2npuvTYDmo/QEZoqwZkYaIDk3jVvBOTOIEgEhaLOynBS9g==", "dev": true, "dependencies": { "argparse": "^1.0.7", "esprima": "^4.0.0" }, "bin": { "js-yaml": "bin/js-yaml.js" } }, "node_modules/json-buffer": { "version": "3.0.1", "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz", "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==", "dev": true }, "node_modules/json-schema-traverse": { "version": "0.4.1", "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz", "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==", "dev": true }, "node_modules/json-stable-stringify-without-jsonify": { "version": "1.0.1", "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz", "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==", "dev": true }, "node_modules/keyv": { "version": "4.5.4", "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz", "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==", "dev": true, "dependencies": { "json-buffer": "3.0.1" } }, "node_modules/levn": { "version": "0.4.1", "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz", "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==", "dev": true, "dependencies": { "prelude-ls": "^1.2.1", "type-check": "~0.4.0" }, "engines": { "node": ">= 0.8.0" } }, "node_modules/local-pkg": { "version": "0.5.1", "resolved": "https://registry.npmjs.org/local-pkg/-/local-pkg-0.5.1.tgz", "integrity": "sha512-9rrA30MRRP3gBD3HTGnC6cDFpaE1kVDWxWgqWJUN0RvDNAo+Nz/9GxB+nHOH0ifbVFy0hSA1V6vFDvnx54lTEQ==", "dev": true, "dependencies": { "mlly": "^1.7.3", "pkg-types": "^1.2.1" }, "engines": { "node": ">=14" }, "funding": { "url": "https://github.com/sponsors/antfu" } }, "node_modules/lodash.merge": { "version": "4.6.2", "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz", "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==", "dev": true }, "node_modules/lodash.truncate": { "version": "4.4.2", "resolved": "https://registry.npmjs.org/lodash.truncate/-/lodash.truncate-4.4.2.tgz", "integrity": "sha512-jttmRe7bRse52OsWIMDLaXxWqRAmtIUccAQ3garviCqJjafXOfNMO0yMfNpdD6zbGaTU0P5Nz7e7gAT6cKmJRw==", "dev": true }, "node_modules/loupe": { "version": "2.3.7", "resolved": "https://registry.npmjs.org/loupe/-/loupe-2.3.7.tgz", "integrity": "sha512-zSMINGVYkdpYSOBmLi0D1Uo7JU9nVdQKrHxC8eYlV+9YKK9WePqAlL7lSlorG/U2Fw1w0hTBmaa/jrQ3UbPHtA==", "dev": true, "dependencies": { "get-func-name": "^2.0.1" } }, "node_modules/lru-cache": { "version": "10.4.3", "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz", "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==", "dev": true }, "node_modules/magic-string": { "version": "0.30.17", "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.17.tgz", "integrity": "sha512-sNPKHvyjVf7gyjwS4xGTaW/mCnF8wnjtifKBEhxfZ7E/S8tQ0rssrwGNn6q8JH/ohItJfSQp9mBtQYuTlH5QnA==", "dev": true, "dependencies": { "@jridgewell/sourcemap-codec": "^1.5.0" } }, "node_modules/magicast": { "version": "0.3.5", "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz", "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==", "dev": true, "dependencies": { "@babel/parser": "^7.25.4", "@babel/types": "^7.25.4", "source-map-js": "^1.2.0" } }, "node_modules/make-dir": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz", "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==", "dev": true, "dependencies": { "semver": "^7.5.3" }, "engines": { "node": ">=10" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/merge-stream": { "version": "2.0.0", "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz", "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==", "dev": true }, "node_modules/merge2": { "version": "1.4.1", "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz", "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==", "dev": true, "engines": { "node": ">= 8" } }, "node_modules/micromatch": { "version": "4.0.8", "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz", "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==", "dev": true, "dependencies": { "braces": "^3.0.3", "picomatch": "^2.3.1" }, "engines": { "node": ">=8.6" } }, "node_modules/mimic-fn": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-4.0.0.tgz", "integrity": "sha512-vqiC06CuhBTUdZH+RYl8sFrL096vA45Ok5ISO6sE/Mr1jRbGH4Csnhi8f3wKVl7x8mO4Au7Ir9D3Oyv1VYMFJw==", "dev": true, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/minimatch": { "version": "3.1.2", "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz", "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==", "dev": true, "dependencies": { "brace-expansion": "^1.1.7" }, "engines": { "node": "*" } }, "node_modules/minipass": { "version": "7.1.2", "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz", "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==", "dev": true, "engines": { "node": ">=16 || 14 >=14.17" } }, "node_modules/mlly": { "version": "1.7.3", "resolved": "https://registry.npmjs.org/mlly/-/mlly-1.7.3.tgz", "integrity": "sha512-xUsx5n/mN0uQf4V548PKQ+YShA4/IW0KI1dZhrNrPCLG+xizETbHTkOa1f8/xut9JRPp8kQuMnz0oqwkTiLo/A==", "dev": true, "dependencies": { "acorn": "^8.14.0", "pathe": "^1.1.2", "pkg-types": "^1.2.1", "ufo": "^1.5.4" } }, "node_modules/mlly/node_modules/acorn": { "version": "8.14.0", "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.0.tgz", "integrity": "sha512-cl669nCJTZBsL97OF4kUQm5g5hC2uihk0NxY3WENAC0TYdILVkAyHymAntgxGkl7K+t0cXIrH5siy5S4XkFycA==", "dev": true, "bin": { "acorn": "bin/acorn" }, "engines": { "node": ">=0.4.0" } }, "node_modules/ms": { "version": "2.1.3", "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz", "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==", "dev": true }, "node_modules/nanoid": { "version": "3.3.8", "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.8.tgz", "integrity": "sha512-WNLf5Sd8oZxOm+TzppcYk8gVOgP+l58xNy58D0nbUnOxOWRWvlcCV4kUF7ltmI6PsrLl/BgKEyS4mqsGChFN0w==", "dev": true, "funding": [ { "type": "github", "url": "https://github.com/sponsors/ai" } ], "bin": { "nanoid": "bin/nanoid.cjs" }, "engines": { "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1" } }, "node_modules/natural-compare": { "version": "1.4.0", "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz", "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==", "dev": true }, "node_modules/npm-run-path": { "version": "5.3.0", "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-5.3.0.tgz", "integrity": "sha512-ppwTtiJZq0O/ai0z7yfudtBpWIoxM8yE6nHi1X47eFR2EWORqfbu6CnPlNsjeN683eT0qG6H/Pyf9fCcvjnnnQ==", "dev": true, "dependencies": { "path-key": "^4.0.0" }, "engines": { "node": "^12.20.0 || ^14.13.1 || >=16.0.0" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/npm-run-path/node_modules/path-key": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/path-key/-/path-key-4.0.0.tgz", "integrity": "sha512-haREypq7xkM7ErfgIyA0z+Bj4AGKlMSdlQE2jvJo6huWD1EdkKYV+G/T4nq0YEF2vgTT8kqMFKo1uHn950r4SQ==", "dev": true, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/once": { "version": "1.4.0", "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz", "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==", "dev": true, "dependencies": { "wrappy": "1" } }, "node_modules/onetime": { "version": "6.0.0", "resolved": "https://registry.npmjs.org/onetime/-/onetime-6.0.0.tgz", "integrity": "sha512-1FlR+gjXK7X+AsAHso35MnyN5KqGwJRi/31ft6x0M194ht7S+rWAvd7PHss9xSKMzE0asv1pyIHaJYq+BbacAQ==", "dev": true, "dependencies": { "mimic-fn": "^4.0.0" }, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/optionator": { "version": "0.9.4", "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz", "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==", "dev": true, "dependencies": { "deep-is": "^0.1.3", "fast-levenshtein": "^2.0.6", "levn": "^0.4.1", "prelude-ls": "^1.2.1", "type-check": "^0.4.0", "word-wrap": "^1.2.5" }, "engines": { "node": ">= 0.8.0" } }, "node_modules/p-limit": { "version": "5.0.0", "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-5.0.0.tgz", "integrity": "sha512-/Eaoq+QyLSiXQ4lyYV23f14mZRQcXnxfHrN0vCai+ak9G0pp9iEQukIIZq5NccEvwRB8PUnZT0KsOoDCINS1qQ==", "dev": true, "dependencies": { "yocto-queue": "^1.0.0" }, "engines": { "node": ">=18" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/package-json-from-dist": { "version": "1.0.1", "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz", "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==", "dev": true }, "node_modules/parent-module": { "version": "1.0.1", "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz", "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==", "dev": true, "dependencies": { "callsites": "^3.0.0" }, "engines": { "node": ">=6" } }, "node_modules/path-is-absolute": { "version": "1.0.1", "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz", "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==", "dev": true, "engines": { "node": ">=0.10.0" } }, "node_modules/path-key": { "version": "3.1.1", "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz", "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/path-scurry": { "version": "1.11.1", "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz", "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==", "dev": true, "dependencies": { "lru-cache": "^10.2.0", "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0" }, "engines": { "node": ">=16 || 14 >=14.18" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/path-type": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz", "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/pathe": { "version": "1.1.2", "resolved": "https://registry.npmjs.org/pathe/-/pathe-1.1.2.tgz", "integrity": "sha512-whLdWMYL2TwI08hn8/ZqAbrVemu0LNaNNJZX73O6qaIdCTfXutsLhMkjdENX0qhsQ9uIimo4/aQOmXkoon2nDQ==", "dev": true }, "node_modules/pathval": { "version": "1.1.1", "resolved": "https://registry.npmjs.org/pathval/-/pathval-1.1.1.tgz", "integrity": "sha512-Dp6zGqpTdETdR63lehJYPeIOqpiNBNtc7BpWSLrOje7UaIsE5aY92r/AunQA7rsXvet3lrJ3JnZX29UPTKXyKQ==", "dev": true, "engines": { "node": "*" } }, "node_modules/picocolors": { "version": "1.1.1", "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz", "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==", "dev": true }, "node_modules/picomatch": { "version": "2.3.1", "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz", "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==", "dev": true, "engines": { "node": ">=8.6" }, "funding": { "url": "https://github.com/sponsors/jonschlinkert" } }, "node_modules/pkg-types": { "version": "1.2.1", "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-1.2.1.tgz", "integrity": "sha512-sQoqa8alT3nHjGuTjuKgOnvjo4cljkufdtLMnO2LBP/wRwuDlo1tkaEdMxCRhyGRPacv/ztlZgDPm2b7FAmEvw==", "dev": true, "dependencies": { "confbox": "^0.1.8", "mlly": "^1.7.2", "pathe": "^1.1.2" } }, "node_modules/postcss": { "version": "8.4.49", "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.4.49.tgz", "integrity": "sha512-OCVPnIObs4N29kxTjzLfUryOkvZEq+pf8jTF0lg8E7uETuWHA+v7j3c/xJmiqpX450191LlmZfUKkXxkTry7nA==", "dev": true, "funding": [ { "type": "opencollective", "url": "https://opencollective.com/postcss/" }, { "type": "tidelift", "url": "https://tidelift.com/funding/github/npm/postcss" }, { "type": "github", "url": "https://github.com/sponsors/ai" } ], "dependencies": { "nanoid": "^3.3.7", "picocolors": "^1.1.1", "source-map-js": "^1.2.1" }, "engines": { "node": "^10 || ^12 || >=14" } }, "node_modules/prelude-ls": { "version": "1.2.1", "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz", "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==", "dev": true, "engines": { "node": ">= 0.8.0" } }, "node_modules/pretty-format": { "version": "29.7.0", "resolved": "https://registry.npmjs.org/pretty-format/-/pretty-format-29.7.0.tgz", "integrity": "sha512-Pdlw/oPxN+aXdmM9R00JVC9WVFoCLTKJvDVLgmJ+qAffBMxsV85l/Lu7sNx4zSzPyoL2euImuEwHhOXdEgNFZQ==", "dev": true, "dependencies": { "@jest/schemas": "^29.6.3", "ansi-styles": "^5.0.0", "react-is": "^18.0.0" }, "engines": { "node": "^14.15.0 || ^16.10.0 || >=18.0.0" } }, "node_modules/pretty-format/node_modules/ansi-styles": { "version": "5.2.0", "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-5.2.0.tgz", "integrity": "sha512-Cxwpt2SfTzTtXcfOlzGEee8O+c+MmUgGrNiBcXnuWxuFJHe6a5Hz7qwhwe5OgaSYI0IJvkLqWX1ASG+cJOkEiA==", "dev": true, "engines": { "node": ">=10" }, "funding": { "url": "https://github.com/chalk/ansi-styles?sponsor=1" } }, "node_modules/progress": { "version": "2.0.3", "resolved": "https://registry.npmjs.org/progress/-/progress-2.0.3.tgz", "integrity": "sha512-7PiHtLll5LdnKIMw100I+8xJXR5gW2QwWYkT6iJva0bXitZKa/XMrSbdmg3r2Xnaidz9Qumd0VPaMrZlF9V9sA==", "dev": true, "engines": { "node": ">=0.4.0" } }, "node_modules/punycode": { "version": "2.3.1", "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz", "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==", "dev": true, "engines": { "node": ">=6" } }, "node_modules/queue-microtask": { "version": "1.2.3", "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz", "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==", "dev": true, "funding": [ { "type": "github", "url": "https://github.com/sponsors/feross" }, { "type": "patreon", "url": "https://www.patreon.com/feross" }, { "type": "consulting", "url": "https://feross.org/support" } ] }, "node_modules/react-is": { "version": "18.3.1", "resolved": "https://registry.npmjs.org/react-is/-/react-is-18.3.1.tgz", "integrity": "sha512-/LLMVyas0ljjAtoYiPqYiL8VWXzUUdThrmU5+n20DZv+a+ClRoevUzw5JxU+Ieh5/c87ytoTBV9G1FiKfNJdmg==", "dev": true }, "node_modules/regexpp": { "version": "3.2.0", "resolved": "https://registry.npmjs.org/regexpp/-/regexpp-3.2.0.tgz", "integrity": "sha512-pq2bWo9mVD43nbts2wGv17XLiNLya+GklZ8kaDLV2Z08gDCsGpnKn9BFMepvWuHCbyVvY7J5o5+BVvoQbmlJLg==", "dev": true, "engines": { "node": ">=8" }, "funding": { "url": "https://github.com/sponsors/mysticatea" } }, "node_modules/require-from-string": { "version": "2.0.2", "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz", "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==", "dev": true, "engines": { "node": ">=0.10.0" } }, "node_modules/resolve-from": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz", "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==", "dev": true, "engines": { "node": ">=4" } }, "node_modules/resolve-pkg-maps": { "version": "1.0.0", "resolved": "https://registry.npmjs.org/resolve-pkg-maps/-/resolve-pkg-maps-1.0.0.tgz", "integrity": "sha512-seS2Tj26TBVOC2NIc2rOe2y2ZO7efxITtLZcGSOnHHNOQ7CkiUBfw0Iw2ck6xkIhPwLhKNLS8BO+hEpngQlqzw==", "dev": true, "funding": { "url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1" } }, "node_modules/reusify": { "version": "1.0.4", "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz", "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==", "dev": true, "engines": { "iojs": ">=1.0.0", "node": ">=0.10.0" } }, "node_modules/rimraf": { "version": "5.0.10", "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-5.0.10.tgz", "integrity": "sha512-l0OE8wL34P4nJH/H2ffoaniAokM2qSmrtXHmlpvYr5AVVX8msAyW0l8NVJFDxlSK4u3Uh/f41cQheDVdnYijwQ==", "dev": true, "dependencies": { "glob": "^10.3.7" }, "bin": { "rimraf": "dist/esm/bin.mjs" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/rollup": { "version": "4.29.1", "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.29.1.tgz", "integrity": "sha512-RaJ45M/kmJUzSWDs1Nnd5DdV4eerC98idtUOVr6FfKcgxqvjwHmxc5upLF9qZU9EpsVzzhleFahrT3shLuJzIw==", "dev": true, "dependencies": { "@types/estree": "1.0.6" }, "bin": { "rollup": "dist/bin/rollup" }, "engines": { "node": ">=18.0.0", "npm": ">=8.0.0" }, "optionalDependencies": { "@rollup/rollup-android-arm-eabi": "4.29.1", "@rollup/rollup-android-arm64": "4.29.1", "@rollup/rollup-darwin-arm64": "4.29.1", "@rollup/rollup-darwin-x64": "4.29.1", "@rollup/rollup-freebsd-arm64": "4.29.1", "@rollup/rollup-freebsd-x64": "4.29.1", "@rollup/rollup-linux-arm-gnueabihf": "4.29.1", "@rollup/rollup-linux-arm-musleabihf": "4.29.1", "@rollup/rollup-linux-arm64-gnu": "4.29.1", "@rollup/rollup-linux-arm64-musl": "4.29.1", "@rollup/rollup-linux-loongarch64-gnu": "4.29.1", "@rollup/rollup-linux-powerpc64le-gnu": "4.29.1", "@rollup/rollup-linux-riscv64-gnu": "4.29.1", "@rollup/rollup-linux-s390x-gnu": "4.29.1", "@rollup/rollup-linux-x64-gnu": "4.29.1", "@rollup/rollup-linux-x64-musl": "4.29.1", "@rollup/rollup-win32-arm64-msvc": "4.29.1", "@rollup/rollup-win32-ia32-msvc": "4.29.1", "@rollup/rollup-win32-x64-msvc": "4.29.1", "fsevents": "~2.3.2" } }, "node_modules/run-parallel": { "version": "1.2.0", "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz", "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==", "dev": true, "funding": [ { "type": "github", "url": "https://github.com/sponsors/feross" }, { "type": "patreon", "url": "https://www.patreon.com/feross" }, { "type": "consulting", "url": "https://feross.org/support" } ], "dependencies": { "queue-microtask": "^1.2.2" } }, "node_modules/semver": { "version": "7.6.3", "resolved": "https://registry.npmjs.org/semver/-/semver-7.6.3.tgz", "integrity": "sha512-oVekP1cKtI+CTDvHWYFUcMtsK/00wmAEfyqKfNdARm8u1wNVhSgaX7A8d4UuIlUI5e84iEwOhs7ZPYRmzU9U6A==", "dev": true, "bin": { "semver": "bin/semver.js" }, "engines": { "node": ">=10" } }, "node_modules/shebang-command": { "version": "2.0.0", "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz", "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==", "dev": true, "dependencies": { "shebang-regex": "^3.0.0" }, "engines": { "node": ">=8" } }, "node_modules/shebang-regex": { "version": "3.0.0", "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz", "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/siginfo": { "version": "2.0.0", "resolved": "https://registry.npmjs.org/siginfo/-/siginfo-2.0.0.tgz", "integrity": "sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==", "dev": true }, "node_modules/signal-exit": { "version": "4.1.0", "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz", "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==", "dev": true, "engines": { "node": ">=14" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/slash": { "version": "3.0.0", "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz", "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==", "dev": true, "engines": { "node": ">=8" } }, "node_modules/slice-ansi": { "version": "4.0.0", "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz", "integrity": "sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==", "dev": true, "dependencies": { "ansi-styles": "^4.0.0", "astral-regex": "^2.0.0", "is-fullwidth-code-point": "^3.0.0" }, "engines": { "node": ">=10" }, "funding": { "url": "https://github.com/chalk/slice-ansi?sponsor=1" } }, "node_modules/source-map-js": { "version": "1.2.1", "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz", "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==", "dev": true, "engines": { "node": ">=0.10.0" } }, "node_modules/sprintf-js": { "version": "1.0.3", "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.0.3.tgz", "integrity": "sha512-D9cPgkvLlV3t3IzL0D0YLvGA9Ahk4PcvVwUbN0dSGr1aP0Nrt4AEnTUbuGvquEC0mA64Gqt1fzirlRs5ibXx8g==", "dev": true }, "node_modules/stackback": { "version": "0.0.2", "resolved": "https://registry.npmjs.org/stackback/-/stackback-0.0.2.tgz", "integrity": "sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==", "dev": true }, "node_modules/std-env": { "version": "3.8.0", "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.8.0.tgz", "integrity": "sha512-Bc3YwwCB+OzldMxOXJIIvC6cPRWr/LxOp48CdQTOkPyk/t4JWWJbrilwBd7RJzKV8QW7tJkcgAmeuLLJugl5/w==", "dev": true }, "node_modules/string-width": { "version": "5.1.2", "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz", "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==", "dev": true, "dependencies": { "eastasianwidth": "^0.2.0", "emoji-regex": "^9.2.2", "strip-ansi": "^7.0.1" }, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/string-width-cjs": { "name": "string-width", "version": "4.2.3", "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz", "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==", "dev": true, "dependencies": { "emoji-regex": "^8.0.0", "is-fullwidth-code-point": "^3.0.0", "strip-ansi": "^6.0.1" }, "engines": { "node": ">=8" } }, "node_modules/string-width-cjs/node_modules/emoji-regex": { "version": "8.0.0", "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz", "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==", "dev": true }, "node_modules/string-width/node_modules/ansi-regex": { "version": "6.1.0", "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz", "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==", "dev": true, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/chalk/ansi-regex?sponsor=1" } }, "node_modules/string-width/node_modules/strip-ansi": { "version": "7.1.0", "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz", "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==", "dev": true, "dependencies": { "ansi-regex": "^6.0.1" }, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/chalk/strip-ansi?sponsor=1" } }, "node_modules/strip-ansi": { "version": "6.0.1", "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz", "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==", "dev": true, "dependencies": { "ansi-regex": "^5.0.1" }, "engines": { "node": ">=8" } }, "node_modules/strip-ansi-cjs": { "name": "strip-ansi", "version": "6.0.1", "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz", "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==", "dev": true, "dependencies": { "ansi-regex": "^5.0.1" }, "engines": { "node": ">=8" } }, "node_modules/strip-final-newline": { "version": "3.0.0", "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-3.0.0.tgz", "integrity": "sha512-dOESqjYr96iWYylGObzd39EuNTa5VJxyvVAEm5Jnh7KGo75V43Hk1odPQkNDyXNmUR6k+gEiDVXnjB8HJ3crXw==", "dev": true, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/strip-json-comments": { "version": "3.1.1", "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz", "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==", "dev": true, "engines": { "node": ">=8" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/strip-literal": { "version": "2.1.1", "resolved": "https://registry.npmjs.org/strip-literal/-/strip-literal-2.1.1.tgz", "integrity": "sha512-631UJ6O00eNGfMiWG78ck80dfBab8X6IVFB51jZK5Icd7XAs60Z5y7QdSd/wGIklnWvRbUNloVzhOKKmutxQ6Q==", "dev": true, "dependencies": { "js-tokens": "^9.0.1" }, "funding": { "url": "https://github.com/sponsors/antfu" } }, "node_modules/strip-literal/node_modules/js-tokens": { "version": "9.0.1", "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-9.0.1.tgz", "integrity": "sha512-mxa9E9ITFOt0ban3j6L5MpjwegGz6lBQmM1IJkWeBZGcMxto50+eWdjC/52xDbS2vy0k7vIMK0Fe2wfL9OQSpQ==", "dev": true }, "node_modules/supports-color": { "version": "7.2.0", "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz", "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==", "dev": true, "dependencies": { "has-flag": "^4.0.0" }, "engines": { "node": ">=8" } }, "node_modules/table": { "version": "6.9.0", "resolved": "https://registry.npmjs.org/table/-/table-6.9.0.tgz", "integrity": "sha512-9kY+CygyYM6j02t5YFHbNz2FN5QmYGv9zAjVp4lCDjlCw7amdckXlEt/bjMhUIfj4ThGRE4gCUH5+yGnNuPo5A==", "dev": true, "dependencies": { "ajv": "^8.0.1", "lodash.truncate": "^4.4.2", "slice-ansi": "^4.0.0", "string-width": "^4.2.3", "strip-ansi": "^6.0.1" }, "engines": { "node": ">=10.0.0" } }, "node_modules/table/node_modules/ajv": { "version": "8.17.1", "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.17.1.tgz", "integrity": "sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==", "dev": true, "dependencies": { "fast-deep-equal": "^3.1.3", "fast-uri": "^3.0.1", "json-schema-traverse": "^1.0.0", "require-from-string": "^2.0.2" }, "funding": { "type": "github", "url": "https://github.com/sponsors/epoberezkin" } }, "node_modules/table/node_modules/emoji-regex": { "version": "8.0.0", "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz", "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==", "dev": true }, "node_modules/table/node_modules/json-schema-traverse": { "version": "1.0.0", "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz", "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==", "dev": true }, "node_modules/table/node_modules/string-width": { "version": "4.2.3", "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz", "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==", "dev": true, "dependencies": { "emoji-regex": "^8.0.0", "is-fullwidth-code-point": "^3.0.0", "strip-ansi": "^6.0.1" }, "engines": { "node": ">=8" } }, "node_modules/test-exclude": { "version": "6.0.0", "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-6.0.0.tgz", "integrity": "sha512-cAGWPIyOHU6zlmg88jwm7VRyXnMN7iV68OGAbYDk/Mh/xC/pzVPlQtY6ngoIH/5/tciuhGfvESU8GrHrcxD56w==", "dev": true, "dependencies": { "@istanbuljs/schema": "^0.1.2", "glob": "^7.1.4", "minimatch": "^3.0.4" }, "engines": { "node": ">=8" } }, "node_modules/test-exclude/node_modules/glob": { "version": "7.2.3", "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz", "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==", "deprecated": "Glob versions prior to v9 are no longer supported", "dev": true, "dependencies": { "fs.realpath": "^1.0.0", "inflight": "^1.0.4", "inherits": "2", "minimatch": "^3.1.1", "once": "^1.3.0", "path-is-absolute": "^1.0.0" }, "engines": { "node": "*" }, "funding": { "url": "https://github.com/sponsors/isaacs" } }, "node_modules/text-table": { "version": "0.2.0", "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz", "integrity": "sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==", "dev": true }, "node_modules/tinybench": { "version": "2.9.0", "resolved": "https://registry.npmjs.org/tinybench/-/tinybench-2.9.0.tgz", "integrity": "sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==", "dev": true }, "node_modules/tinypool": { "version": "0.8.4", "resolved": "https://registry.npmjs.org/tinypool/-/tinypool-0.8.4.tgz", "integrity": "sha512-i11VH5gS6IFeLY3gMBQ00/MmLncVP7JLXOw1vlgkytLmJK7QnEr7NXf0LBdxfmNPAeyetukOk0bOYrJrFGjYJQ==", "dev": true, "engines": { "node": ">=14.0.0" } }, "node_modules/tinyspy": { "version": "2.2.1", "resolved": "https://registry.npmjs.org/tinyspy/-/tinyspy-2.2.1.tgz", "integrity": "sha512-KYad6Vy5VDWV4GH3fjpseMQ/XU2BhIYP7Vzd0LG44qRWm/Yt2WCOTicFdvmgo6gWaqooMQCawTtILVQJupKu7A==", "dev": true, "engines": { "node": ">=14.0.0" } }, "node_modules/to-regex-range": { "version": "5.0.1", "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz", "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==", "dev": true, "dependencies": { "is-number": "^7.0.0" }, "engines": { "node": ">=8.0" } }, "node_modules/tslib": { "version": "2.8.1", "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz", "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==", "dev": true }, "node_modules/tsutils": { "version": "3.21.0", "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz", "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==", "dev": true, "dependencies": { "tslib": "^1.8.1" }, "engines": { "node": ">= 6" }, "peerDependencies": { "typescript": ">=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta" } }, "node_modules/tsutils/node_modules/tslib": { "version": "1.14.1", "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz", "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==", "dev": true }, "node_modules/tsx": { "version": "4.19.2", "resolved": "https://registry.npmjs.org/tsx/-/tsx-4.19.2.tgz", "integrity": "sha512-pOUl6Vo2LUq/bSa8S5q7b91cgNSjctn9ugq/+Mvow99qW6x/UZYwzxy/3NmqoT66eHYfCVvFvACC58UBPFf28g==", "dev": true, "dependencies": { "esbuild": "~0.23.0", "get-tsconfig": "^4.7.5" }, "bin": { "tsx": "dist/cli.mjs" }, "engines": { "node": ">=18.0.0" }, "optionalDependencies": { "fsevents": "~2.3.3" } }, "node_modules/type-check": { "version": "0.4.0", "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz", "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==", "dev": true, "dependencies": { "prelude-ls": "^1.2.1" }, "engines": { "node": ">= 0.8.0" } }, "node_modules/type-detect": { "version": "4.1.0", "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.1.0.tgz", "integrity": "sha512-Acylog8/luQ8L7il+geoSxhEkazvkslg7PSNKOX59mbB9cOveP5aq9h74Y7YU8yDpJwetzQQrfIwtf4Wp4LKcw==", "dev": true, "engines": { "node": ">=4" } }, "node_modules/type-fest": { "version": "0.20.2", "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz", "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==", "dev": true, "engines": { "node": ">=10" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } }, "node_modules/typescript": { "version": "4.9.5", "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.9.5.tgz", "integrity": "sha512-1FXk9E2Hm+QzZQ7z+McJiHL4NW1F2EzMu9Nq9i3zAaGqibafqYwCVU6WyWAuyQRRzOlxou8xZSyXLEN8oKj24g==", "bin": { "tsc": "bin/tsc", "tsserver": "bin/tsserver" }, "engines": { "node": ">=4.2.0" } }, "node_modules/ufo": { "version": "1.5.4", "resolved": "https://registry.npmjs.org/ufo/-/ufo-1.5.4.tgz", "integrity": "sha512-UsUk3byDzKd04EyoZ7U4DOlxQaD14JUKQl6/P7wiX4FNvUfm3XL246n9W5AmqwW5RSFJ27NAuM0iLscAOYUiGQ==", "dev": true }, "node_modules/uri-js": { "version": "4.4.1", "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz", "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==", "dev": true, "dependencies": { "punycode": "^2.1.0" } }, "node_modules/v8-compile-cache": { "version": "2.4.0", "resolved": "https://registry.npmjs.org/v8-compile-cache/-/v8-compile-cache-2.4.0.tgz", "integrity": "sha512-ocyWc3bAHBB/guyqJQVI5o4BZkPhznPYUG2ea80Gond/BgNWpap8TOmLSeeQG7bnh2KMISxskdADG59j7zruhw==", "dev": true }, "node_modules/vite": { "version": "5.4.11", "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.11.tgz", "integrity": "sha512-c7jFQRklXua0mTzneGW9QVyxFjUgwcihC4bXEtujIo2ouWCe1Ajt/amn2PCxYnhYfd5k09JX3SB7OYWFKYqj8Q==", "dev": true, "dependencies": { "esbuild": "^0.21.3", "postcss": "^8.4.43", "rollup": "^4.20.0" }, "bin": { "vite": "bin/vite.js" }, "engines": { "node": "^18.0.0 || >=20.0.0" }, "funding": { "url": "https://github.com/vitejs/vite?sponsor=1" }, "optionalDependencies": { "fsevents": "~2.3.3" }, "peerDependencies": { "@types/node": "^18.0.0 || >=20.0.0", "less": "*", "lightningcss": "^1.21.0", "sass": "*", "sass-embedded": "*", "stylus": "*", "sugarss": "*", "terser": "^5.4.0" }, "peerDependenciesMeta": { "@types/node": { "optional": true }, "less": { "optional": true }, "lightningcss": { "optional": true }, "sass": { "optional": true }, "sass-embedded": { "optional": true }, "stylus": { "optional": true }, "sugarss": { "optional": true }, "terser": { "optional": true } } }, "node_modules/vite-node": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/vite-node/-/vite-node-1.6.0.tgz", "integrity": "sha512-de6HJgzC+TFzOu0NTC4RAIsyf/DY/ibWDYQUcuEA84EMHhcefTUGkjFHKKEJhQN4A+6I0u++kr3l36ZF2d7XRw==", "dev": true, "dependencies": { "cac": "^6.7.14", "debug": "^4.3.4", "pathe": "^1.1.1", "picocolors": "^1.0.0", "vite": "^5.0.0" }, "bin": { "vite-node": "vite-node.mjs" }, "engines": { "node": "^18.0.0 || >=20.0.0" }, "funding": { "url": "https://opencollective.com/vitest" } }, "node_modules/vite/node_modules/@esbuild/aix-ppc64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz", "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==", "cpu": [ "ppc64" ], "dev": true, "optional": true, "os": [ "aix" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/android-arm": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz", "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==", "cpu": [ "arm" ], "dev": true, "optional": true, "os": [ "android" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/android-arm64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz", "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "android" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/android-x64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz", "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "android" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/darwin-arm64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz", "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "darwin" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/darwin-x64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz", "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "darwin" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/freebsd-arm64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz", "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "freebsd" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/freebsd-x64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz", "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "freebsd" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-arm": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz", "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==", "cpu": [ "arm" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-arm64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz", "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-ia32": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz", "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==", "cpu": [ "ia32" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-loong64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz", "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==", "cpu": [ "loong64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-mips64el": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz", "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==", "cpu": [ "mips64el" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-ppc64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz", "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==", "cpu": [ "ppc64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-riscv64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz", "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==", "cpu": [ "riscv64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-s390x": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz", "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==", "cpu": [ "s390x" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/linux-x64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz", "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "linux" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/netbsd-x64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz", "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "netbsd" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/openbsd-x64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz", "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "openbsd" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/sunos-x64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz", "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "sunos" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/win32-arm64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz", "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==", "cpu": [ "arm64" ], "dev": true, "optional": true, "os": [ "win32" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/win32-ia32": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz", "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==", "cpu": [ "ia32" ], "dev": true, "optional": true, "os": [ "win32" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/@esbuild/win32-x64": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz", "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==", "cpu": [ "x64" ], "dev": true, "optional": true, "os": [ "win32" ], "engines": { "node": ">=12" } }, "node_modules/vite/node_modules/esbuild": { "version": "0.21.5", "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz", "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==", "dev": true, "hasInstallScript": true, "bin": { "esbuild": "bin/esbuild" }, "engines": { "node": ">=12" }, "optionalDependencies": { "@esbuild/aix-ppc64": "0.21.5", "@esbuild/android-arm": "0.21.5", "@esbuild/android-arm64": "0.21.5", "@esbuild/android-x64": "0.21.5", "@esbuild/darwin-arm64": "0.21.5", "@esbuild/darwin-x64": "0.21.5", "@esbuild/freebsd-arm64": "0.21.5", "@esbuild/freebsd-x64": "0.21.5", "@esbuild/linux-arm": "0.21.5", "@esbuild/linux-arm64": "0.21.5", "@esbuild/linux-ia32": "0.21.5", "@esbuild/linux-loong64": "0.21.5", "@esbuild/linux-mips64el": "0.21.5", "@esbuild/linux-ppc64": "0.21.5", "@esbuild/linux-riscv64": "0.21.5", "@esbuild/linux-s390x": "0.21.5", "@esbuild/linux-x64": "0.21.5", "@esbuild/netbsd-x64": "0.21.5", "@esbuild/openbsd-x64": "0.21.5", "@esbuild/sunos-x64": "0.21.5", "@esbuild/win32-arm64": "0.21.5", "@esbuild/win32-ia32": "0.21.5", "@esbuild/win32-x64": "0.21.5" } }, "node_modules/vitest": { "version": "1.6.0", "resolved": "https://registry.npmjs.org/vitest/-/vitest-1.6.0.tgz", "integrity": "sha512-H5r/dN06swuFnzNFhq/dnz37bPXnq8xB2xB5JOVk8K09rUtoeNN+LHWkoQ0A/i3hvbUKKcCei9KpbxqHMLhLLA==", "dev": true, "dependencies": { "@vitest/expect": "1.6.0", "@vitest/runner": "1.6.0", "@vitest/snapshot": "1.6.0", "@vitest/spy": "1.6.0", "@vitest/utils": "1.6.0", "acorn-walk": "^8.3.2", "chai": "^4.3.10", "debug": "^4.3.4", "execa": "^8.0.1", "local-pkg": "^0.5.0", "magic-string": "^0.30.5", "pathe": "^1.1.1", "picocolors": "^1.0.0", "std-env": "^3.5.0", "strip-literal": "^2.0.0", "tinybench": "^2.5.1", "tinypool": "^0.8.3", "vite": "^5.0.0", "vite-node": "1.6.0", "why-is-node-running": "^2.2.2" }, "bin": { "vitest": "vitest.mjs" }, "engines": { "node": "^18.0.0 || >=20.0.0" }, "funding": { "url": "https://opencollective.com/vitest" }, "peerDependencies": { "@edge-runtime/vm": "*", "@types/node": "^18.0.0 || >=20.0.0", "@vitest/browser": "1.6.0", "@vitest/ui": "1.6.0", "happy-dom": "*", "jsdom": "*" }, "peerDependenciesMeta": { "@edge-runtime/vm": { "optional": true }, "@types/node": { "optional": true }, "@vitest/browser": { "optional": true }, "@vitest/ui": { "optional": true }, "happy-dom": { "optional": true }, "jsdom": { "optional": true } } }, "node_modules/which": { "version": "2.0.2", "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz", "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==", "dev": true, "dependencies": { "isexe": "^2.0.0" }, "bin": { "node-which": "bin/node-which" }, "engines": { "node": ">= 8" } }, "node_modules/why-is-node-running": { "version": "2.3.0", "resolved": "https://registry.npmjs.org/why-is-node-running/-/why-is-node-running-2.3.0.tgz", "integrity": "sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==", "dev": true, "dependencies": { "siginfo": "^2.0.0", "stackback": "0.0.2" }, "bin": { "why-is-node-running": "cli.js" }, "engines": { "node": ">=8" } }, "node_modules/word-wrap": { "version": "1.2.5", "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz", "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==", "dev": true, "engines": { "node": ">=0.10.0" } }, "node_modules/wrap-ansi": { "version": "8.1.0", "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz", "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==", "dev": true, "dependencies": { "ansi-styles": "^6.1.0", "string-width": "^5.0.1", "strip-ansi": "^7.0.1" }, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/chalk/wrap-ansi?sponsor=1" } }, "node_modules/wrap-ansi-cjs": { "name": "wrap-ansi", "version": "7.0.0", "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz", "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==", "dev": true, "dependencies": { "ansi-styles": "^4.0.0", "string-width": "^4.1.0", "strip-ansi": "^6.0.0" }, "engines": { "node": ">=10" }, "funding": { "url": "https://github.com/chalk/wrap-ansi?sponsor=1" } }, "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": { "version": "8.0.0", "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz", "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==", "dev": true }, "node_modules/wrap-ansi-cjs/node_modules/string-width": { "version": "4.2.3", "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz", "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==", "dev": true, "dependencies": { "emoji-regex": "^8.0.0", "is-fullwidth-code-point": "^3.0.0", "strip-ansi": "^6.0.1" }, "engines": { "node": ">=8" } }, "node_modules/wrap-ansi/node_modules/ansi-regex": { "version": "6.1.0", "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz", "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==", "dev": true, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/chalk/ansi-regex?sponsor=1" } }, "node_modules/wrap-ansi/node_modules/ansi-styles": { "version": "6.2.1", "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.1.tgz", "integrity": "sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==", "dev": true, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/chalk/ansi-styles?sponsor=1" } }, "node_modules/wrap-ansi/node_modules/strip-ansi": { "version": "7.1.0", "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz", "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==", "dev": true, "dependencies": { "ansi-regex": "^6.0.1" }, "engines": { "node": ">=12" }, "funding": { "url": "https://github.com/chalk/strip-ansi?sponsor=1" } }, "node_modules/wrappy": { "version": "1.0.2", "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz", "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==", "dev": true }, "node_modules/yocto-queue": { "version": "1.1.1", "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-1.1.1.tgz", "integrity": "sha512-b4JR1PFR10y1mKjhHY9LaGo6tmrgjit7hxVIeAmyMw3jegXR4dhYqLaQF5zMXZxY7tLpMyJeLjr1C4rLmkVe8g==", "dev": true, "engines": { "node": ">=12.20" }, "funding": { "url": "https://github.com/sponsors/sindresorhus" } } } }
--- package.json: { "type": "module", "name": "@dvanauken/sphere", "version": "0.1.0-alpha.1007", "main": "./dist/src/index.js", "module": "./dist/src/index.js", "types": "./dist/src/index.d.ts", "exports": { ".": { "types": "./dist/src/index.d.ts", "import": "./dist/src/index.js", "default": "./dist/src/index.js" } }, "scripts": { "clean": "rimraf dist", "prebuild": "npm run clean && git add . && (git commit -m \"Pre-release commit\" || exit 0)", "build": "tsc", "start": "node dist/src/index.js", "test": "vitest run", "test:watch": "vitest", "test:coverage": "vitest run --coverage", "version:bump": "npm version prerelease --preid=alpha", "release": "npm run prebuild && npm run build && npm run version:bump && npm publish --tag latest" }, "repository": { "type": "git", "url": "git+https://github.com/dvanauken/sphere.git" }, "files": [ "dist/src/**/*.js", "dist/src/**/*.d.ts", "README.md", "package.json", "LICENSE" ], "publishConfig": { "access": "public", "registry": "https://registry.npmjs.org/" }, "dependencies": { "typescript": "^4.5.2" }, "peerDependencies": { "@angular/core": "^16.2.0", "tslib": "^2.3.0" }, "peerDependenciesMeta": { "@angular/core": { "optional": true } }, "devDependencies": { "@typescript-eslint/eslint-plugin": "^4.33.0", "@typescript-eslint/parser": "^4.33.0", "@vitest/coverage-v8": "^1.6.0", "eslint": "^7.32.0", "rimraf": "^5.0.0", "tsx": "^4.19.2", "vitest": "^1.6.0", "tslib": "^2.5.2" }, "keywords": [ "typescript", "geometry", "geospatial", "spherical-geometry", "navigation" ], "sideEffects": false, "author": "dvanauken", "license": "Proprietary" }
--- tsconfig.json: { "compilerOptions": { "target": "ES2022", "module": "ES2022", "moduleResolution": "NodeNext", "esModuleInterop": true, "strict": true, "skipLibCheck": true, "forceConsistentCasingInFileNames": true, "rootDir": "./src", // or keep "." if you want, see note below "outDir": "./dist", // These are optional but commonly used "declaration": true, "sourceMap": false, "declarationMap": false, // If you have importHelpers=true, remember to install 'tslib' "importHelpers": true }, "include": ["src"], "exclude": ["node_modules", "dist", "test"] }
--- vitest.config.ts: import { defineConfig } from 'vitest/config' export default defineConfig({ test: { globals: true, environment: 'node', include: ['test/**/*.test.ts'], coverage: { provider: 'v8', reporter: ['text', 'json', 'html'], }, testTimeout: 20000, hookTimeout: 20000, teardownTimeout: 1000, } })
