+-- .gitignore
+-- New Text Document.txt
+-- README.md
+-- benchmarks
|   -- README.md
+-- docs
|   -- README.md
+-- examples
|   -- README.md
+-- package-lock.json
+-- package.json
+-- reorganize.bat
+-- scripts
|   -- README.md
+-- src
|   +-- adapters
|   |   -- geojson
|   |      +-- Feature.ts: // Feature.ts import { GeometryCollection } from "./GeometryCollection"; import { LineString } from "./LineString"; import { MultiLineString } from "./MultiLineString"; import { MultiPoint } from "./MultiPoint"; import { MultiPolygon } from "./MultiPolygon"; import { Point } from "./Point"; import { Polygon } from "./Polygon";  export interface Feature {   type: "Feature";   geometry: GeometryCollection | Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon;   properties: { [key: string]: any }; } 
|   |      +-- FeatureCollection.ts: // FeatureCollection.ts import { Feature } from "./Feature";  export interface FeatureCollection {   type: "FeatureCollection";   features: Feature[]; } 
|   |      +-- GeoConversionError.ts: import { Feature } from "./Feature";  export class GeoConversionError extends Error {   constructor(       message: string,       public readonly sourceType?: string,       public readonly targetType?: string,       public readonly cause?: Error   ) {       super(message);       this.name = 'GeoConversionError';   } }  // Add validation and error handling to existing classes: export class TypeValidator {   static validateFeature(feature: Feature): void {       if (!feature.type || feature.type !== 'Feature') {           throw new GeoConversionError('Invalid Feature type');       }       if (!feature.geometry) {           throw new GeoConversionError('Missing geometry');       }       // Add more validation   }    static validateGeometry(geometry: any): void {       // Geometry validation   } }
|   |      +-- GeoConverter.ts: import { Feature } from "./Feature"; import { GeoReader } from "./GeoReader"; import { GeoWriter } from "./GeoWriter";  export class GeoConverter {   static toGeoJSON(input: any): Feature | Feature[] {       if (Array.isArray(input)) {           return GeoWriter.writeCollection(input);       }       return GeoWriter.write(input);   }    static fromGeoJSON(input: Feature | Feature[]): any {       if (Array.isArray(input)) {           return GeoReader.readCollection(input);       }       return GeoReader.read(input);   } }  /* Example usage: const feature = GeoConverter.toGeoJSON(greatCircle); const circle = GeoConverter.fromGeoJSON(feature); */
|   |      +-- GeoReader.ts: import { Feature } from "./Feature"; import { GeoRegistry } from "./GeoRegistry";  export class GeoReader {   static read(feature: Feature): any {       return GeoRegistry.reverse(feature);   }    static readCollection(collection: Feature[]): any[] {       return collection.map(f => GeoReader.read(f));   } }  
|   |      +-- GeoRegistry.ts: import { TypeConverter } from './TypeConverter'; import { TypeMapping } from './TypeMapping'; import { Feature } from './Feature';  export class GeoRegistry {     private static readonly converters = new Map<string, TypeConverter>();      static register(type: any, converter: TypeConverter): void {         const geoType = TypeMapping.get(type);         if (!geoType) throw new Error(`No mapping for type ${type.name}`);         GeoRegistry.converters.set(type.name, converter);     }      static convert(source: any, target: string): any {         const converter = GeoRegistry.converters.get(source.constructor.name);         if (!converter) throw new Error(`No converter for ${source.constructor.name}`);         return TypeConverter.toFeature(source);     }      static reverse(feature: Feature): any {         return TypeConverter.fromFeature(feature);     } }
|   |      +-- GeoWriter.ts: import { Feature } from "./Feature"; import { GeoRegistry } from "./GeoRegistry";  export class GeoWriter {   static write(source: any): Feature {       return GeoRegistry.convert(source, 'Feature');   }    static writeCollection(sources: any[]): Feature[] {       return sources.map(s => GeoWriter.write(s));   } }
|   |      +-- GeometryCollection.ts: import { LineString } from "./LineString"; import { MultiLineString } from "./MultiLineString"; import { MultiPoint } from "./MultiPoint"; import { MultiPolygon } from "./MultiPolygon"; import { Point } from "./Point"; import { Polygon } from "./Polygon";  // GeometryCollection.ts export interface GeometryCollection {   type: "GeometryCollection";   geometries: Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection>; } 
|   |      +-- LineString.ts: // LineString.ts import { Point } from "./Point";  export interface LineString {   type: "LineString";   coordinates: Point['coordinates'][]; } 
|   |      +-- MultiLineString.ts: // MultiLineString.ts import { LineString } from "./LineString";  export interface MultiLineString {   type: "MultiLineString";   coordinates: LineString['coordinates'][]; } 
|   |      +-- MultiPoint.ts: // MultiPoint.ts import { Point } from "./Point";  export interface MultiPoint {   type: "MultiPoint";   coordinates: Point['coordinates'][]; } 
|   |      +-- MultiPolygon.ts: // MultiPolygon.ts import { Polygon } from "./Polygon";  export interface MultiPolygon {   type: "MultiPolygon";   coordinates: Polygon['coordinates'][]; } 
|   |      +-- Point.ts: // Point.ts export interface Point {   type: "Point";   coordinates: [number, number]; // Longitude, Latitude } 
|   |      +-- Polygon.ts: // Polygon.ts import { LineString } from "./LineString";  export interface Polygon {   type: "Polygon";   coordinates: LineString['coordinates'][]; // Array of linear rings } 
|   |      +-- TypeConverter.ts: import { Coordinate } from "../../core/models/Coordinate"; import { Distance } from "../../core/models/Distance"; import { GreatCircle } from "../../core/models/GreatCircle"; import { SmallCircle } from "../../core/models/SmallCircle"; import { Triangle } from "../../core/models/Triangle"; import { Feature } from "./Feature"; import { TypeMapping } from "./TypeMapping";  export class TypeConverter {     static toFeature(source: any): Feature {         const type = TypeMapping.get(source.constructor);         if (!type) {             throw new Error(`No mapping for type ${source.constructor.name}`);         }          try {             switch(type.type) {                 case "Point":                     if (source instanceof Coordinate) {                         return {                             type: "Feature",                             geometry: {                                 type: "Point",                                 coordinates: [source.longitude, source.latitude]                             },                             properties: {}                         };                     }                     return {                         type: "Feature",                         geometry: {                             type: "Point",                             coordinates: [0, 0] // Default return                         },                         properties: {}                     };                  case "LineString":                     if (source instanceof GreatCircle) {                         const points = source.generatePoints({ minPoints: 100 });                         return {                             type: "Feature",                             geometry: {                                 type: "LineString",                                 coordinates: points.map((p: Coordinate) => [p.longitude, p.latitude])                             },                             properties: {                                 distance: source.distance().inMeters()                             }                         };                     }                     return {                         type: "Feature",                         geometry: {                             type: "LineString",                             coordinates: []                         },                         properties: {}                     };                  case "Polygon":                     if (source instanceof SmallCircle) {                         const points = source.generatePoints(100);                         points.push(points[0]);                         return {                             type: "Feature",                             geometry: {                                 type: "Polygon",                                 coordinates: [points.map((p: Coordinate) => [p.longitude, p.latitude])]                             },                             properties: {                                 radius: source.getRadius().inMeters(),                                 area: source.area()                             }                         };                     }                     if (source instanceof Triangle) {                         const vertices = source.vertices;                         const allVertices = [...vertices, vertices[0]];                         return {                             type: "Feature",                             geometry: {                                 type: "Polygon",                                 coordinates: [allVertices.map((v: Coordinate) => [v.longitude, v.latitude])]                             },                             properties: {                                 area: source.area(),                                 perimeter: source.perimeter().inMeters()                             }                         };                     }                     return {                         type: "Feature",                         geometry: {                             type: "Polygon",                             coordinates: [[]]                         },                         properties: {}                     };             }              throw new Error(`Conversion not implemented for ${type.type}`);         } catch (exception: any) {             console.log('Conversion error:', exception);             return {                 type: "Feature",                 geometry: {                     type: "Point",                     coordinates: [0, 0]                 },                 properties: {}             };         }     }      static fromFeature(feature: Feature): any {         if (!feature.geometry) {             throw new Error('Invalid Feature: missing geometry');         }          try {             switch(feature.geometry.type) {                 case "Point":                     const [lon, lat] = feature.geometry.coordinates;                     return Coordinate.at(lat, lon);                  case "LineString":                     const coords = feature.geometry.coordinates;                     if (coords.length < 2) {                         throw new Error('Invalid LineString: needs at least 2 points');                     }                     const startCoord = Coordinate.at(coords[0][1], coords[0][0]);                     const endCoord = Coordinate.at(coords[coords.length - 1][1], coords[coords.length - 1][0]);                     return GreatCircle.from(startCoord).to(endCoord);                  case "Polygon":                     const vertices = feature.geometry.coordinates[0];                     if (vertices.length === 4 && feature.properties?.area) {                         const points = vertices.slice(0, -1).map(([lon, lat]) => Coordinate.at(lat, lon));                         return Triangle.from(points[0]).to(points[1]).and(points[2]);                     } else if (feature.properties?.radius) {                         const center = Coordinate.at(vertices[0][1], vertices[0][0]);                         const radius = new Distance(feature.properties.radius.inMeters());                         return SmallCircle.withCenter(center).radius(radius);                     }                     throw new Error('Unsupported Polygon type');             }              throw new Error(`Conversion not implemented for geometry type ${feature.geometry.type}`);         } catch (exception: any) {             console.log('Conversion error:', exception);             return null;         }     } }
|   |      -- TypeMapping.ts: import { Coordinate } from "../../core/models/Coordinate"; import { GreatCircle } from "../../core/models/GreatCircle"; import { Point } from "../../core/models/Point"; import { SmallCircle } from "../../core/models/SmallCircle"; import { Triangle } from "../../core/models/Triangle";  export interface GeoType {     type: string;     coordinates: any; }  export class TypeMapping {     private static readonly map = new Map<any, GeoType>([         [Coordinate, { type: "Point", coordinates: [] }],         [Point, { type: "Point", coordinates: [] }],         [GreatCircle, { type: "LineString", coordinates: [] }],         [SmallCircle, { type: "Polygon", coordinates: [] }],         [Triangle, { type: "Polygon", coordinates: [] }]     ]);      static get(type: any): GeoType | null {         const mapping = TypeMapping.map.get(type);         if (!mapping) {             return null;         }         return { ...mapping }; // Return a copy to prevent modification     }      static set(sourceType: any, geoType: GeoType): void {         TypeMapping.map.set(sourceType, { ...geoType }); // Store a copy     }      static hasMapping(type: any): boolean {         return TypeMapping.map.has(type);     }      static getAllMappings(): Map<any, GeoType> {         return new Map(TypeMapping.map); // Return a copy     }      static getSourceTypeForGeoType(geoType: string): any[] {         const results: any[] = [];         TypeMapping.map.forEach((value, key) => {             if (value.type === geoType) {                 results.push(key);             }         });         return results;     }      static registerMapping(sourceType: any, geoType: GeoType): void {         if (!geoType.type || !["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"].includes(geoType.type)) {             throw new Error(`Invalid GeoJSON type: ${geoType.type}`);         }         TypeMapping.set(sourceType, geoType);     } }
|   +-- core
|   |   +-- coordinate
|   |   |   -- CoordinateSystem.ts: import { Coordinate } from "../models/Coordinate"; import { Point } from "../models/Point";  export class CoordinateSystem {   static fromCoordinate(coord: Coordinate): Point {       const lat = coord.latitude * (Math.PI / 180);       const lon = coord.longitude * (Math.PI / 180);       return Point.at(lat, lon);   }    static fromPoint(point: Point): Coordinate {       const lat = point.X * (180 / Math.PI);       const lon = point.Y * (180 / Math.PI);       return Coordinate.at(lat, lon);   } }
|   |   +-- errors
|   |   |   +-- GeoConversionError.ts: import { GeoError } from './GeoError';  export class GeoConversionError extends GeoError {     constructor(         message: string,         public readonly sourceType: string,         public readonly targetType: string,         cause?: Error     ) {         super(message, cause);     } }
|   |   |   +-- GeoError.ts: export abstract class GeoError extends Error {   constructor(       message: string,       public readonly cause?: Error   ) {       super(message);       this.name = this.constructor.name;   } } 
|   |   |   +-- GeoValidationError.ts: import { GeoError } from './GeoError';  export class GeoValidationError extends GeoError {     constructor(         message: string,         public readonly validationType: string,         public readonly invalidValue: any,         cause?: Error     ) {         super(message, cause);     } }
|   |   |   -- index.ts: export * from './GeoError'; export * from './GeoConversionError'; export * from './GeoValidationError';
|   |   -- models
|   |      +-- Angle.js
|   |      +-- Angle.ts: import { Arc } from "./Arc"; import { Distance } from './Distance.js';    // Angle.ts export class Angle {     constructor(public readonly degrees: number) {}      // Add toRadians method     toRadians(): number {         return this.degrees * (Math.PI / 180);     }      normalize(): number {         return ((this.degrees % 360) + 360) % 360;     }      // Fix overload signatures     static defineBy(a: Arc, b: Arc, c: Arc | Angle, aLength?: Distance, bLength?: Distance, cLength?: Distance): Angle {         if (!aLength || !bLength || !cLength) {             throw new Error("Length parameters are required");         }          if (c instanceof Angle) {             // Law of Sines case             const sinA = Math.sin(c.toRadians());             const calculatedAngleDegrees = Math.asin(                 (aLength.inMeters() * Math.sin(c.toRadians())) / bLength.inMeters()             ) * (180 / Math.PI);              return new Angle(calculatedAngleDegrees);         } else {             // Law of Cosines case             const cosC = (                 Math.pow(aLength.inMeters(), 2) +                  Math.pow(bLength.inMeters(), 2) -                  Math.pow(cLength.inMeters(), 2)             ) / (2 * aLength.inMeters() * bLength.inMeters());              const calculatedAngleDegrees = Math.acos(cosC) * (180 / Math.PI);             return new Angle(calculatedAngleDegrees);         }     }      toString(): string {         return `Angle(${this.degrees} degrees)`;     } }  
|   |      +-- Arc.js
|   |      +-- Arc.ts: import { Angle } from "./Angle"; import { Coordinate } from "./Coordinate"; import { Distance } from "./Distance"; import { Sphere } from "./Sphere"; import { Point } from "./Point"; import { CoordinateSystem } from "../coordinate/CoordinateSystem";  export class Arc {     private constructor(         private readonly sphereRadius: Distance,         private readonly centralAngle?: Angle,         private readonly start?: Coordinate,         private readonly end?: Coordinate     ) { }      static onSphere(         sphereRadius: Distance = Sphere.getRadius(),         centralAngle?: Angle     ): Arc {         return new Arc(sphereRadius, centralAngle);     }      static fromPoints(         start: Coordinate,         end: Coordinate,         sphereRadius: Distance = Sphere.getRadius()     ): Arc {         return new Arc(sphereRadius, undefined, start, end);     }      length(): Distance {         if (this.start && this.end) {             const startPoint = CoordinateSystem.fromCoordinate(this.start);             const endPoint = CoordinateSystem.fromCoordinate(this.end);              // Calculate central angle using haversine formula             const dLat = endPoint.Y - startPoint.Y;             const dLon = endPoint.X - startPoint.X;              const a =                 Math.sin(dLat / 2) ** 2 +                 Math.cos(startPoint.Y) * Math.cos(endPoint.Y) * Math.sin(dLon / 2) ** 2;              const centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));              return new Distance(this.sphereRadius.inMeters() * centralAngle);         } else if (this.centralAngle) {             return new Distance(this.sphereRadius.inMeters() * this.centralAngle.toRadians());         } else {             return new Distance(2 * Math.PI * this.sphereRadius.inMeters());         }     }      interpolate(fraction: number): Coordinate | undefined {         if (fraction < 0 || fraction > 1) {             throw new Error('Fraction must be between 0 and 1');         }          if (this.start && this.end) {             const startPoint = CoordinateSystem.fromCoordinate(this.start);             const endPoint = CoordinateSystem.fromCoordinate(this.end);              const d = this.length().inMeters() / this.sphereRadius.inMeters();              const A = Math.sin((1 - fraction) * d) / Math.sin(d);             const B = Math.sin(fraction * d) / Math.sin(d);              const x =                 A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.cos(endPoint.X);             const y =                 A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.sin(endPoint.X);             const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y);              const lat3 = Math.atan2(z, Math.sqrt(x * x + y * y));             const lon3 = Math.atan2(y, x);              return CoordinateSystem.fromPoint(Point.at(lon3, lat3));         }         return undefined;     } }
|   |      +-- Azimuth.js
|   |      +-- Azimuth.ts: import { Coordinate } from './Coordinate'; import { Angle } from './Angle'; import { CoordinateSystem } from '../coordinate/CoordinateSystem';  export class Azimuth {     private constructor(         private readonly start: Coordinate,         private readonly end: Coordinate     ) {}      static from = (start: Coordinate) => ({         to: (end: Coordinate) => new Azimuth(start, end)     });      forward = (): Angle => {         const startPoint = CoordinateSystem.fromCoordinate(this.start);         const endPoint = CoordinateSystem.fromCoordinate(this.end);          const dLon = endPoint.X - startPoint.X;         const y = Math.sin(dLon) * Math.cos(endPoint.Y);         const x = Math.cos(startPoint.Y) * Math.sin(endPoint.Y) -                  Math.sin(startPoint.Y) * Math.cos(endPoint.Y) * Math.cos(dLon);                  const azimuthRadians = Math.atan2(y, x);         const azimuthDegrees = (azimuthRadians * (180 / Math.PI) + 360) % 360;          return new Angle(azimuthDegrees);     };      reverse = (): Angle => {         const forward = this.forward().degrees;         return new Angle((forward + 180) % 360);     };      toString = (): string =>          `Azimuth(${this.start} → ${this.end})`; }
|   |      +-- Bearing.js
|   |      +-- Bearing.ts: import { Coordinate } from './Coordinate'; import { Angle } from './Angle'; import { Azimuth } from './Azimuth';  export class Bearing {     private constructor(         private readonly start: Coordinate,         private readonly end: Coordinate     ) {}      static from = (start: Coordinate) => ({         to: (end: Coordinate) => new Bearing(start, end)     });      initial = (): Angle =>          Azimuth.from(this.start).to(this.end).forward();      final = (): Angle =>          Azimuth.from(this.start).to(this.end).reverse();      toString = (): string =>          `Bearing(${this.start} → ${this.end})`; }
|   |      +-- Coordinate.js
|   |      +-- Coordinate.ts: export class Coordinate {     public constructor(         private readonly lat: number,         private readonly lon: number,         private readonly alt?: number     ) {         if (lat < -90 || lat > 90) {             throw new Error('Latitude must be between -90 and 90 degrees');         }         if (lon < -180 || lon > 180) {             throw new Error('Longitude must be between -180 and 180 degrees');         }     }      static at = (lat: number, lon: number, alt?: number) =>          new Coordinate(lat, lon, alt);      get latitude(): number {         return this.lat;     }      get longitude(): number {         return this.lon;     }      get altitude(): number | undefined {         return this.alt;     }      equals = (other: Coordinate): boolean =>          this.lat === other.lat &&          this.lon === other.lon &&          this.alt === other.alt;      toString = (): string =>         `(${this.lat}°, ${this.lon}°${this.alt ? `, ${this.alt}m` : ''})`; }
|   |      +-- Distance.ts: // Angle.ts remains the same...  // Distance.ts export class Distance {     private static readonly METERS_TO_NM = 0.000539957;      constructor(private readonly meters: number) {}      inMeters(): number {         return this.meters;     }      inKilometers(): number {         return this.meters / 1000;     }      inCentimeters(): number {         return this.meters * 100;     }      inMiles(): number {         return this.meters * 0.000621371;     }      inFeet(): number {         return this.meters * 3.28084;     }      inYards(): number {         return this.meters * 1.09361;     }      inNauticalMiles(): number {         return this.meters * Distance.METERS_TO_NM;     }      static fromMeters(meters: number): Distance {         return new Distance(meters);     }      static fromKilometers(km: number): Distance {         return new Distance(km * 1000);     }      static fromMiles(miles: number): Distance {         return new Distance(miles / 0.000621371);     }      static fromNauticalMiles(nm: number): Distance {         return new Distance(nm / Distance.METERS_TO_NM);     }      static fromFeet(feet: number): Distance {         return new Distance(feet / 3.28084);     }      toString(): string {         return `${this.inKilometers().toFixed(2)} km`;     }      toFormat(unit: 'km' | 'mi' | 'nm' | 'ft' | 'm'): string {         switch(unit) {             case 'km': return `${this.inKilometers().toFixed(2)} km`;             case 'mi': return `${this.inMiles().toFixed(2)} mi`;             case 'nm': return `${this.inNauticalMiles().toFixed(2)} nm`;             case 'ft': return `${this.inFeet().toFixed(2)} ft`;             case 'm': return `${this.inMeters().toFixed(2)} m`;         }     } }
|   |      +-- GreatCircle.js
|   |      +-- GreatCircle.ts: import { CoordinateSystem } from '../coordinate/CoordinateSystem'; import { Azimuth } from './Azimuth'; import { Coordinate } from './Coordinate'; import { Distance } from './Distance'; import { Point } from './Point'; import { Sphere } from './Sphere';  interface PointGenerationOptions {    spacing?: Distance;    minPoints?: number;    maxPoints?: number; }  export class GreatCircle {    public constructor(        private readonly start: Coordinate,        private readonly end: Coordinate,        private readonly sphereRadius: Distance = Sphere.getRadius()    ) {}     static from(start: Coordinate) {        return {            to: (end: Coordinate) => new GreatCircle(start, end)        };    }     withSphere = (sphereRadius: Distance): GreatCircle =>         new GreatCircle(this.start, this.end, sphereRadius);     distance = (): Distance => {        const startPoint = CoordinateSystem.fromCoordinate(this.start);        const endPoint = CoordinateSystem.fromCoordinate(this.end);                const dLat = endPoint.Y - startPoint.Y;        const dLon = endPoint.X - startPoint.X;                const a = Math.sin(dLat/2) ** 2 +                  Math.cos(startPoint.Y) *                  Math.cos(endPoint.Y) *                  Math.sin(dLon/2) ** 2;                         const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));                return new Distance(this.sphereRadius.inMeters() * c);    };     interpolate = (fraction: number): Coordinate | undefined => {        if (fraction < 0 || fraction > 1) {            throw new Error('Fraction must be between 0 and 1');        }         const startPoint = CoordinateSystem.fromCoordinate(this.start);        const endPoint = CoordinateSystem.fromCoordinate(this.end);                const d = this.distance().inMeters() / this.sphereRadius.inMeters();                const A = Math.sin((1 - fraction) * d) / Math.sin(d);        const B = Math.sin(fraction * d) / Math.sin(d);                const x = A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.cos(endPoint.X);        const y = A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.sin(endPoint.X);        const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y);                const lat = Math.atan2(z, Math.sqrt(x * x + y * y));        const lon = Math.atan2(y, x);                return CoordinateSystem.fromPoint(Point.at(lon, lat));    };     // Rest of the methods remain unchanged    generatePoints = (options: PointGenerationOptions): Coordinate[] => {        const totalDistance = this.distance();                let numPoints: number;        if (options.spacing) {            numPoints = Math.ceil(totalDistance.inMeters() / options.spacing.inMeters());        } else if (options.minPoints) {            numPoints = options.minPoints;        } else {            numPoints = 100;        }         if (options.maxPoints) {            numPoints = Math.min(numPoints, options.maxPoints);        }         const points: Coordinate[] = [];        for (let i = 0; i <= numPoints; i++) {            const fraction = i / numPoints;            const point = this.interpolate(fraction);            if (point) points.push(point);        }         return points;    };     extend = (distance: Distance): GreatCircle => {        const bearing = Azimuth.from(this.start).to(this.end).forward();        const endPoint = this.interpolate(1 + (distance.inMeters() / this.distance().inMeters()));        return endPoint ? GreatCircle.from(this.start).to(endPoint) : this;    };     midpoint = (): Coordinate =>         this.interpolate(0.5)!;     toString = (): string =>        `GreatCircle(${this.start} → ${this.end})`; }
|   |      +-- Point.ts: import { Coordinate } from "./Coordinate";  export class Point {    private constructor(        private readonly x: number,        private readonly y: number,        private readonly z?: number    ) {}     static at = (x: number, y: number, z?: number) =>        new Point(x, y, z);     get X(): number {        return this.x;    }     get Y(): number {        return this.y;    }     get Z(): number | undefined {        return this.z;    }     equals = (other: Point): boolean =>        this.x === other.x &&        this.y === other.y &&        this.z === other.z;     toString = (): string =>        `Point(${this.x}, ${this.y}${this.z ? `, ${this.z}` : ''})`; }
|   |      +-- Polygon.ts: import { CoordinateSystem } from "../coordinate/CoordinateSystem"; import { Coordinate } from "./Coordinate"; import { Point } from "./Point";  export class Polygon {     constructor(private readonly vertices: Coordinate[]) {         if (vertices.length < 3) {             throw new Error("Polygon must have at least 3 vertices");         }     }      // Coordinate-based constructor     static fromCoordinates = (coords: Coordinate[]): Polygon =>          new Polygon(coords);      // Point-based constructor     static fromPoints = (points: Point[]): Polygon => {         const coords = points.map(p =>              CoordinateSystem.fromPoint(p)         );         return new Polygon(coords);     };      getVertices = (): Coordinate[] => this.vertices;      rewind = (): Polygon => {         const points = this.vertices.map(c => CoordinateSystem.fromCoordinate(c));         const fixed = this.ensureProperWindingPoints(points);         return Polygon.fromPoints(fixed);     };      private ensureProperWindingPoints = (points: Point[]): Point[] => {         // Calculate the signed area         let area = 0;         for (let i = 0; i < points.length; i++) {             const j = (i + 1) % points.length;             area += points[i].X * points[j].Y - points[j].X * points[i].Y;         }          // If area is negative (clockwise), reverse the points         if (area > 0) {             return [...points].reverse();         }         return points;     };      toString = (): string =>         `Polygon(${this.vertices.length} vertices)`; }
|   |      +-- SmallCircle.js
|   |      +-- SmallCircle.ts: import { Coordinate } from './Coordinate'; import { Point } from './Point'; import { Distance } from './Distance'; import { Angle } from './Angle'; import { Sphere } from './Sphere'; import { CoordinateSystem } from '../coordinate/CoordinateSystem';  export class SmallCircle {     private readonly centerPoint: Point;      private constructor(         private readonly center: Coordinate,         private readonly circleRadius: Distance,         private readonly sphereRadius: Distance = Sphere.getRadius()     ) {         this.centerPoint = CoordinateSystem.fromCoordinate(center);     }      static withCenter = (center: Coordinate) => ({         radius: (radius: Distance) => new SmallCircle(center, radius)     });      withSphere = (sphere: Sphere): SmallCircle =>         new SmallCircle(this.center, this.circleRadius, Sphere.getRadius());      circumference = (): Distance => {         const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters();         return new Distance(2 * Math.PI * this.sphereRadius.inMeters() * Math.sin(angularRadius));     };      area = (): number => {         const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters();         const sphereRadiusKm = this.sphereRadius.inMeters() / 1000;         return 2 * Math.PI * Math.pow(sphereRadiusKm, 2) * (1 - Math.cos(angularRadius));     };      generatePoints = (numPoints: number = 100): Coordinate[] => {         const points: Coordinate[] = [];         const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters();          for (let i = 0; i < numPoints; i++) {             const angle = (2 * Math.PI * i) / numPoints;             const latRad = Math.asin(                 Math.sin(this.centerPoint.Y) * Math.cos(angularRadius) +                 Math.cos(this.centerPoint.Y) * Math.sin(angularRadius) * Math.cos(angle)             );             const lonRad = this.centerPoint.X + Math.atan2(                 Math.sin(angle) * Math.sin(angularRadius) * Math.cos(this.centerPoint.Y),                 Math.cos(angularRadius) - Math.sin(this.centerPoint.Y) * Math.sin(latRad)             );              points.push(CoordinateSystem.fromPoint(Point.at(lonRad, latRad)));         }          return points;     };      getCenter = (): Coordinate => this.center;      getRadius = (): Distance => this.circleRadius;      toString = (): string =>         `SmallCircle(center: ${this.center}, radius: ${this.circleRadius})`; }
|   |      +-- Sphere.js
|   |      +-- Sphere.ts: import { Distance } from "./Distance";  export class Sphere {     private static readonly DEFAULT_RADIUS = Distance.fromKilometers(6371);      static getRadius = (radius?: Distance): Distance =>          radius ?? Sphere.DEFAULT_RADIUS;      static surfaceAreaFromRadius = (radius: Distance): number =>          4 * Math.PI * Math.pow(radius.inMeters() / 1000, 2);      static volumeFromRadius = (radius: Distance): number =>          (4/3) * Math.PI * Math.pow(radius.inMeters() / 1000, 3); }  // // Usage: // const radius = Sphere.getRadius();  // Default 6371km // const customRadius = Sphere.getRadius(Distance.fromMiles(4000));
|   |      +-- SphericalTrigonometry.ts: import { Angle } from "./Angle"; import { Distance } from "./Distance";  // For Law of Sines/Cosines calculations, we should use Distance directly export class SphericalTrigonometry {   static lawOfCosines(arcA: Distance, arcB: Distance, angleC: Angle): Distance {       const a = arcA.inMeters();       const b = arcB.inMeters();       const C = angleC.toRadians();              const c = Math.sqrt(           Math.pow(a, 2) + Math.pow(b, 2) -            2 * a * b * Math.cos(C)       );        return new Distance(c);   }    static lawOfSines(angleA: Angle, angleB: Angle, arcC: Distance): Distance {       const A = angleA.toRadians();       const B = angleB.toRadians();       const C = Math.PI - (A + B);              const c = arcC.inMeters();       const a = Math.abs(c * Math.sin(A) / Math.sin(C));        return new Distance(a);   } }
|   |      +-- Triangle.js
|   |      -- Triangle.ts: import { Coordinate } from './Coordinate'; import { Point } from './Point'; import { Sphere } from './Sphere'; import { Distance } from './Distance'; import { Angle } from './Angle'; import { CoordinateSystem } from '../coordinate/CoordinateSystem';  export class Triangle {     private readonly points: Point[];      public constructor(         private readonly triangleVertices: [Coordinate, Coordinate, Coordinate],         private readonly sphereRadius: Distance = Sphere.getRadius()     ) {         this.points = triangleVertices.map(v => CoordinateSystem.fromCoordinate(v));     }      static from = (a: Coordinate) => ({         to: (b: Coordinate) => ({             and: (c: Coordinate) => new Triangle([a, b, c])         })     });      withSphere = (sphere: Sphere): Triangle =>         new Triangle(this.triangleVertices, Sphere.getRadius());      area = (): number => {         const angles = this.angles();         const sphericalExcess = angles.reduce((sum, angle) => sum + angle.degrees, 0) - 180;         return sphericalExcess * (Math.PI / 180) * Math.pow(this.sphereRadius.inMeters() / 1000, 2);     };      perimeter = (): Distance => {         const sides = this.sides();         const totalMeters = sides.reduce((sum, side) => sum + side.inMeters(), 0);         return new Distance(totalMeters);     };      angles = (): [Angle, Angle, Angle] => {         return [0, 1, 2].map(i => {             const p1 = this.points[i];             const p2 = this.points[(i + 1) % 3];             const p3 = this.points[(i + 2) % 3];              const v1 = this.vectorBetween(p1, p2);             const v2 = this.vectorBetween(p1, p3);             const angle = this.angleBetweenVectors(v1, v2);              return new Angle(angle * (180 / Math.PI));         }) as [Angle, Angle, Angle];     };      sides = (): [Distance, Distance, Distance] => {         return [0, 1, 2].map(i => {             const start = this.points[i];             const end = this.points[(i + 1) % 3];             return this.sphericalDistance(start, end);         }) as [Distance, Distance, Distance];     };      private vectorBetween = (p1: Point, p2: Point): [number, number, number] => {         // Points are already in radians since we converted them in constructor         const x = Math.cos(p2.Y) * Math.cos(p2.X) - Math.cos(p1.Y) * Math.cos(p1.X);         const y = Math.cos(p2.Y) * Math.sin(p2.X) - Math.cos(p1.Y) * Math.sin(p1.X);         const z = Math.sin(p2.Y) - Math.sin(p1.Y);         return [x, y, z];     };      private angleBetweenVectors = (v1: [number, number, number], v2: [number, number, number]): number => {         const dot = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];         const mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);         const mag2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);         return Math.acos(dot / (mag1 * mag2));     };      private sphericalDistance = (p1: Point, p2: Point): Distance => {         // Points are already in radians from CoordinateSystem conversion         const dLat = p2.Y - p1.Y;         const dLon = p2.X - p1.X;         const a = Math.sin(dLat/2) ** 2 +                 Math.cos(p1.Y) * Math.cos(p2.Y) *                 Math.sin(dLon/2) ** 2;         const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));         return new Distance(this.sphereRadius.inMeters() * c);     };      get vertices(): [Coordinate, Coordinate, Coordinate] {         return this.triangleVertices;     }      toString = (): string =>         `Triangle(${this.triangleVertices.map(v => v.toString()).join(' → ')})`; }
|   +-- index.js
|   +-- index.ts: // Main entry point for the spherical geometry library  // Export core models export * from './core/models/Angle'; export * from './core/models/Arc'; export * from './core/models/Azimuth'; export * from './core/models/Bearing'; export * from './core/models/Coordinate'; export * from './core/models/Distance'; export * from './core/models/GreatCircle'; export * from './core/models/Point'; export * from './core/models/Polygon'; export * from './core/models/SmallCircle'; export * from './core/models/Sphere'; export * from './core/models/SphericalTrigonometry'; export * from './core/models/Triangle';  // Export coordinate system utilities export * from './core/coordinate/CoordinateSystem';  // Export error types export * from './core/errors/GeoError'; export * from './core/errors/GeoConversionError'; export * from './core/errors/GeoValidationError';  // Export GeoJSON adapters export * from './adapters/geojson/Feature'; export * from './adapters/geojson/FeatureCollection'; export * from './adapters/geojson/GeoConverter'; export * from './adapters/geojson/TypeConverter'; export * from './adapters/geojson/TypeMapping';
|   -- utils
|      +-- conversion
|      -- math
+-- test
|   +-- __fixtures__
|   |   +-- angles.ts: // Common angles  import { Angle } from '../../src/core/models/Angle';  // Common Angles export const ZERO = new Angle(0); export const RIGHT_ANGLE = new Angle(90); export const STRAIGHT_ANGLE = new Angle(180); export const FULL_CIRCLE = new Angle(360);  // Quadrant Angles export const QUAD_1_MID = new Angle(45);    // Northeast export const QUAD_2_MID = new Angle(135);   // Northwest export const QUAD_3_MID = new Angle(225);   // Southwest export const QUAD_4_MID = new Angle(315);   // Southeast  // Navigation Angles export const NORTH = new Angle(0); export const EAST = new Angle(90); export const SOUTH = new Angle(180); export const WEST = new Angle(270);  // Special Angles export const EQUILATERAL = new Angle(60);  // Angle in equilateral triangle export const GOLDEN = new Angle(137.5);    // Golden angle export const HALF_TURN = new Angle(180);   // Half turn export const THIRD_TURN = new Angle(120);  // One third of a circle  // Test Cases export const ACUTE = new Angle(45); export const OBTUSE = new Angle(135); export const REFLEX = new Angle(270);  // Edge Cases export const NEGATIVE = new Angle(-45); export const OVER_360 = new Angle(400); export const UNDER_NEG_360 = new Angle(-400);
|   |   +-- coordinates.ts: // Common test coordinates  import { Coordinate } from '../../src/core/models/Coordinate';  // Major Cities export const LONDON = new Coordinate(51.5074, -0.1278); export const NEW_YORK = new Coordinate(40.7128, -74.0060); export const TOKYO = new Coordinate(35.6762, 139.6503); export const SYDNEY = new Coordinate(33.8688, 151.2093); export const PARIS = new Coordinate(48.8566, 2.3522); export const LOS_ANGELES = new Coordinate(34.0522, -118.2437);  // Geographic Points of Interest export const NORTH_POLE = new Coordinate(90, 0); export const SOUTH_POLE = new Coordinate(-90, 0); export const EQUATOR_PRIME = new Coordinate(0, 0);  // Equator at Prime Meridian export const EQUATOR_180 = new Coordinate(0, 180);  // Equator at 180° longitude export const EQUATOR_MINUS_180 = new Coordinate(0, -180); // Equator at -180° longitude  // Mountain Peaks export const MOUNT_EVEREST = new Coordinate(27.9881, 86.9250, 8848); export const KILIMANJARO = new Coordinate(-3.0674, 37.3556, 5895); export const MOUNT_MCKINLEY = new Coordinate(63.0695, -151.0074, 6190);  // Edge Cases export const MAX_LAT = new Coordinate(90, 0); export const MIN_LAT = new Coordinate(-90, 0); export const MAX_LON = new Coordinate(0, 180); export const MIN_LON = new Coordinate(0, -180);  // Test Points at Various Quadrants export const QUAD_1 = new Coordinate(45, 45);    // Northeast export const QUAD_2 = new Coordinate(45, -45);   // Northwest export const QUAD_3 = new Coordinate(-45, -45);  // Southwest export const QUAD_4 = new Coordinate(-45, 45);   // Southeast  // Points for Triangle Testing export const TRIANGLE_VERTEX_1 = new Coordinate(0, 0); export const TRIANGLE_VERTEX_2 = new Coordinate(0, 1); export const TRIANGLE_VERTEX_3 = new Coordinate(1, 0);  // Points for Small Circle Testing export const CIRCLE_CENTER = new Coordinate(0, 0); export const CIRCLE_POINT = new Coordinate(0, 1);
|   |   -- distances.ts: // Pre-calculated distances  import { Distance } from '../../src/core/models/Distance';  // Common Distances export const ONE_KILOMETER = Distance.fromKilometers(1); export const ONE_MILE = Distance.fromMiles(1); export const ONE_NAUTICAL_MILE = Distance.fromNauticalMiles(1);  // Earth-related Distances export const EARTH_RADIUS = Distance.fromKilometers(6371);  // Average Earth radius export const EARTH_EQUATORIAL_RADIUS = Distance.fromKilometers(6378.137);  // WGS84 equatorial radius export const EARTH_POLAR_RADIUS = Distance.fromKilometers(6356.752);  // WGS84 polar radius export const EARTH_CIRCUMFERENCE = Distance.fromKilometers(40075.017);  // Earth's circumference at equator  // Pre-calculated Real-World Distances export const LONDON_TO_PARIS = Distance.fromKilometers(344);  // ~344 km export const NEW_YORK_TO_LOS_ANGELES = Distance.fromKilometers(3936);  // ~3,936 km export const SYDNEY_TO_TOKYO = Distance.fromKilometers(7832);  // ~7,832 km  // Common Test Distances export const TINY_DISTANCE = Distance.fromMeters(1); export const SMALL_DISTANCE = Distance.fromKilometers(1); export const MEDIUM_DISTANCE = Distance.fromKilometers(100); export const LARGE_DISTANCE = Distance.fromKilometers(1000); export const HUGE_DISTANCE = Distance.fromKilometers(10000);  // Special Case Distances export const ZERO_DISTANCE = Distance.fromMeters(0); export const QUARTER_EARTH = Distance.fromKilometers(10018.75);  // One quarter of Earth's circumference export const HALF_EARTH = Distance.fromKilometers(20037.5);      // Half of Earth's circumference
|   +-- __helpers__
|   |   +-- assertions.ts: // Custom assertions  import { expect } from 'vitest'; import { Coordinate } from '../../src/core/models/Coordinate'; import { Distance } from '../../src/core/models/Distance'; import { Angle } from '../../src/core/models/Angle';  // Distance assertions export function assertDistanceNearlyEqual(     actual: Distance,     expected: Distance,     toleranceMeters: number = 1,     message?: string ) {     const diff = Math.abs(actual.inMeters() - expected.inMeters());     expect(diff, message || `Expected distance to be within ${toleranceMeters}m of ${expected.inMeters()}m`)         .toBeLessThanOrEqual(toleranceMeters); }  // Angle assertions export function assertAngleNearlyEqual(     actual: Angle,     expected: Angle,     toleranceDegrees: number = 0.1,     message?: string ) {     const diff = Math.abs(actual.degrees - expected.degrees) % 360;     const smallestDiff = Math.min(diff, 360 - diff);     expect(smallestDiff, message || `Expected angle to be within ${toleranceDegrees}° of ${expected.degrees}°`)         .toBeLessThanOrEqual(toleranceDegrees); }  // Coordinate assertions export function assertCoordinateNearlyEqual(     actual: Coordinate,     expected: Coordinate,     toleranceDegrees: number = 0.0001,     message?: string ) {     const latDiff = Math.abs(actual.latitude - expected.latitude);     const lonDiff = Math.abs(actual.longitude - expected.longitude);          expect(latDiff, message || `Latitude difference exceeds tolerance`)         .toBeLessThanOrEqual(toleranceDegrees);     expect(lonDiff, message || `Longitude difference exceeds tolerance`)         .toBeLessThanOrEqual(toleranceDegrees);          if (actual.altitude !== undefined && expected.altitude !== undefined) {         const altDiff = Math.abs(actual.altitude - expected.altitude);         expect(altDiff, message || `Altitude difference exceeds tolerance`)             .toBeLessThanOrEqual(1); // 1 meter tolerance for altitude     } }  // Area assertions (for spherical geometry) export function assertAreaNearlyEqual(     actual: number,     expected: number,     toleranceKm2: number = 1,     message?: string ) {     const diff = Math.abs(actual - expected);     expect(diff, message || `Expected area to be within ${toleranceKm2}km² of ${expected}km²`)         .toBeLessThanOrEqual(toleranceKm2); }  // Bearing/Azimuth assertions export function assertBearingNearlyEqual(     actual: Angle,     expected: Angle,     toleranceDegrees: number = 0.1,     message?: string ) {     let diff = Math.abs(actual.degrees - expected.degrees) % 360;     if (diff > 180) diff = 360 - diff;     expect(diff, message || `Expected bearing to be within ${toleranceDegrees}° of ${expected.degrees}°`)         .toBeLessThanOrEqual(toleranceDegrees); }
|   |   +-- constants.ts: // Test constants  // Test Tolerances export const DISTANCE_TOLERANCE_METERS = 1;        // 1 meter tolerance for distance comparisons export const ANGLE_TOLERANCE_DEGREES = 0.1;        // 0.1 degree tolerance for angle comparisons export const COORDINATE_TOLERANCE_DEGREES = 0.0001; // 0.0001 degree tolerance for coordinate comparisons export const AREA_TOLERANCE_KM2 = 1;              // 1 km² tolerance for area comparisons export const ALTITUDE_TOLERANCE_METERS = 1;        // 1 meter tolerance for altitude comparisons  // Test Categories export const TEST_CATEGORIES = {     CONSTRUCTOR: 'Constructor Tests',     VALIDATION: 'Input Validation',     CALCULATIONS: 'Core Calculations',     EDGE_CASES: 'Edge Cases',     ERROR_HANDLING: 'Error Handling',     REAL_WORLD: 'Real World Examples',     INTEGRATION: 'Integration Tests' } as const;  // Error Messages export const ERROR_MESSAGES = {     INVALID_LATITUDE: 'Latitude must be between -90 and 90 degrees',     INVALID_LONGITUDE: 'Longitude must be between -180 and 180 degrees',     INVALID_ANGLE: 'Angle must be a finite number',     INVALID_DISTANCE: 'Distance must be non-negative',     INVALID_RADIUS: 'Radius must be positive',     INVALID_COORDINATE: 'Invalid coordinate',     INVALID_POINT: 'Invalid point' } as const;  // Common Test Values export const TEST_VALUES = {     ITERATIONS: 100,           // Number of iterations for property-based tests     MIN_POINTS: 10,           // Minimum points for shape generation     MAX_POINTS: 1000,         // Maximum points for shape generation     SEED: 12345              // Seed for random number generation } as const;  // Mathematical Constants export const MATH_CONSTANTS = {     EARTH_RADIUS_KM: 6371,    // Earth's mean radius in kilometers     DEG_TO_RAD: Math.PI / 180,     RAD_TO_DEG: 180 / Math.PI,     EPSILON: 1e-10            // Small number for floating-point comparisons } as const;
|   |   -- generators.ts: // Test generators  
|   +-- adapters
|   |   -- geojson
|   |      +-- Feature.test.ts: // Feature test file  
|   |      +-- FeatureCollection.test.ts: // FeatureCollection test file  
|   |      +-- GeoConverter.test.ts: // GeoConverter test file  
|   |      +-- GeoReader.test.ts: // GeoReader test file  
|   |      +-- GeoRegistry.test.ts: import { describe, it, expect } from 'vitest'; import { GeoRegistry } from '../../../src/adapters/geojson/GeoRegistry'; import { Feature } from '../../../src/adapters/geojson/Feature'; import { Coordinate } from '../../../src/core/models/Coordinate'; import { GreatCircle } from '../../../src/core/models/GreatCircle'; import { SmallCircle } from '../../../src/core/models/SmallCircle'; import { Triangle } from '../../../src/core/models/Triangle'; import { Distance } from '../../../src/core/models/Distance'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import {     LONDON,     PARIS,     TRIANGLE_VERTEX_1,     TRIANGLE_VERTEX_2,     TRIANGLE_VERTEX_3 } from '../../__fixtures__/coordinates'; import { ONE_KILOMETER } from '../../__fixtures__/distances';  describe('GeoRegistry', () => {     describe('Feature to Model Conversion', () => {         it('should convert LineString feature to GreatCircle', () => {             const feature: Feature = {                 type: 'Feature',                 geometry: {                     type: 'LineString',                     coordinates: [                         [PARIS.longitude, PARIS.latitude],                         [LONDON.longitude, LONDON.latitude]                     ]                 },                 properties: {}             };              const result = GeoRegistry.reverse(feature);             expect(result).toBeInstanceOf(GreatCircle);         });          // Triangle case         it('should convert Triangle Polygon feature to Triangle', () => {             const triangleFeature: Feature = {                 type: 'Feature',                 geometry: {                     type: 'Polygon',                     coordinates: [[                         [0, 0],                         [1, 0],                         [0, 1],                         [0, 0]  // Closing point                     ]]                 },                 properties: { area: 100 }             };              const result = GeoRegistry.reverse(triangleFeature);             expect(result).toBeInstanceOf(Triangle);         });          // Small Circle case         it('should convert Circle Polygon feature to SmallCircle', () => {             const circleFeature: Feature = {                 type: 'Feature',                 geometry: {                     type: 'Polygon',                     coordinates: [[                         [0, 0],                         [0.1, 0],                         [0, 0.1],                         [0, 0]  // Closing point                     ]]                 },                 properties: { radius: 1000 }             };              const result = GeoRegistry.reverse(circleFeature);             expect(result).toBeInstanceOf(SmallCircle);         });     });      describe('Model to Feature Conversion', () => {         it('should convert GreatCircle to LineString feature', () => {             const greatCircle = GreatCircle.from(PARIS).to(LONDON);             const feature = GeoRegistry.convert(greatCircle, 'Feature');              expect(feature.type).toBe('Feature');             expect(feature.geometry.type).toBe('LineString');             if (feature.geometry.type === 'LineString') {                 expect(feature.geometry.coordinates.length).toBeGreaterThan(0);             }         });          it('should convert SmallCircle to Polygon feature', () => {             const circle = SmallCircle.withCenter(LONDON).radius(ONE_KILOMETER);             const feature = GeoRegistry.convert(circle, 'Feature');              expect(feature.type).toBe('Feature');             expect(feature.geometry.type).toBe('Polygon');             if (feature.geometry.type === 'Polygon') {                 expect(feature.geometry.coordinates[0].length).toBeGreaterThan(0);                 // Verify polygon is closed                 const ring = feature.geometry.coordinates[0];                 expect(ring[0]).toEqual(ring[ring.length - 1]);             }         });          it('should convert Triangle to Polygon feature', () => {             const triangle = Triangle.from(TRIANGLE_VERTEX_1)                 .to(TRIANGLE_VERTEX_2)                 .and(TRIANGLE_VERTEX_3);             const feature = GeoRegistry.convert(triangle, 'Feature');              expect(feature.type).toBe('Feature');             expect(feature.geometry.type).toBe('Polygon');             if (feature.geometry.type === 'Polygon') {                 expect(feature.geometry.coordinates[0].length).toBe(4); // 3 vertices + closing point                 // Verify polygon is closed                 const ring = feature.geometry.coordinates[0];                 expect(ring[0]).toEqual(ring[ring.length - 1]);             }         });     });      describe(TEST_CATEGORIES.ERROR_HANDLING, () => {         it('should handle invalid LineString features', () => {             const invalidFeature: Feature = {                 type: 'Feature',                 geometry: {                     type: 'LineString',                     coordinates: []  // Empty coordinates                 },                 properties: {}             };              expect(() => {                 GeoRegistry.reverse(invalidFeature);             }).toThrow();         });          it('should handle LineString with insufficient points', () => {             const invalidFeature: Feature = {                 type: 'Feature',                 geometry: {                     type: 'LineString',                     coordinates: [[0, 0]]  // Only one point                 },                 properties: {}             };              expect(() => {                 GeoRegistry.reverse(invalidFeature);             }).toThrow();         });     }); });
|   |      +-- GeoWriter.test.ts: // GeoWriter test file  
|   |      +-- GeometryCollection.test.ts: // GeometryCollection test file  
|   |      +-- LineString.test.ts: // LineString test file  
|   |      +-- MultiLineString.test.ts: // MultiLineString test file  
|   |      +-- MultiPoint.test.ts: // MultiPoint test file  
|   |      +-- MultiPolygon.test.ts: // MultiPolygon test file  
|   |      +-- Point.test.ts: // Point test file  
|   |      +-- Polygon.test.ts: // Polygon test file  
|   |      +-- TypeConverter.test.ts: // TypeConverter test file  
|   |      -- TypeMapping.test.ts: // TypeMapping test file  import { describe, it, expect } from 'vitest'; import { TypeMapping } from '../../../src/adapters/geojson/TypeMapping'; import { Coordinate } from '../../../src/core/models/Coordinate'; import { Point } from '../../../src/core/models/Point'; import { GreatCircle } from '../../../src/core/models/GreatCircle'; import { SmallCircle } from '../../../src/core/models/SmallCircle'; import { Triangle } from '../../../src/core/models/Triangle'; import { TEST_CATEGORIES } from '../../__helpers__/constants';  describe('TypeMapping', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should have default mappings for core types', () => {             expect(TypeMapping.hasMapping(Coordinate)).toBe(true);             expect(TypeMapping.hasMapping(Point)).toBe(true);             expect(TypeMapping.hasMapping(GreatCircle)).toBe(true);             expect(TypeMapping.hasMapping(SmallCircle)).toBe(true);             expect(TypeMapping.hasMapping(Triangle)).toBe(true);         });          it('should return null for unknown types', () => {             class UnknownType {}             expect(TypeMapping.get(UnknownType)).toBeNull();         });     });      describe('Mapping Operations', () => {         it('should get correct GeoJSON type for each model', () => {             const mappings = {                 Coordinate: 'Point',                 Point: 'Point',                 GreatCircle: 'LineString',                 SmallCircle: 'Polygon',                 Triangle: 'Polygon'             };              for (const [modelName, geoType] of Object.entries(mappings)) {                 const mapping = TypeMapping.get(eval(modelName));                 expect(mapping?.type).toBe(geoType);             }         });          it('should return copy of mapping to prevent modification', () => {             const mapping1 = TypeMapping.get(Coordinate);             const mapping2 = TypeMapping.get(Coordinate);                          expect(mapping1).not.toBe(mapping2);             expect(mapping1).toEqual(mapping2);         });     });      describe('Registration', () => {         it('should register new valid mapping', () => {             class CustomType {}             const geoType = { type: "Point", coordinates: [] };                          TypeMapping.registerMapping(CustomType, geoType);             expect(TypeMapping.hasMapping(CustomType)).toBe(true);             expect(TypeMapping.get(CustomType)).toEqual(geoType);         });          it('should throw error for invalid GeoJSON type', () => {             class CustomType {}             const invalidType = { type: "InvalidType", coordinates: [] };                          expect(() => {                 TypeMapping.registerMapping(CustomType, invalidType as any);             }).toThrow();         });          it('should allow overriding existing mapping', () => {             class CustomType {}             const type1 = { type: "Point", coordinates: [] };             const type2 = { type: "LineString", coordinates: [] };                          TypeMapping.registerMapping(CustomType, type1);             TypeMapping.registerMapping(CustomType, type2);                          expect(TypeMapping.get(CustomType)?.type).toBe("LineString");         });     });      describe('Type Lookup', () => {         it('should find source types for GeoJSON type', () => {             const pointSources = TypeMapping.getSourceTypeForGeoType('Point');             expect(pointSources).toContain(Coordinate);             expect(pointSources).toContain(Point);                          const polygonSources = TypeMapping.getSourceTypeForGeoType('Polygon');             expect(polygonSources).toContain(SmallCircle);             expect(polygonSources).toContain(Triangle);         });          it('should return empty array for unknown GeoJSON type', () => {             const sources = TypeMapping.getSourceTypeForGeoType('UnknownType');             expect(sources).toHaveLength(0);         });     });      describe('Mapping Access', () => {         it('should return all mappings', () => {             const allMappings = TypeMapping.getAllMappings();             expect(allMappings.size).toBeGreaterThan(0);             expect(allMappings instanceof Map).toBe(true);         });          it('should return copy of mappings to prevent modification', () => {             const mappings1 = TypeMapping.getAllMappings();             const mappings2 = TypeMapping.getAllMappings();                          expect(mappings1).not.toBe(mappings2);             expect([...mappings1.entries()]).toEqual([...mappings2.entries()]);         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle undefined type registration', () => {             expect(() => {                 TypeMapping.registerMapping(undefined as any, { type: "Point", coordinates: [] });             }).toThrow();         });          it('should handle null type registration', () => {             expect(() => {                 TypeMapping.registerMapping(null as any, { type: "Point", coordinates: [] });             }).toThrow();         });          it('should handle registration with empty GeoType', () => {             class CustomType {}             expect(() => {                 TypeMapping.registerMapping(CustomType, {} as any);             }).toThrow();         });     });      describe('Type Validation', () => {         it('should validate GeoJSON types on registration', () => {             class CustomType {}             const validTypes = ["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"];                          validTypes.forEach(type => {                 expect(() => {                     TypeMapping.registerMapping(CustomType, { type, coordinates: [] });                 }).not.toThrow();             });         });          it('should reject invalid GeoJSON types', () => {             class CustomType {}             const invalidTypes = ["Invalid", "Circle", "Rectangle", ""];                          invalidTypes.forEach(type => {                 expect(() => {                     TypeMapping.registerMapping(CustomType, { type, coordinates: [] } as any);                 }).toThrow();             });         });     }); });
|   +-- core
|   |   +-- coordinate
|   |   |   -- CoordinateSystem.test.ts: // CoordinateSystem test file  import { describe, it, expect } from 'vitest'; import { CoordinateSystem } from '../../../src/core/coordinate/CoordinateSystem'; import { Coordinate } from '../../../src/core/models/Coordinate'; import { Point } from '../../../src/core/models/Point'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import {      assertCoordinateNearlyEqual  } from '../../__helpers__/assertions'; import {     LONDON,     PARIS,     NORTH_POLE,     SOUTH_POLE,     EQUATOR_PRIME,     EQUATOR_180 } from '../../__fixtures__/coordinates';  describe('CoordinateSystem', () => {     describe('Coordinate to Point Conversion', () => {         it('should convert equator point', () => {             const point = CoordinateSystem.fromCoordinate(EQUATOR_PRIME);             expect(point.X).toBeCloseTo(0);             expect(point.Y).toBeCloseTo(0);         });          it('should convert North Pole', () => {             const point = CoordinateSystem.fromCoordinate(NORTH_POLE);             expect(point.X).toBeCloseTo(0);             expect(point.Y).toBeCloseTo(Math.PI / 2);         });          it('should convert South Pole', () => {             const point = CoordinateSystem.fromCoordinate(SOUTH_POLE);             expect(point.X).toBeCloseTo(0);             expect(point.Y).toBeCloseTo(-Math.PI / 2);         });          it('should convert date line points', () => {             const point = CoordinateSystem.fromCoordinate(EQUATOR_180);             expect(point.X).toBeCloseTo(Math.PI);             expect(point.Y).toBeCloseTo(0);         });          it('should convert arbitrary point', () => {             const point = CoordinateSystem.fromCoordinate(LONDON);             expect(point.X).toBeCloseTo(-0.1278 * Math.PI / 180);             expect(point.Y).toBeCloseTo(51.5074 * Math.PI / 180);         });     });      describe('Point to Coordinate Conversion', () => {         it('should convert origin point', () => {             const point = Point.at(0, 0);             const coord = CoordinateSystem.fromPoint(point);             expect(coord.latitude).toBeCloseTo(0);             expect(coord.longitude).toBeCloseTo(0);         });          it('should convert pole point', () => {             const point = Point.at(0, Math.PI / 2);             const coord = CoordinateSystem.fromPoint(point);             expect(coord.latitude).toBeCloseTo(90);             expect(coord.longitude).toBeCloseTo(0);         });          it('should convert arbitrary point', () => {             const point = Point.at(                 -0.1278 * Math.PI / 180,                 51.5074 * Math.PI / 180             );             const coord = CoordinateSystem.fromPoint(point);             assertCoordinateNearlyEqual(coord, LONDON);         });     });      describe('Round Trip Conversions', () => {         const testPoints = [             LONDON,             PARIS,             NORTH_POLE,             SOUTH_POLE,             EQUATOR_PRIME,             EQUATOR_180         ];          testPoints.forEach(original => {             it(`should preserve ${original.toString()} in round trip`, () => {                 const point = CoordinateSystem.fromCoordinate(original);                 const roundTrip = CoordinateSystem.fromPoint(point);                 assertCoordinateNearlyEqual(roundTrip, original);             });         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle 180/-180 longitude equivalence', () => {             const pos180 = new Coordinate(0, 180);             const neg180 = new Coordinate(0, -180);                          const point1 = CoordinateSystem.fromCoordinate(pos180);             const point2 = CoordinateSystem.fromCoordinate(neg180);                          expect(point1.X).toBeCloseTo(point2.X);             expect(point1.Y).toBeCloseTo(point2.Y);         });          it('should handle points near poles', () => {             const nearNorthPole = new Coordinate(89.9999, 0);             const point = CoordinateSystem.fromCoordinate(nearNorthPole);             const roundTrip = CoordinateSystem.fromPoint(point);             assertCoordinateNearlyEqual(roundTrip, nearNorthPole);         });          it('should handle points near date line', () => {             const nearDateLine = new Coordinate(0, 179.9999);             const point = CoordinateSystem.fromCoordinate(nearDateLine);             const roundTrip = CoordinateSystem.fromPoint(point);             assertCoordinateNearlyEqual(roundTrip, nearDateLine);         });     });      describe('Numerical Precision', () => {         it('should maintain precision for small angles', () => {             const smallAngle = new Coordinate(0.0001, 0.0001);             const point = CoordinateSystem.fromCoordinate(smallAngle);             const roundTrip = CoordinateSystem.fromPoint(point);             assertCoordinateNearlyEqual(roundTrip, smallAngle, 0.0000001);         });          it('should handle angles close to limits', () => {             const nearLimit = new Coordinate(89.9999999, 179.9999999);             const point = CoordinateSystem.fromCoordinate(nearLimit);             const roundTrip = CoordinateSystem.fromPoint(point);             assertCoordinateNearlyEqual(roundTrip, nearLimit, 0.0000001);         });     }); });
|   |   +-- errors
|   |   |   +-- GeoConversionError.test.ts: // GeoConversionError test file  import { describe, it, expect } from 'vitest'; import { GeoConversionError } from '../../../src/core/errors/GeoConversionError'; import { GeoError } from '../../../src/core/errors/GeoError'; import { TEST_CATEGORIES } from '../../__helpers__/constants';  describe('GeoConversionError', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create error with all parameters', () => {             const error = new GeoConversionError(                 'Conversion failed',                 'Coordinate',                 'GeoJSON',                 new Error('Cause')             );                          expect(error.message).toBe('Conversion failed');             expect(error.sourceType).toBe('Coordinate');             expect(error.targetType).toBe('GeoJSON');             expect(error.cause).toBeInstanceOf(Error);         });          it('should create error without cause', () => {             const error = new GeoConversionError(                 'Conversion failed',                 'Coordinate',                 'GeoJSON'             );                          expect(error.message).toBe('Conversion failed');             expect(error.sourceType).toBe('Coordinate');             expect(error.targetType).toBe('GeoJSON');             expect(error.cause).toBeUndefined();         });     });      describe('Error Properties', () => {         it('should have correct name', () => {             const error = new GeoConversionError(                 'Conversion failed',                 'Coordinate',                 'GeoJSON'             );             expect(error.name).toBe('GeoConversionError');         });          it('should have correct inheritance chain', () => {             const error = new GeoConversionError(                 'Conversion failed',                 'Coordinate',                 'GeoJSON'             );             expect(error).toBeInstanceOf(Error);             expect(error).toBeInstanceOf(GeoError);             expect(error).toBeInstanceOf(GeoConversionError);         });          it('should expose source and target types', () => {             const error = new GeoConversionError(                 'Conversion failed',                 'Coordinate',                 'GeoJSON'             );             expect(error.sourceType).toBe('Coordinate');             expect(error.targetType).toBe('GeoJSON');         });     });      describe('Usage Patterns', () => {         it('should work in try-catch block', () => {             expect(() => {                 throw new GeoConversionError(                     'Conversion failed',                     'Coordinate',                     'GeoJSON'                 );             }).toThrow(GeoConversionError);         });          it('should maintain error chain with cause', () => {             const cause = new Error('Original error');             const error = new GeoConversionError(                 'Conversion failed',                 'Coordinate',                 'GeoJSON',                 cause             );                          expect(error.cause).toBe(cause);             expect(error.message).toBe('Conversion failed');         });     });      describe(TEST_CATEGORIES.ERROR_HANDLING, () => {         it('should handle empty strings', () => {             const error = new GeoConversionError('', '', '');             expect(error.message).toBe('');             expect(error.sourceType).toBe('');             expect(error.targetType).toBe('');         });          it('should handle undefined cause', () => {             const error = new GeoConversionError(                 'Conversion failed',                 'Coordinate',                 'GeoJSON',                 undefined             );             expect(error.cause).toBeUndefined();         });          it('should handle non-Error cause', () => {             const error = new GeoConversionError(                 'Conversion failed',                 'Coordinate',                 'GeoJSON',                 'Not an error' as any             );             expect(error.cause).toBe('Not an error');         });     }); });
|   |   |   +-- GeoError.test.ts: // GeoError test file  import { describe, it, expect } from 'vitest'; import { GeoError } from '../../../src/core/errors/GeoError'; import { TEST_CATEGORIES } from '../../__helpers__/constants';  // Create a concrete implementation of GeoError for testing class TestGeoError extends GeoError {     constructor(message: string, cause?: Error) {         super(message, cause);     } }  describe('GeoError', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create error with message', () => {             const message = 'Test error message';             const error = new TestGeoError(message);                          expect(error.message).toBe(message);             expect(error.name).toBe('TestGeoError');             expect(error instanceof Error).toBe(true);             expect(error instanceof GeoError).toBe(true);         });          it('should create error with message and cause', () => {             const message = 'Test error message';             const cause = new Error('Cause error');             const error = new TestGeoError(message, cause);                          expect(error.message).toBe(message);             expect(error.cause).toBe(cause);         });     });      describe('Error Properties', () => {         it('should have correct name', () => {             const error = new TestGeoError('Test error');             expect(error.name).toBe('TestGeoError');         });          it('should have correct inheritance chain', () => {             const error = new TestGeoError('Test error');             expect(error).toBeInstanceOf(Error);             expect(error).toBeInstanceOf(GeoError);             expect(error).toBeInstanceOf(TestGeoError);         });          it('should be throwable', () => {             expect(() => {                 throw new TestGeoError('Test error');             }).toThrow(TestGeoError);         });     });      describe('Stack Trace', () => {         it('should maintain stack trace', () => {             const error = new TestGeoError('Test error');             expect(error.stack).toBeDefined();         });          it('should include cause in stack trace when provided', () => {             const cause = new Error('Cause error');             const error = new TestGeoError('Test error', cause);             expect(error.stack).toContain('Test error');             expect(error.cause).toBe(cause);         });     });      describe(TEST_CATEGORIES.ERROR_HANDLING, () => {         it('should handle empty message', () => {             const error = new TestGeoError('');             expect(error.message).toBe('');         });          it('should handle undefined cause', () => {             const error = new TestGeoError('Test error', undefined);             expect(error.cause).toBeUndefined();         });          it('should handle non-Error cause', () => {             const error = new TestGeoError('Test error', 'Not an error' as any);             expect(error.cause).toBe('Not an error');         });     }); });
|   |   |   -- GeoValidationError.test.ts: // GeoValidationError test file  import { describe, it, expect } from 'vitest'; import { GeoValidationError } from '../../../src/core/errors/GeoValidationError'; import { GeoError } from '../../../src/core/errors/GeoError'; import { TEST_CATEGORIES } from '../../__helpers__/constants';  describe('GeoValidationError', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create error with all parameters', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'latitude',                 91,                 new Error('Cause')             );                          expect(error.message).toBe('Invalid coordinate');             expect(error.validationType).toBe('latitude');             expect(error.invalidValue).toBe(91);             expect(error.cause).toBeInstanceOf(Error);         });          it('should create error without cause', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'latitude',                 91             );                          expect(error.message).toBe('Invalid coordinate');             expect(error.validationType).toBe('latitude');             expect(error.invalidValue).toBe(91);             expect(error.cause).toBeUndefined();         });     });      describe('Error Properties', () => {         it('should have correct name', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'latitude',                 91             );             expect(error.name).toBe('GeoValidationError');         });          it('should have correct inheritance chain', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'latitude',                 91             );             expect(error).toBeInstanceOf(Error);             expect(error).toBeInstanceOf(GeoError);             expect(error).toBeInstanceOf(GeoValidationError);         });          it('should expose validation details', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'latitude',                 91             );             expect(error.validationType).toBe('latitude');             expect(error.invalidValue).toBe(91);         });     });      describe('Usage with Different Types', () => {         it('should handle numeric invalid values', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'latitude',                 91             );             expect(error.invalidValue).toBe(91);         });          it('should handle string invalid values', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'format',                 'invalid-format'             );             expect(error.invalidValue).toBe('invalid-format');         });          it('should handle object invalid values', () => {             const invalidObj = { lat: 91, lon: 0 };             const error = new GeoValidationError(                 'Invalid coordinate',                 'coordinate',                 invalidObj             );             expect(error.invalidValue).toBe(invalidObj);         });          it('should handle array invalid values', () => {             const invalidArray = [91, 0];             const error = new GeoValidationError(                 'Invalid coordinate',                 'coordinates',                 invalidArray             );             expect(error.invalidValue).toBe(invalidArray);         });     });      describe(TEST_CATEGORIES.ERROR_HANDLING, () => {         it('should handle empty strings', () => {             const error = new GeoValidationError('', '', '');             expect(error.message).toBe('');             expect(error.validationType).toBe('');             expect(error.invalidValue).toBe('');         });          it('should handle undefined cause', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'latitude',                 91,                 undefined             );             expect(error.cause).toBeUndefined();         });          it('should handle non-Error cause', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'latitude',                 91,                 'Not an error' as any             );             expect(error.cause).toBe('Not an error');         });          it('should handle null invalid values', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'coordinate',                 null             );             expect(error.invalidValue).toBeNull();         });          it('should handle undefined invalid values', () => {             const error = new GeoValidationError(                 'Invalid coordinate',                 'coordinate',                 undefined             );             expect(error.invalidValue).toBeUndefined();         });     }); });
|   |   -- models
|   |      +-- Angle.test.ts: import { describe, it, expect } from 'vitest'; import { Angle } from '../../../src/core/models/Angle'; import { Distance } from '../../../src/core/models/Distance'; import { Arc } from '../../../src/core/models/Arc'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import { assertAngleNearlyEqual } from '../../__helpers__/assertions'; import {     RIGHT_ANGLE,     STRAIGHT_ANGLE,     FULL_CIRCLE,     EQUILATERAL,     ACUTE,     OBTUSE,     NEGATIVE,     OVER_360 } from '../../__fixtures__/angles';  describe('Angle', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create angle with degrees', () => {             const angle = new Angle(90);             expect(angle.degrees).toBe(90);         });          it('should allow negative angles', () => {             const angle = new Angle(-45);             expect(angle.degrees).toBe(-45);         });          it('should allow angles over 360', () => {             const angle = new Angle(720);             expect(angle.degrees).toBe(720);         });     });      describe('Conversions', () => {         it('should convert degrees to radians', () => {             const angle = RIGHT_ANGLE;             expect(angle.toRadians()).toBeCloseTo(Math.PI / 2, 10);         });          it('should normalize angles to 0-360 range', () => {             const cases = [                 { input: 0, expected: 0 },                 { input: 360, expected: 0 },                 { input: 720, expected: 0 },                 { input: -90, expected: 270 },                 { input: -360, expected: 0 },                 { input: 45, expected: 45 },                 { input: 405, expected: 45 }             ];              cases.forEach(({ input, expected }) => {                 const angle = new Angle(input);                 expect(angle.normalize()).toBe(expected);             });         });     });      describe('Static Methods', () => {         it('should define angle using Law of Sines', () => {             // Setup triangle with known angles and sides             const arcA = new Distance(5);             const arcB = new Distance(7);             const arcC = new Distance(9);             const angleC = new Angle(60);              // Calculate using Law of Sines             const angleA = Angle.defineBy(                 Arc.onSphere(),                 Arc.onSphere(),                 angleC,                 arcA,                 arcB,                 arcC             );              // The result should satisfy the Law of Sines             const sinA = Math.sin(angleA.toRadians());             const sinC = Math.sin(angleC.toRadians());             const ratio = (arcA.inMeters() * sinC) / (arcC.inMeters() * sinA);             expect(ratio).toBeCloseTo(1, 5);         });          it('should define angle using Law of Cosines', () => {             // Setup triangle with known sides             const arcA = new Distance(5);             const arcB = new Distance(7);             const arcC = new Distance(9);              // Calculate using Law of Cosines             const angleC = Angle.defineBy(                 Arc.onSphere(),                 Arc.onSphere(),                 Arc.onSphere(),                 arcA,                 arcB,                 arcC             );              // Verify using Law of Cosines formula             const cosC = (                 Math.pow(arcA.inMeters(), 2) +                 Math.pow(arcB.inMeters(), 2) -                 Math.pow(arcC.inMeters(), 2)             ) / (2 * arcA.inMeters() * arcB.inMeters());                          const expectedAngle = new Angle(Math.acos(cosC) * 180 / Math.PI);             assertAngleNearlyEqual(angleC, expectedAngle);         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle 0 degrees', () => {             const angle = new Angle(0);             expect(angle.degrees).toBe(0);             expect(angle.toRadians()).toBe(0);         });          it('should handle 360 degrees', () => {             const angle = new Angle(360);             expect(angle.degrees).toBe(360);             expect(angle.toRadians()).toBeCloseTo(2 * Math.PI, 10);         });          it('should handle negative angles', () => {             const angle = NEGATIVE;  // -45 degrees             expect(angle.normalize()).toBe(315);         });          it('should handle angles over 360', () => {             const angle = OVER_360;  // 400 degrees             expect(angle.normalize()).toBe(40);         });     });      describe('String Representation', () => {         it('should format angle correctly', () => {             const angle = new Angle(45.5);             expect(angle.toString()).toBe('Angle(45.5 degrees)');         });     });      describe(TEST_CATEGORIES.REAL_WORLD, () => {         it('should handle right angle', () => {             assertAngleNearlyEqual(RIGHT_ANGLE, new Angle(90));         });          it('should handle straight angle', () => {             assertAngleNearlyEqual(STRAIGHT_ANGLE, new Angle(180));         });          it('should handle full circle', () => {             assertAngleNearlyEqual(FULL_CIRCLE, new Angle(360));         });          it('should handle equilateral triangle angle', () => {             assertAngleNearlyEqual(EQUILATERAL, new Angle(60));         });     }); });
|   |      +-- Arc.test.ts: // Arc test file  import { describe, it, expect } from 'vitest'; import { Arc } from '../../../src/core/models/Arc'; import { Angle } from '../../../src/core/models/Angle'; import { Distance } from '../../../src/core/models/Distance'; import { Sphere } from '../../../src/core/models/Sphere'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import { assertDistanceNearlyEqual, assertCoordinateNearlyEqual } from '../../__helpers__/assertions'; import {      LONDON,     PARIS,     NEW_YORK,     TOKYO,     EQUATOR_PRIME,     NORTH_POLE } from '../../__fixtures__/coordinates'; import {     EARTH_RADIUS,     LONDON_TO_PARIS,     TINY_DISTANCE,     ZERO_DISTANCE } from '../../__fixtures__/distances'; import { Coordinate } from '../../../src/core/models/Coordinate';  describe('Arc', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create arc on sphere with default radius', () => {             const arc = Arc.onSphere();             const circumference = arc.length();             assertDistanceNearlyEqual(                 circumference,                 Distance.fromKilometers(2 * Math.PI * 6371),                 1000             );         });          it('should create arc on sphere with custom radius', () => {             const radius = Distance.fromKilometers(1000);             const arc = Arc.onSphere(radius);             const circumference = arc.length();             assertDistanceNearlyEqual(                 circumference,                 Distance.fromKilometers(2 * Math.PI * 1000),                 1             );         });          it('should create arc from two points', () => {             const arc = Arc.fromPoints(LONDON, PARIS);             const length = arc.length();             assertDistanceNearlyEqual(length, LONDON_TO_PARIS, 1000);         });          it('should create arc with central angle', () => {             const angle = new Angle(90); // Quarter circle             const arc = Arc.onSphere(EARTH_RADIUS, angle);             const length = arc.length();             assertDistanceNearlyEqual(                 length,                 Distance.fromKilometers(Math.PI * 6371 / 2),                 1             );         });     });      describe('Length Calculations', () => {         it('should calculate zero length for same point', () => {             const arc = Arc.fromPoints(LONDON, LONDON);             assertDistanceNearlyEqual(arc.length(), ZERO_DISTANCE);         });          it('should calculate length of quarter earth circumference', () => {             const arc = Arc.fromPoints(EQUATOR_PRIME, NORTH_POLE);             assertDistanceNearlyEqual(                 arc.length(),                 Distance.fromKilometers(10000), // ~10,000 km (quarter Earth circumference)                 100             );         });          it('should calculate length of major city pairs', () => {             const testCases = [                 {                     start: LONDON,                     end: PARIS,                     expectedKm: 344                 },                 {                     start: NEW_YORK,                     end: TOKYO,                     expectedKm: 10838                 }             ];              testCases.forEach(({ start, end, expectedKm }) => {                 const arc = Arc.fromPoints(start, end);                 assertDistanceNearlyEqual(                     arc.length(),                     Distance.fromKilometers(expectedKm),                     100                 );             });         });     });      describe('Interpolation', () => {         it('should interpolate midpoint', () => {             const arc = Arc.fromPoints(LONDON, PARIS);             const midpoint = arc.interpolate(0.5);             expect(midpoint).toBeDefined();             if (midpoint) {                 // Verify midpoint is roughly equidistant from both endpoints                 const toStart = Arc.fromPoints(midpoint, LONDON).length();                 const toEnd = Arc.fromPoints(midpoint, PARIS).length();                 assertDistanceNearlyEqual(toStart, toEnd, 1);             }         });          it('should return start point for fraction 0', () => {             const arc = Arc.fromPoints(LONDON, PARIS);             const point = arc.interpolate(0);             expect(point).toBeDefined();             if (point) {                 assertCoordinateNearlyEqual(point, LONDON);             }         });          it('should return end point for fraction 1', () => {             const arc = Arc.fromPoints(LONDON, PARIS);             const point = arc.interpolate(1);             expect(point).toBeDefined();             if (point) {                 assertCoordinateNearlyEqual(point, PARIS);             }         });          it('should throw error for invalid fractions', () => {             const arc = Arc.fromPoints(LONDON, PARIS);             expect(() => arc.interpolate(-0.1)).toThrow();             expect(() => arc.interpolate(1.1)).toThrow();         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle antipodal points', () => {             const arc = Arc.fromPoints(                 new Coordinate(0, 0),                 new Coordinate(0, 180)             );             assertDistanceNearlyEqual(                 arc.length(),                 Distance.fromKilometers(20000), // ~20,000 km (half Earth circumference)                 100             );         });          it('should handle tiny arcs', () => {             const start = LONDON;             const end = new Coordinate(                 LONDON.latitude + 0.0001,                 LONDON.longitude + 0.0001             );             const arc = Arc.fromPoints(start, end);             expect(arc.length().inMeters()).toBeLessThan(100);         });     }); });
|   |      +-- Azimuth.test.ts: // Azimuth test file  
|   |      +-- Bearing.test.ts: // Bearing test file  import { describe, it, expect } from 'vitest'; import { Azimuth } from '../../../src/core/models/Azimuth'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import { assertAngleNearlyEqual } from '../../__helpers__/assertions'; import {     LONDON,     PARIS,     NEW_YORK,     TOKYO,     NORTH_POLE,     SOUTH_POLE,     EQUATOR_PRIME,     QUAD_1,     QUAD_2,     QUAD_3,     QUAD_4 } from '../../__fixtures__/coordinates'; import {     NORTH,     EAST,     SOUTH,     WEST } from '../../__fixtures__/angles'; import { Coordinate } from '../../../src/core/models/Coordinate'; import { Angle } from '../../../src';  describe('Azimuth', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create azimuth between two points', () => {             const azimuth = Azimuth.from(LONDON).to(PARIS);             expect(azimuth).toBeDefined();         });     });      describe('Forward Azimuth', () => {         it('should calculate forward azimuth between major cities', () => {             const testCases = [                 {                     start: LONDON,                     end: PARIS,                     expectedDegrees: 117  // Approximate                 },                 {                     start: NEW_YORK,                     end: TOKYO,                     expectedDegrees: 333  // Approximate                 }             ];              testCases.forEach(({ start, end, expectedDegrees }) => {                 const azimuth = Azimuth.from(start).to(end);                 assertAngleNearlyEqual(                     azimuth.forward(),                     new Angle(expectedDegrees),                     1                 );             });         });          it('should calculate cardinal directions from equator', () => {             // Test points 1 degree in each cardinal direction from equator             const north = new Coordinate(1, 0);             const east = new Coordinate(0, 1);             const south = new Coordinate(-1, 0);             const west = new Coordinate(0, -1);              assertAngleNearlyEqual(                 Azimuth.from(EQUATOR_PRIME).to(north).forward(),                 NORTH             );             assertAngleNearlyEqual(                 Azimuth.from(EQUATOR_PRIME).to(east).forward(),                 EAST             );             assertAngleNearlyEqual(                 Azimuth.from(EQUATOR_PRIME).to(south).forward(),                 SOUTH             );             assertAngleNearlyEqual(                 Azimuth.from(EQUATOR_PRIME).to(west).forward(),                 WEST             );         });     });      describe('Reverse Azimuth', () => {         it('should calculate reverse azimuth as forward + 180°', () => {             const testPoints = [                 [LONDON, PARIS],                 [NEW_YORK, TOKYO],                 [QUAD_1, QUAD_3],                 [QUAD_2, QUAD_4]             ];              testPoints.forEach(([start, end]) => {                 const azimuth = Azimuth.from(start).to(end);                 const forward = azimuth.forward().degrees;                 const reverse = azimuth.reverse().degrees;                 const diff = Math.abs((reverse - forward + 180) % 360);                 expect(diff).toBeLessThan(0.1);             });         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle poles', () => {             // All directions from North Pole are south             const fromNorthPole = Azimuth.from(NORTH_POLE).to(LONDON);             assertAngleNearlyEqual(fromNorthPole.forward(), SOUTH);              // All directions from South Pole are north             const fromSouthPole = Azimuth.from(SOUTH_POLE).to(LONDON);             assertAngleNearlyEqual(fromSouthPole.forward(), NORTH);         });          it('should handle antipodal points', () => {             const point1 = new Coordinate(0, 0);             const point2 = new Coordinate(0, 180);             const azimuth = Azimuth.from(point1).to(point2);             assertAngleNearlyEqual(azimuth.forward(), EAST);         });          it('should handle same point', () => {             const azimuth = Azimuth.from(LONDON).to(LONDON);             expect(azimuth.forward().degrees).toBeDefined();         });     });      describe('String Representation', () => {         it('should format azimuth correctly', () => {             const azimuth = Azimuth.from(LONDON).to(PARIS);             expect(azimuth.toString()).toBe(                 `Azimuth(${LONDON} → ${PARIS})`             );         });     }); });
|   |      +-- Coordinate.test.ts: // Coordinate test file  import { describe, it, expect } from 'vitest'; import { Coordinate } from '../../../src/core/models/Coordinate'; import { ERROR_MESSAGES, TEST_CATEGORIES } from '../../__helpers__/constants'; import { assertCoordinateNearlyEqual } from '../../__helpers__/assertions'; import {      LONDON,     TOKYO,     NORTH_POLE,     SOUTH_POLE,     MOUNT_EVEREST } from '../../__fixtures__/coordinates';  describe('Coordinate', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create a valid coordinate', () => {             const coord = new Coordinate(51.5074, -0.1278);             expect(coord.latitude).toBe(51.5074);             expect(coord.longitude).toBe(-0.1278);             expect(coord.altitude).toBeUndefined();         });          it('should create a coordinate with altitude', () => {             const coord = new Coordinate(27.9881, 86.9250, 8848);             expect(coord.latitude).toBe(27.9881);             expect(coord.longitude).toBe(86.9250);             expect(coord.altitude).toBe(8848);         });          it('should create coordinate using static factory method', () => {             const coord = Coordinate.at(51.5074, -0.1278);             expect(coord.latitude).toBe(51.5074);             expect(coord.longitude).toBe(-0.1278);         });     });      describe(TEST_CATEGORIES.VALIDATION, () => {         it('should throw error for latitude below -90', () => {             expect(() => new Coordinate(-91, 0))                 .toThrow(ERROR_MESSAGES.INVALID_LATITUDE);         });          it('should throw error for latitude above 90', () => {             expect(() => new Coordinate(91, 0))                 .toThrow(ERROR_MESSAGES.INVALID_LATITUDE);         });          it('should throw error for longitude below -180', () => {             expect(() => new Coordinate(0, -181))                 .toThrow(ERROR_MESSAGES.INVALID_LONGITUDE);         });          it('should throw error for longitude above 180', () => {             expect(() => new Coordinate(0, 181))                 .toThrow(ERROR_MESSAGES.INVALID_LONGITUDE);         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle North Pole', () => {             const coord = new Coordinate(90, 0);             expect(coord.latitude).toBe(90);             expect(coord.longitude).toBe(0);         });          it('should handle South Pole', () => {             const coord = new Coordinate(-90, 0);             expect(coord.latitude).toBe(-90);             expect(coord.longitude).toBe(0);         });          it('should handle International Date Line', () => {             const coord1 = new Coordinate(0, 180);             const coord2 = new Coordinate(0, -180);             expect(coord1.longitude).toBe(180);             expect(coord2.longitude).toBe(-180);         });     });      describe('Equality', () => {         it('should correctly compare equal coordinates', () => {             const coord1 = new Coordinate(51.5074, -0.1278);             const coord2 = new Coordinate(51.5074, -0.1278);             expect(coord1.equals(coord2)).toBe(true);         });          it('should correctly compare unequal coordinates', () => {             const coord1 = new Coordinate(51.5074, -0.1278);             const coord2 = new Coordinate(51.5074, -0.1279);             expect(coord1.equals(coord2)).toBe(false);         });          it('should handle altitude in equality comparison', () => {             const coord1 = new Coordinate(27.9881, 86.9250, 8848);             const coord2 = new Coordinate(27.9881, 86.9250);             expect(coord1.equals(coord2)).toBe(false);         });     });      describe('String Representation', () => {         it('should format coordinate without altitude', () => {             const coord = LONDON;             expect(coord.toString()).toBe('(51.5074°, -0.1278°)');         });          it('should format coordinate with altitude', () => {             const coord = MOUNT_EVEREST;             expect(coord.toString()).toBe('(27.9881°, 86.925°, 8848m)');         });     });      describe(TEST_CATEGORIES.REAL_WORLD, () => {         it('should correctly represent London coordinates', () => {             assertCoordinateNearlyEqual(                 LONDON,                 new Coordinate(51.5074, -0.1278)             );         });          it('should correctly represent Tokyo coordinates', () => {             assertCoordinateNearlyEqual(                 TOKYO,                 new Coordinate(35.6762, 139.6503)             );         });     }); });
|   |      +-- Distance.test.ts: import { describe, it, expect } from 'vitest'; import { Distance } from '../../../src/core/models/Distance'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import { assertDistanceNearlyEqual } from '../../__helpers__/assertions'; import {     ONE_KILOMETER,     ONE_MILE,     ONE_NAUTICAL_MILE,     LONDON_TO_PARIS } from '../../__fixtures__/distances';  describe('Distance', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create distance from meters', () => {             const distance = new Distance(1000);             expect(distance.inMeters()).toBe(1000);         });          it('should create distance from kilometers', () => {             const distance = Distance.fromKilometers(1);             expect(distance.inMeters()).toBe(1000);         });          it('should create distance from miles', () => {             const distance = Distance.fromMiles(1);             expect(distance.inMeters()).toBeCloseTo(1609.344, 2);         });          it('should create distance from nautical miles', () => {             const distance = Distance.fromNauticalMiles(1);             expect(distance.inMeters()).toBeCloseTo(1852, 2);         });          it('should create distance from feet', () => {             const distance = Distance.fromFeet(5280);             assertDistanceNearlyEqual(distance, ONE_MILE);         });     });      describe('Conversions', () => {         it('should convert to kilometers', () => {             const distance = new Distance(1000);             expect(distance.inKilometers()).toBe(1);         });          it('should convert to miles', () => {             const distance = new Distance(1609.344);             expect(distance.inMiles()).toBeCloseTo(1, 5);         });          it('should convert to nautical miles', () => {             const distance = new Distance(1852);             expect(distance.inNauticalMiles()).toBeCloseTo(1, 5);         });          it('should convert to feet', () => {             const distance = ONE_MILE;             expect(distance.inFeet()).toBeCloseTo(5280, 1);         });          it('should convert to yards', () => {             const distance = ONE_MILE;             expect(distance.inYards()).toBeCloseTo(1760, 1);         });     });      describe('Formatting', () => {         it('should format with default units', () => {             const distance = ONE_KILOMETER;             expect(distance.toString()).toBe('1.00 km');         });          it('should format with specified units', () => {             const distance = ONE_KILOMETER;             expect(distance.toFormat('km')).toBe('1.00 km');             expect(distance.toFormat('mi')).toMatch(/0.62 mi/);             expect(distance.toFormat('nm')).toMatch(/0.54 nm/);             expect(distance.toFormat('m')).toBe('1000.00 m');         });     });      describe(TEST_CATEGORIES.REAL_WORLD, () => {         it('should calculate London to Paris distance', () => {             assertDistanceNearlyEqual(                 LONDON_TO_PARIS,                 Distance.fromKilometers(344),                 1000  // 1km tolerance for real-world distance             );         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle zero distance', () => {             const distance = new Distance(0);             expect(distance.inMeters()).toBe(0);             expect(distance.inKilometers()).toBe(0);             expect(distance.inMiles()).toBe(0);         });          it('should handle very small distances', () => {             const distance = new Distance(0.0001);             expect(distance.inMeters()).toBeCloseTo(0.0001, 10);         });          it('should handle very large distances', () => {             const largeDistance = Distance.fromKilometers(1e6);             expect(largeDistance.inKilometers()).toBe(1e6);         });     }); });
|   |      +-- GreatCircle.test.ts: import { describe, it, expect } from 'vitest'; import { GreatCircle } from '../../../src/core/models/GreatCircle'; import { Distance } from '../../../src/core/models/Distance'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import {      assertDistanceNearlyEqual,     assertCoordinateNearlyEqual } from '../../__helpers__/assertions'; import {     LONDON,     PARIS,     EQUATOR_PRIME,     TOKYO } from '../../__fixtures__/coordinates'; import { ONE_KILOMETER } from '../../__fixtures__/distances'; import { Coordinate } from '../../../src/core/models/Coordinate';  describe('GreatCircle', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create great circle using factory method', () => {             const circle = GreatCircle.from(LONDON).to(PARIS);             expect(circle).toBeDefined();             expect(circle.toString()).toBe(`GreatCircle(${LONDON} → ${PARIS})`);         });          it('should allow custom sphere radius', () => {             const customRadius = Distance.fromKilometers(2000);             const circle = GreatCircle.from(LONDON)                 .to(PARIS)                 .withSphere(customRadius);             expect(circle).toBeDefined();         });     });      describe('Distance Calculations', () => {         it('should calculate correct distance between points', () => {             const circle = GreatCircle.from(LONDON).to(PARIS);             const distance = circle.distance();             assertDistanceNearlyEqual(                 distance,                 Distance.fromKilometers(344), // ~344km from London to Paris                 1000 // 1km tolerance             );         });          it('should handle zero distance', () => {             const circle = GreatCircle.from(LONDON).to(LONDON);             const distance = circle.distance();             expect(distance.inMeters()).toBe(0);         });          it('should handle antipodal points', () => {             const antipode = new Coordinate(-LONDON.latitude,                  LONDON.longitude + 180);             const circle = GreatCircle.from(LONDON).to(antipode);             const distance = circle.distance();             expect(distance.inKilometers()).toBeCloseTo(20000, -1); // ~20,000km         });     });      describe('Point Generation', () => {         it('should generate points with specified spacing', () => {             const circle = GreatCircle.from(LONDON).to(TOKYO);             const spacing = Distance.fromKilometers(500);             const points = circle.generatePoints({ spacing });                          // Verify point spacing             for (let i = 1; i < points.length; i++) {                 const segmentDistance = GreatCircle.from(points[i-1])                     .to(points[i])                     .distance();                 expect(segmentDistance.inKilometers())                     .toBeLessThanOrEqual(spacing.inKilometers() * 1.1);             }         });          it('should respect minimum points parameter', () => {             const circle = GreatCircle.from(LONDON).to(PARIS);             const minPoints = 10;             const points = circle.generatePoints({ minPoints });             expect(points.length).toBeGreaterThanOrEqual(minPoints);         });          it('should respect maximum points parameter', () => {             const circle = GreatCircle.from(LONDON).to(TOKYO);             const maxPoints = 50;             const points = circle.generatePoints({ maxPoints });             expect(points.length).toBeLessThanOrEqual(maxPoints);         });     });      describe('Interpolation', () => {         it('should interpolate midpoint', () => {             const circle = GreatCircle.from(LONDON).to(PARIS);             const midpoint = circle.interpolate(0.5);                          expect(midpoint).toBeDefined();             if (!midpoint) {                 throw new Error('Failed to interpolate midpoint');             }              // Check midpoint is equidistant from endpoints             const distToStart = GreatCircle.from(LONDON)                 .to(midpoint)                 .distance();             const distToEnd = GreatCircle.from(midpoint)                 .to(PARIS)                 .distance();                          assertDistanceNearlyEqual(distToStart, distToEnd, 1);         });          it('should handle fraction limits', () => {             const circle = GreatCircle.from(LONDON).to(PARIS);                          const start = circle.interpolate(0);             expect(start).toBeDefined();             if (start) {                 assertCoordinateNearlyEqual(start, LONDON);             }                          const end = circle.interpolate(1);             expect(end).toBeDefined();             if (end) {                 assertCoordinateNearlyEqual(end, PARIS);             }         });          it('should throw error for invalid fractions', () => {             const circle = GreatCircle.from(LONDON).to(PARIS);             expect(() => circle.interpolate(-0.1)).toThrow();             expect(() => circle.interpolate(1.1)).toThrow();         });     });      describe('Circle Extension', () => {         it('should extend great circle by distance', () => {             const original = GreatCircle.from(LONDON).to(PARIS);             const extension = Distance.fromKilometers(100);                          const extended = original.extend(extension);             const totalDistance = extended.distance();              // Calculate expected distance             const expectedDistance = new Distance(                 original.distance().inMeters() + extension.inMeters()             );                          assertDistanceNearlyEqual(totalDistance, expectedDistance, 1);         });          it('should maintain bearing when extending', () => {             const original = GreatCircle.from(LONDON).to(PARIS);             const extension = Distance.fromKilometers(100);                          const extended = original.extend(extension);             const endPoint = extended.interpolate(1);              expect(endPoint).toBeDefined();             if (!endPoint) {                 throw new Error('Failed to get end point');             }              // New end point should be further from start but in same direction             const newDistance = GreatCircle.from(LONDON)                 .to(endPoint)                 .distance();             expect(newDistance.inMeters())                 .toBeGreaterThan(original.distance().inMeters());         });     });      describe('Edge Cases', () => {         it('should handle date line crossing', () => {             const point1 = new Coordinate(0, 179);             const point2 = new Coordinate(0, -179);             const circle = GreatCircle.from(point1).to(point2);                          // Distance should be small despite longitude difference             expect(circle.distance().inKilometers()).toBeLessThan(300);                          // Interpolated points should form a continuous path             const points = circle.generatePoints({ minPoints: 10 });             for (let i = 1; i < points.length; i++) {                 const segmentDistance = GreatCircle.from(points[i-1])                     .to(points[i])                     .distance();                 expect(segmentDistance.inKilometers()).toBeLessThan(100);             }         });          it('should handle points at poles', () => {             const northPole = new Coordinate(90, 0);             const circle = GreatCircle.from(LONDON).to(northPole);                          const midpoint = circle.interpolate(0.5);             expect(midpoint).toBeDefined();             if (midpoint) {                 // Midpoint should be between start and pole latitudes                 expect(midpoint.latitude).toBeGreaterThan(LONDON.latitude);                 expect(midpoint.latitude).toBeLessThan(90);             }         });          it('should handle points on same meridian', () => {             const point1 = new Coordinate(0, 0);             const point2 = new Coordinate(45, 0);             const circle = GreatCircle.from(point1).to(point2);                          const midpoint = circle.interpolate(0.5);             expect(midpoint).toBeDefined();             if (midpoint) {                 expect(midpoint.longitude).toBe(0);                 expect(midpoint.latitude).toBe(22.5);             }         });     }); });
|   |      +-- Point.test.ts: // Point test file  import { describe, it, expect } from 'vitest'; import { Point } from '../../../src/core/models/Point'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import { MATH_CONSTANTS } from '../../__helpers__/constants';  describe('Point', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create a 2D point using factory method', () => {             const point = Point.at(1, 2);             expect(point.X).toBe(1);             expect(point.Y).toBe(2);             expect(point.Z).toBeUndefined();         });          it('should create a 3D point using factory method', () => {             const point = Point.at(1, 2, 3);             expect(point.X).toBe(1);             expect(point.Y).toBe(2);             expect(point.Z).toBe(3);         });     });      describe('Accessors', () => {         it('should provide read-only access to coordinates', () => {             const point = Point.at(1, 2, 3);             expect(point.X).toBe(1);             expect(point.Y).toBe(2);             expect(point.Z).toBe(3);         });     });      describe('Equality', () => {         it('should correctly compare equal 2D points', () => {             const point1 = Point.at(1, 2);             const point2 = Point.at(1, 2);             expect(point1.equals(point2)).toBe(true);         });          it('should correctly compare equal 3D points', () => {             const point1 = Point.at(1, 2, 3);             const point2 = Point.at(1, 2, 3);             expect(point1.equals(point2)).toBe(true);         });          it('should correctly compare unequal points', () => {             const point1 = Point.at(1, 2);             const point2 = Point.at(1, 3);             expect(point1.equals(point2)).toBe(false);         });          it('should handle Z coordinate in equality comparison', () => {             const point1 = Point.at(1, 2, 3);             const point2 = Point.at(1, 2);             expect(point1.equals(point2)).toBe(false);         });     });      describe('String Representation', () => {         it('should format 2D point correctly', () => {             const point = Point.at(1, 2);             expect(point.toString()).toBe('Point(1, 2)');         });          it('should format 3D point correctly', () => {             const point = Point.at(1, 2, 3);             expect(point.toString()).toBe('Point(1, 2, 3)');         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle zero coordinates', () => {             const point = Point.at(0, 0, 0);             expect(point.X).toBe(0);             expect(point.Y).toBe(0);             expect(point.Z).toBe(0);         });          it('should handle very large coordinates', () => {             const large = 1e10;             const point = Point.at(large, large);             expect(point.X).toBe(large);             expect(point.Y).toBe(large);         });          it('should handle very small coordinates', () => {             const small = MATH_CONSTANTS.EPSILON;             const point = Point.at(small, small);             expect(point.X).toBe(small);             expect(point.Y).toBe(small);         });     }); });
|   |      +-- Polygon.test.ts: // Polygon test file  
|   |      +-- SmallCircle.test.ts: import { describe, it, expect } from 'vitest'; import { SmallCircle } from '../../../src/core/models/SmallCircle'; import { Distance } from '../../../src/core/models/Distance'; import { Sphere } from '../../../src/core/models/Sphere'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import {      assertDistanceNearlyEqual,     assertCoordinateNearlyEqual,     assertAreaNearlyEqual } from '../../__helpers__/assertions'; import {     LONDON,     PARIS,     EQUATOR_PRIME,     NORTH_POLE,     CIRCLE_CENTER,     CIRCLE_POINT } from '../../__fixtures__/coordinates'; import {     EARTH_RADIUS,     ONE_KILOMETER,     TINY_DISTANCE } from '../../__fixtures__/distances'; import { GreatCircle } from '../../../src/core/models/GreatCircle'; import { Coordinate } from '../../../src/core/models/Coordinate';  describe('SmallCircle', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create small circle using factory method', () => {             const circle = SmallCircle.withCenter(CIRCLE_CENTER)                 .radius(ONE_KILOMETER);             expect(circle).toBeDefined();         });          it('should allow custom sphere radius', () => {             const customSphere = new Sphere();             const circle = SmallCircle.withCenter(CIRCLE_CENTER)                 .radius(ONE_KILOMETER)                 .withSphere(customSphere);             expect(circle).toBeDefined();         });     });      describe('Radius Handling', () => {         it('should retrieve radius using getRadius', () => {             const radius = ONE_KILOMETER;             const circle = SmallCircle.withCenter(CIRCLE_CENTER).radius(radius);             assertDistanceNearlyEqual(circle.getRadius(), radius);         });          it('should throw error for zero radius', () => {             expect(() => {                 SmallCircle.withCenter(CIRCLE_CENTER)                     .radius(Distance.fromMeters(0));             }).toThrow();         });          it('should throw error for negative radius', () => {             expect(() => {                 SmallCircle.withCenter(CIRCLE_CENTER)                     .radius(Distance.fromMeters(-100));             }).toThrow();         });     });      describe('Sphere Customization', () => {         it('should use custom sphere radius for calculations', () => {             const customRadius = Distance.fromKilometers(2000);             const circleRadius = Distance.fromKilometers(100);                          // Create circle with custom sphere radius             const circle = SmallCircle.withCenter(EQUATOR_PRIME)                 .radius(circleRadius)                 .withSphere(new Sphere());  // Pass the radius via getRadius                              // Test with custom radius             const sphereRadius = Sphere.getRadius(customRadius);                          // Create standard circle for comparison             const standardCircle = SmallCircle.withCenter(EQUATOR_PRIME)                 .radius(circleRadius);                          // Area and circumference should reflect custom sphere radius             expect(circle.area()).not.toBe(standardCircle.area());             expect(circle.circumference().inMeters())                 .not.toBe(standardCircle.circumference().inMeters());                          // Additional verification             assertDistanceNearlyEqual(                 Sphere.getRadius(customRadius),                  customRadius             );         });     });          describe('Circumference Calculations', () => {         it('should calculate circumference for various radiuses', () => {             const testCases = [                 {                     radius: Distance.fromKilometers(1),                     expected: Distance.fromKilometers(2 * Math.PI)                 },                 {                     radius: Distance.fromKilometers(10),                     expected: Distance.fromKilometers(20 * Math.PI)                 },                 {                     radius: Distance.fromKilometers(100),                     expected: Distance.fromKilometers(200 * Math.PI)                 }             ];              testCases.forEach(({ radius, expected }) => {                 const circle = SmallCircle.withCenter(EQUATOR_PRIME)                     .radius(radius);                 assertDistanceNearlyEqual(                     circle.circumference(),                     expected,                     radius.inMeters() * 0.01 // 1% tolerance                 );             });         });          it('should handle tiny circles', () => {             const circle = SmallCircle.withCenter(LONDON)                 .radius(TINY_DISTANCE);             expect(circle.circumference().inMeters())                 .toBeLessThan(TINY_DISTANCE.inMeters() * 2 * Math.PI * 1.1);         });     });      describe('Area Calculations', () => {         it('should calculate area for various radiuses', () => {             const testCases = [                 {                     radius: Distance.fromKilometers(1),                     expected: Math.PI // ~3.14 km²                 },                 {                     radius: Distance.fromKilometers(10),                     expected: 100 * Math.PI // ~314 km²                 },                 {                     radius: Distance.fromKilometers(100),                     expected: 10000 * Math.PI // ~31,416 km²                 }             ];              testCases.forEach(({ radius, expected }) => {                 const circle = SmallCircle.withCenter(EQUATOR_PRIME)                     .radius(radius);                 assertAreaNearlyEqual(                     circle.area(),                     expected,                     expected * 0.01 // 1% tolerance                 );             });         });     });      describe('Point Generation', () => {         it('should generate specified number of points', () => {             const circle = SmallCircle.withCenter(CIRCLE_CENTER)                 .radius(ONE_KILOMETER);             const numPoints = 100;             const points = circle.generatePoints(numPoints);                          expect(points.length).toBe(numPoints);                          // Verify all points are approximately at the specified radius             points.forEach(point => {                 const distance = GreatCircle.from(CIRCLE_CENTER)                     .to(point)                     .distance();                 assertDistanceNearlyEqual(                     distance,                     ONE_KILOMETER,                     ONE_KILOMETER.inMeters() * 0.01 // 1% tolerance                 );             });         });          it('should generate evenly spaced points', () => {             const circle = SmallCircle.withCenter(CIRCLE_CENTER)                 .radius(ONE_KILOMETER);             const points = circle.generatePoints(4);                          // Check consecutive points are equally spaced             const distances = [];             for (let i = 0; i < points.length; i++) {                 const nextPoint = points[(i + 1) % points.length];                 distances.push(                     GreatCircle.from(points[i])                         .to(nextPoint)                         .distance()                         .inMeters()                 );             }                          const avgDistance = distances.reduce((a, b) => a + b) / distances.length;             distances.forEach(dist => {                 expect(Math.abs(dist - avgDistance) / avgDistance)                     .toBeLessThan(0.01); // 1% tolerance             });         });     });      describe('Latitude Effects', () => {         it('should maintain consistent properties at different latitudes', () => {             const radius = ONE_KILOMETER;             const testLatitudes = [-60, -30, 0, 30, 60];                          const circles = testLatitudes.map(lat =>                  SmallCircle.withCenter(new Coordinate(lat, 0)).radius(radius)             );                          // Area should be the same regardless of latitude             const areas = circles.map(c => c.area());             const avgArea = areas.reduce((a, b) => a + b) / areas.length;             areas.forEach(area => {                 expect(Math.abs(area - avgArea) / avgArea).toBeLessThan(0.01);             });                          // Generate points and check they maintain radius             circles.forEach(circle => {                 const points = circle.generatePoints(8);                 points.forEach(point => {                     const distance = GreatCircle.from(CIRCLE_CENTER)                         .to(point)                         .distance();                     assertDistanceNearlyEqual(distance, radius);                 });             });         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle circles at poles', () => {             const circle = SmallCircle.withCenter(NORTH_POLE)                 .radius(ONE_KILOMETER);             const points = circle.generatePoints(4);             points.forEach(point => {                 expect(point.latitude).toBeLessThan(90);                 expect(point.latitude).toBeGreaterThan(89);             });         });          it('should handle circles crossing date line', () => {             const center = new Coordinate(0, 179.5);             const circle = SmallCircle.withCenter(center)                 .radius(Distance.fromKilometers(100));             const points = circle.generatePoints(100);                          // Verify some points cross the date line             const hasPositive = points.some(p => p.longitude > 0);             const hasNegative = points.some(p => p.longitude < 0);             expect(hasPositive && hasNegative).toBe(true);         });          it('should handle tiny circles', () => {             const circle = SmallCircle.withCenter(LONDON)                 .radius(TINY_DISTANCE);             const points = circle.generatePoints(4);                          points.forEach(point => {                 const distance = GreatCircle.from(LONDON)                     .to(point)                     .distance();                 expect(distance.inMeters())                     .toBeLessThan(TINY_DISTANCE.inMeters() * 1.1);             });         });     });      describe('String Representation', () => {         it('should format small circle correctly', () => {             const circle = SmallCircle.withCenter(CIRCLE_CENTER)                 .radius(ONE_KILOMETER);             expect(circle.toString()).toBe(                 `SmallCircle(center: ${CIRCLE_CENTER}, radius: ${ONE_KILOMETER})`             );         });     }); });
|   |      +-- Sphere.test.ts: // Sphere test file  import { describe, it, expect } from 'vitest'; import { Sphere } from '../../../src/core/models/Sphere'; import { Distance } from '../../../src/core/models/Distance'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import { assertDistanceNearlyEqual } from '../../__helpers__/assertions'; import {      EARTH_RADIUS,     ONE_KILOMETER,     TINY_DISTANCE  } from '../../__fixtures__/distances';  describe('Sphere', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should use default Earth radius when no radius provided', () => {             const radius = Sphere.getRadius();             assertDistanceNearlyEqual(radius, EARTH_RADIUS);         });          it('should use custom radius when provided', () => {             const customRadius = Distance.fromKilometers(2000);             const radius = Sphere.getRadius(customRadius);             assertDistanceNearlyEqual(radius, customRadius);         });     });      describe('Surface Area Calculations', () => {         it('should calculate surface area with default radius', () => {             const area = Sphere.surfaceAreaFromRadius(EARTH_RADIUS);             const expected = 4 * Math.PI * Math.pow(EARTH_RADIUS.inKilometers(), 2);             expect(area).toBeCloseTo(expected);         });          it('should calculate surface area with custom radius', () => {             const customRadius = Distance.fromKilometers(2000);             const area = Sphere.surfaceAreaFromRadius(customRadius);             const expected = 4 * Math.PI * Math.pow(customRadius.inKilometers(), 2);             expect(area).toBeCloseTo(expected);         });          it('should calculate surface area for small radius', () => {             const smallRadius = Distance.fromKilometers(1);             const area = Sphere.surfaceAreaFromRadius(smallRadius);             const expected = 4 * Math.PI; // 4πr² where r=1             expect(area).toBeCloseTo(expected);         });     });      describe('Volume Calculations', () => {         it('should calculate volume with default radius', () => {             const volume = Sphere.volumeFromRadius(EARTH_RADIUS);             const expected = (4/3) * Math.PI * Math.pow(EARTH_RADIUS.inKilometers(), 3);             expect(volume).toBeCloseTo(expected);         });          it('should calculate volume with custom radius', () => {             const customRadius = Distance.fromKilometers(2000);             const volume = Sphere.volumeFromRadius(customRadius);             const expected = (4/3) * Math.PI * Math.pow(customRadius.inKilometers(), 3);             expect(volume).toBeCloseTo(expected);         });          it('should calculate volume for small radius', () => {             const smallRadius = Distance.fromKilometers(1);             const volume = Sphere.volumeFromRadius(smallRadius);             const expected = (4/3) * Math.PI; // (4/3)πr³ where r=1             expect(volume).toBeCloseTo(expected);         });     });      describe('Radius Validation', () => {         it('should handle undefined radius by using Earth radius', () => {             const radius = Sphere.getRadius(undefined);             assertDistanceNearlyEqual(radius, EARTH_RADIUS);         });          it('should handle zero radius', () => {             const zeroRadius = Distance.fromKilometers(0);             const radius = Sphere.getRadius(zeroRadius);             expect(radius.inMeters()).toBe(0);         });          it('should handle very small radius', () => {             const radius = Sphere.getRadius(TINY_DISTANCE);             assertDistanceNearlyEqual(radius, TINY_DISTANCE);         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle very large radius', () => {             const largeRadius = Distance.fromKilometers(1e6); // 1 million km             const area = Sphere.surfaceAreaFromRadius(largeRadius);             const volume = Sphere.volumeFromRadius(largeRadius);                          expect(area).toBeGreaterThan(0);             expect(volume).toBeGreaterThan(0);             expect(Number.isFinite(area)).toBe(true);             expect(Number.isFinite(volume)).toBe(true);         });          it('should handle very small radius calculations', () => {             const tinyRadius = TINY_DISTANCE;             const area = Sphere.surfaceAreaFromRadius(tinyRadius);             const volume = Sphere.volumeFromRadius(tinyRadius);                          expect(area).toBeGreaterThan(0);             expect(volume).toBeGreaterThan(0);         });          it('should maintain precision for small values', () => {             const smallRadius = new Distance(0.1); // Changed from fromMeters             const area = Sphere.surfaceAreaFromRadius(smallRadius);             const volume = Sphere.volumeFromRadius(smallRadius);                          expect(area).toBeGreaterThan(0);             expect(volume).toBeGreaterThan(0);             expect(area).toBeLessThan(1);             expect(volume).toBeLessThan(1);         });     });      describe('Unit Consistency', () => {         it('should maintain consistent units in calculations', () => {             const radiusInKm = Distance.fromKilometers(1000);             const radiusInM = new Distance(1000000); // Changed from fromMeters                          const areaFromKm = Sphere.surfaceAreaFromRadius(radiusInKm);             const areaFromM = Sphere.surfaceAreaFromRadius(radiusInM);                          expect(areaFromKm).toBeCloseTo(areaFromM);         });     });      describe('Mathematical Properties', () => {         it('should maintain sphere volume to surface area relationship', () => {             const radius = Distance.fromKilometers(1000);             const volume = Sphere.volumeFromRadius(radius);             const area = Sphere.surfaceAreaFromRadius(radius);                          // Volume = (r/3) * Surface Area for a sphere             const volumeFromArea = (radius.inKilometers() / 3) * area;             expect(volume).toBeCloseTo(volumeFromArea);         });          it('should follow scaling laws', () => {             const radius1 = Distance.fromKilometers(1000);             const radius2 = Distance.fromKilometers(2000);                          const area1 = Sphere.surfaceAreaFromRadius(radius1);             const area2 = Sphere.surfaceAreaFromRadius(radius2);                          // Area should scale with square of radius             expect(area2 / area1).toBeCloseTo(4); // (2000/1000)^2 = 4         });     }); });
|   |      +-- SphericalTrigonometry.test.ts: // SphericalTrigonometry test file  import { describe, it, expect } from 'vitest'; import { SphericalTrigonometry } from '../../../src/core/models/SphericalTrigonometry'; import { Distance } from '../../../src/core/models/Distance'; import { Angle } from '../../../src/core/models/Angle'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import {      assertDistanceNearlyEqual,     assertAngleNearlyEqual } from '../../__helpers__/assertions'; import {     RIGHT_ANGLE,     EQUILATERAL } from '../../__fixtures__/angles';  describe('SphericalTrigonometry', () => {     describe('Law of Cosines', () => {         it('should calculate third side of right triangle', () => {             const arcA = Distance.fromKilometers(1000);             const arcB = Distance.fromKilometers(1000);             const angleC = RIGHT_ANGLE;              const arcC = SphericalTrigonometry.lawOfCosines(                 arcA,                 arcB,                 angleC             );              // For right triangle, c² ≈ a² + b² for small triangles             const expectedC = Math.sqrt(                 Math.pow(arcA.inMeters(), 2) +                  Math.pow(arcB.inMeters(), 2)             );             expect(arcC.inMeters()).toBeCloseTo(expectedC, -2); // Less precise for large distances         });          it('should calculate side of equilateral triangle', () => {             const arcA = Distance.fromKilometers(1000);             const arcB = Distance.fromKilometers(1000);             const angleC = EQUILATERAL;              const arcC = SphericalTrigonometry.lawOfCosines(                 arcA,                 arcB,                 angleC             );              // For equilateral triangle, all sides should be equal             assertDistanceNearlyEqual(arcC, arcA);             assertDistanceNearlyEqual(arcC, arcB);         });          it('should handle zero angle', () => {             const arcA = Distance.fromKilometers(1000);             const arcB = Distance.fromKilometers(1000);             const angleC = new Angle(0);              const arcC = SphericalTrigonometry.lawOfCosines(                 arcA,                 arcB,                 angleC             );              // For zero angle, c = |a - b|             const expected = Math.abs(arcA.inMeters() - arcB.inMeters());             expect(arcC.inMeters()).toBeCloseTo(expected);         });     });      describe('Law of Sines', () => {         it('should calculate side using known angle and side', () => {             const angleA = new Angle(30);             const angleB = new Angle(60);             const arcC = Distance.fromKilometers(1000);              const arcA = SphericalTrigonometry.lawOfSines(                 angleA,                 angleB,                 arcC             );              // Check using law of sines ratio             const sinA = Math.sin(angleA.toRadians());             const sinB = Math.sin(angleB.toRadians());             const ratio = arcA.inMeters() / arcC.inMeters();             expect(ratio).toBeCloseTo(sinA / sinB, 5);         });          it('should handle right angle', () => {             const angleA = new Angle(30);             const angleB = RIGHT_ANGLE;             const arcC = Distance.fromKilometers(1000);              const arcA = SphericalTrigonometry.lawOfSines(                 angleA,                 angleB,                 arcC             );              // For right triangle, sin(A) = a/c             const sinA = Math.sin(angleA.toRadians());             const ratio = arcA.inMeters() / arcC.inMeters();             expect(ratio).toBeCloseTo(sinA, 5);         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle very small angles', () => {             const angleA = new Angle(0.0001);             const angleB = new Angle(0.0002);             const arcC = Distance.fromKilometers(1);              const arcA = SphericalTrigonometry.lawOfSines(                 angleA,                 angleB,                 arcC             );              expect(arcA.inMeters()).toBeGreaterThan(0);         });          it('should handle very small distances', () => {             const arcA = new Distance(0.1); // Direct meters constructor             const arcB = new Distance(0.1); // Direct meters constructor             const angleC = new Angle(60);              const arcC = SphericalTrigonometry.lawOfCosines(                 arcA,                 arcB,                 angleC             );              expect(arcC.inMeters()).toBeGreaterThan(0);         });     });      describe('Numerical Stability', () => {         it('should maintain precision for small values', () => {             const arcA = new Distance(1); // Direct meters constructor             const arcB = new Distance(1); // Direct meters constructor             const angleC = new Angle(1);              const arcC = SphericalTrigonometry.lawOfCosines(                 arcA,                 arcB,                 angleC             );              expect(arcC.inMeters()).toBeGreaterThan(0);             expect(arcC.inMeters()).toBeLessThan(3); // Triangle inequality         });          it('should handle nearly equal distances', () => {             const arcA = Distance.fromKilometers(1000);             const arcB = Distance.fromKilometers(1000.000001);             const angleC = new Angle(60);              const arcC = SphericalTrigonometry.lawOfCosines(                 arcA,                 arcB,                 angleC             );              expect(arcC.inMeters()).toBeGreaterThan(0);         });     }); });
|   |      -- Triangle.test.ts: // Triangle test file  import { describe, it, expect } from 'vitest'; import { Triangle } from '../../../src/core/models/Triangle'; import { Angle } from '../../../src/core/models/Angle'; import { Distance } from '../../../src/core/models/Distance'; import { Sphere } from '../../../src/core/models/Sphere'; import { TEST_CATEGORIES } from '../../__helpers__/constants'; import {     assertDistanceNearlyEqual,     assertAngleNearlyEqual,     assertAreaNearlyEqual } from '../../__helpers__/assertions'; import {     LONDON,     PARIS,     NEW_YORK,     TRIANGLE_VERTEX_1,     TRIANGLE_VERTEX_2,     TRIANGLE_VERTEX_3 } from '../../__fixtures__/coordinates'; import {     EARTH_RADIUS } from '../../__fixtures__/distances'; import {     EQUILATERAL,     RIGHT_ANGLE } from '../../__fixtures__/angles'; import { Coordinate } from '../../../src/core/models/Coordinate';  describe('Triangle', () => {     describe(TEST_CATEGORIES.CONSTRUCTOR, () => {         it('should create triangle using factory method', () => {             const triangle = Triangle.from(TRIANGLE_VERTEX_1)                 .to(TRIANGLE_VERTEX_2)                 .and(TRIANGLE_VERTEX_3);             expect(triangle).toBeDefined();         });          it('should throw error for invalid vertex count', () => {             expect(() => {                 new Triangle([TRIANGLE_VERTEX_1, TRIANGLE_VERTEX_2] as any);             }).toThrow();         });     });      describe('Area Calculations', () => {         it('should calculate area of right triangle', () => {             // Create a right triangle at equator             const v1 = new Coordinate(0, 0);             const v2 = new Coordinate(0, 1);             const v3 = new Coordinate(1, 0);             const triangle = Triangle.from(v1).to(v2).and(v3);                          // Area should be non-zero and reasonable             const area = triangle.area();             expect(area).toBeGreaterThan(0);             expect(area).toBeLessThan(12000); // rough maximum possible area         });          it('should calculate area of equilateral triangle', () => {             // Create an equilateral triangle             const center = new Coordinate(0, 0);             const radius = Distance.fromKilometers(1000);             const angles = [0, 120, 240].map(deg => new Angle(deg));                          const vertices = angles.map(angle => {                 const lat = Math.asin(Math.sin(radius.inMeters() / EARTH_RADIUS.inMeters()) *                                      Math.cos(angle.toRadians()));                 const lon = Math.atan2(                     Math.sin(angle.toRadians()) *                      Math.sin(radius.inMeters() / EARTH_RADIUS.inMeters()) *                      Math.cos(center.latitude * Math.PI / 180),                     Math.cos(radius.inMeters() / EARTH_RADIUS.inMeters()) -                      Math.sin(center.latitude * Math.PI / 180) *                      Math.sin(lat)                 );                 return new Coordinate(lat * 180 / Math.PI, lon * 180 / Math.PI);             });              const triangle = Triangle.from(vertices[0])                 .to(vertices[1])                 .and(vertices[2]);              const area = triangle.area();             expect(area).toBeGreaterThan(0);                          // All angles should be 60 degrees             const triangleAngles = triangle.angles();             angles.forEach(angle => {                 assertAngleNearlyEqual(triangleAngles[0], EQUILATERAL);             });         });     });      describe('Perimeter Calculations', () => {         it('should calculate perimeter', () => {             const triangle = Triangle.from(LONDON)                 .to(PARIS)                 .and(NEW_YORK);                          const perimeter = triangle.perimeter();             const sides = triangle.sides();                          // Perimeter should equal sum of sides             const sumOfSides = new Distance(                 sides.reduce((sum, side) => sum + side.inMeters(), 0)             );             assertDistanceNearlyEqual(perimeter, sumOfSides);         });     });      describe('Angle Calculations', () => {         it('should calculate angles', () => {             const triangle = Triangle.from(LONDON)                 .to(PARIS)                 .and(NEW_YORK);                          const angles = triangle.angles();             expect(angles).toHaveLength(3);                          // Sum of angles in spherical triangle should be > 180°             const sumOfAngles = angles.reduce(                 (sum, angle) => sum + angle.degrees,                 0             );             expect(sumOfAngles).toBeGreaterThan(180);             expect(sumOfAngles).toBeLessThan(540); // Maximum possible is 540°         });          it('should calculate right angle in right triangle', () => {             // Create a right triangle at equator             const v1 = new Coordinate(0, 0);             const v2 = new Coordinate(0, 1);             const v3 = new Coordinate(1, 0);             const triangle = Triangle.from(v1).to(v2).and(v3);                          const angles = triangle.angles();             // One angle should be approximately 90°             const hasRightAngle = angles.some(                 angle => Math.abs(angle.degrees - 90) < 1             );             expect(hasRightAngle).toBe(true);         });     });      describe('Side Calculations', () => {         it('should calculate sides', () => {             const triangle = Triangle.from(LONDON)                 .to(PARIS)                 .and(NEW_YORK);                          const sides = triangle.sides();             expect(sides).toHaveLength(3);                          // All sides should be positive             sides.forEach(side => {                 expect(side.inMeters()).toBeGreaterThan(0);             });                          // Triangle inequality: sum of any two sides > third side             for (let i = 0; i < 3; i++) {                 const sum = sides[(i + 1) % 3].inMeters() +                            sides[(i + 2) % 3].inMeters();                 expect(sum).toBeGreaterThan(sides[i].inMeters());             }         });     });      describe(TEST_CATEGORIES.EDGE_CASES, () => {         it('should handle degenerate triangles', () => {             // Three points on equator 120° apart             const vertices = [0, 120, 240].map(lon =>                  new Coordinate(0, lon)             );                          const triangle = Triangle.from(vertices[0])                 .to(vertices[1])                 .and(vertices[2]);                          const area = triangle.area();             expect(area).toBeGreaterThan(0);                          // All angles should be equal             const angles = triangle.angles();             const firstAngle = angles[0].degrees;             angles.forEach(angle => {                 expect(Math.abs(angle.degrees - firstAngle))                     .toBeLessThan(1);             });         });          it('should handle triangles crossing date line', () => {             const triangle = Triangle.from(                 new Coordinate(0, 179)             ).to(                 new Coordinate(0, -179)             ).and(                 new Coordinate(1, 180)             );                          const area = triangle.area();             expect(area).toBeGreaterThan(0);             expect(area).toBeLessThan(1000); // Should be small         });          it('should handle triangles including poles', () => {             const triangle = Triangle.from(                 new Coordinate(90, 0)  // North pole             ).to(                 new Coordinate(0, 0)   // Equator at prime meridian             ).and(                 new Coordinate(0, 90)  // Equator at 90°E             );                          const area = triangle.area();             expect(area).toBeGreaterThan(0);                          const angles = triangle.angles();             // At pole, angle should be 90°             assertAngleNearlyEqual(angles[0], RIGHT_ANGLE);         });     });      describe('String Representation', () => {         it('should format triangle correctly', () => {             const triangle = Triangle.from(TRIANGLE_VERTEX_1)                 .to(TRIANGLE_VERTEX_2)                 .and(TRIANGLE_VERTEX_3);             expect(triangle.toString()).toBe(                 `Triangle(${TRIANGLE_VERTEX_1} → ${TRIANGLE_VERTEX_2} → ${TRIANGLE_VERTEX_3})`             );         });     }); });
|   +-- integration
|   |   +-- geojson-conversion.test.ts: import { describe, it, expect } from 'vitest'; import { TypeConverter } from '../../src/adapters/geojson/TypeConverter'; import { GeoConverter } from '../../src/adapters/geojson/GeoConverter'; import { Coordinate } from '../../src/core/models/Coordinate'; import { GreatCircle } from '../../src/core/models/GreatCircle'; import { SmallCircle } from '../../src/core/models/SmallCircle'; import { Triangle } from '../../src/core/models/Triangle'; import { Distance } from '../../src/core/models/Distance'; import {     LONDON,     PARIS,     NEW_YORK,     TOKYO } from '../__fixtures__/coordinates';  describe('GeoJSON Integration', () => {     describe('Route Planning Data Exchange', () => {         it('should convert complex route to GeoJSON and back', () => {             // Create a multi-leg route             const waypoints = [LONDON, PARIS, NEW_YORK, TOKYO];             const routes = [];                          // Generate route segments             for (let i = 0; i < waypoints.length - 1; i++) {                 const route = GreatCircle.from(waypoints[i]).to(waypoints[i + 1]);                 routes.push(route);             }                          // Convert to GeoJSON             const features = routes.map(route => TypeConverter.toFeature(route));                          // Convert back to routes             const reconvertedRoutes = features.map(feature =>                  TypeConverter.fromFeature(feature)             );                          expect(reconvertedRoutes.length).toBe(routes.length);             reconvertedRoutes.forEach(route => {                 expect(route).toBeInstanceOf(GreatCircle);             });         });          it('should preserve route properties in conversion', () => {             // Create route with specific properties             const route = GreatCircle.from(LONDON).to(TOKYO);             const distance = route.distance();                          // Convert to GeoJSON             const feature = TypeConverter.toFeature(route);                          // Verify properties are preserved             expect(feature.properties.distance).toBeDefined();             expect(feature.properties.distance).toBeCloseTo(                 distance.inMeters(),                 -2             );                          // Convert back and verify             const reconverted = TypeConverter.fromFeature(feature) as GreatCircle;             expect(reconverted.distance().inMeters()).toBeCloseTo(                 distance.inMeters(),                 -2             );         });     });      describe('Area Coverage Export/Import', () => {         it('should convert search patterns to GeoJSON and back', () => {             // Create search pattern with circles and triangles             const center = new Coordinate(40.7128, -74.006);             const searchCircle = SmallCircle.withCenter(center)                 .radius(Distance.fromKilometers(10));                          const points = searchCircle.generatePoints(3);             const searchTriangle = Triangle.from(points[0])                 .to(points[1])                 .and(points[2]);                          // Convert both to GeoJSON             const circleFeature = TypeConverter.toFeature(searchCircle);             const triangleFeature = TypeConverter.toFeature(searchTriangle);                          // Convert back             const reconvertedCircle = TypeConverter.fromFeature(circleFeature);             const reconvertedTriangle = TypeConverter.fromFeature(triangleFeature);                          expect(reconvertedCircle).toBeInstanceOf(SmallCircle);             expect(reconvertedTriangle).toBeInstanceOf(Triangle);         });          it('should handle collection of search areas', () => {             // Create multiple search areas             const areas = [];             const baseCenter = new Coordinate(40.7128, -74.006);                          // Generate 3 overlapping search circles             for (let i = 0; i < 3; i++) {                 const center = new Coordinate(                     baseCenter.latitude + (i * 0.01),                     baseCenter.longitude + (i * 0.01)                 );                 areas.push(                     SmallCircle.withCenter(center)                         .radius(Distance.fromKilometers(5))                 );             }                          // Convert all to GeoJSON             const features = areas.map(area => TypeConverter.toFeature(area));                          // Convert back             const reconverted = features.map(feature =>                  TypeConverter.fromFeature(feature)             );                          expect(reconverted.length).toBe(areas.length);             reconverted.forEach(area => {                 expect(area).toBeInstanceOf(SmallCircle);             });         });     });      describe('Data Validation and Error Handling', () => {         it('should handle invalid GeoJSON input', () => {             const invalidFeatures = [                 { type: 'Feature', geometry: null, properties: {} },                 { type: 'Feature', geometry: { type: 'Unknown' }, properties: {} },                 { type: 'Feature', geometry: { type: 'Point', coordinates: null }, properties: {} }             ];                          invalidFeatures.forEach(feature => {                 expect(() => TypeConverter.fromFeature(feature as any)).toThrow();             });         });          it('should validate coordinate ranges', () => {             const invalidCoordinates = [                 { type: 'Point', coordinates: [181, 0] },                 { type: 'Point', coordinates: [0, 91] },                 { type: 'Point', coordinates: [-181, -91] }             ];                          invalidCoordinates.forEach(geometry => {                 expect(() => TypeConverter.fromFeature({                     type: 'Feature',                     geometry,                     properties: {}                 } as any)).toThrow();             });         });     });      describe('Complex Data Structures', () => {         it('should handle nested geometry collections', () => {             // Create a complex search and rescue pattern             const center = new Coordinate(40.7128, -74.006);             const searchArea = SmallCircle.withCenter(center)                 .radius(Distance.fromKilometers(10));                          // Generate search pattern             const perimeterPoints = searchArea.generatePoints(8);             const searchPatterns: GreatCircle[] = [];                          // Create spokes from center to perimeter             perimeterPoints.forEach(point => {                 searchPatterns.push(GreatCircle.from(center).to(point));             });                          // Create perimeter segments             perimeterPoints.forEach((point, i) => {                 const nextPoint = perimeterPoints[(i + 1) % perimeterPoints.length];                 searchPatterns.push(GreatCircle.from(point).to(nextPoint));             });                          const features = searchPatterns.map(pattern =>                  TypeConverter.toFeature(pattern)             );                          // Convert back             const reconverted = features.map(feature =>                  TypeConverter.fromFeature(feature)             );                          expect(reconverted.length).toBe(searchPatterns.length);             reconverted.forEach(pattern => {                 expect(pattern).toBeDefined();             });         });          it('should preserve complex properties during conversion', () => {             const route = GreatCircle.from(LONDON).to(TOKYO);             const originalFeature = TypeConverter.toFeature(route);                          // Add complex properties             originalFeature.properties = {                 distance: route.distance().inMeters(),                 waypoints: [                     { name: 'London', coordinates: [LONDON.longitude, LONDON.latitude] },                     { name: 'Tokyo', coordinates: [TOKYO.longitude, TOKYO.latitude] }                 ],                 metadata: {                     created: new Date().toISOString(),                     type: 'flight-route',                     settings: {                         altitude: 35000,                         speed: 500                     }                 }             };                          // Convert back             const reconvertedRoute = TypeConverter.fromFeature(originalFeature);             const reconvertedFeature = TypeConverter.toFeature(reconvertedRoute);                          // Verify complex properties are preserved             expect(reconvertedFeature.properties.waypoints).toBeDefined();             expect(reconvertedFeature.properties.metadata).toBeDefined();             expect(reconvertedFeature.properties.metadata.settings).toBeDefined();         });     });      describe('Batch Processing', () => {         it('should handle bulk conversions', () => {             // Create a mix of geometric objects             const geometries = [                 LONDON, // Coordinate                 GreatCircle.from(LONDON).to(PARIS), // GreatCircle                 SmallCircle.withCenter(LONDON).radius(Distance.fromKilometers(10)), // SmallCircle                 Triangle.from(LONDON).to(PARIS).and(NEW_YORK) // Triangle             ];                          // Batch convert to GeoJSON             const features = geometries.map(geo => TypeConverter.toFeature(geo));                          // Batch convert back             const reconverted = features.map(feature =>                  TypeConverter.fromFeature(feature)             );                          expect(reconverted.length).toBe(geometries.length);             expect(reconverted[0]).toBeInstanceOf(Coordinate);             expect(reconverted[1]).toBeInstanceOf(GreatCircle);             expect(reconverted[2]).toBeInstanceOf(SmallCircle);             expect(reconverted[3]).toBeInstanceOf(Triangle);         });          it('should handle collection conversion', () => {             // Create a collection of similar objects             const routes = [                 GreatCircle.from(LONDON).to(PARIS),                 GreatCircle.from(PARIS).to(NEW_YORK),                 GreatCircle.from(NEW_YORK).to(TOKYO)             ];                          // Convert collection to GeoJSON             const collection = {                 type: 'FeatureCollection',                 features: routes.map(route => TypeConverter.toFeature(route))             };                          // Convert each feature back             const reconvertedRoutes = collection.features.map(feature =>                 TypeConverter.fromFeature(feature)             );                          expect(reconvertedRoutes.length).toBe(routes.length);             reconvertedRoutes.forEach(route => {                 expect(route).toBeInstanceOf(GreatCircle);             });         });     }); });
|   |   -- geometric-calculations.test.ts: import { describe, it, expect } from 'vitest'; import { Coordinate } from '../../src/core/models/Coordinate'; import { GreatCircle } from '../../src/core/models/GreatCircle'; import { SmallCircle } from '../../src/core/models/SmallCircle'; import { Triangle } from '../../src/core/models/Triangle'; import { Distance } from '../../src/core/models/Distance'; import { Angle } from '../../src/core/models/Angle'; import { Azimuth } from '../../src/core/models/Azimuth'; import { Bearing } from '../../src/core/models/Bearing'; import { assertDistanceNearlyEqual, assertAngleNearlyEqual } from '../__helpers__/assertions'; import {     LONDON,     PARIS,     NEW_YORK,     TOKYO } from '../__fixtures__/coordinates';  describe('Geometric Calculations Integration', () => {     describe('Flight Route Planning', () => {         it('should calculate great circle route with waypoints', () => {             // Flight from London to Tokyo with waypoint at Dubai             const dubai = new Coordinate(25.2532, 55.3657);                          // Calculate route segments             const leg1 = GreatCircle.from(LONDON).to(dubai);             const leg2 = GreatCircle.from(dubai).to(TOKYO);                          // Generate waypoints along route             const waypoints1 = leg1.generatePoints({ spacing: Distance.fromKilometers(500) });             const waypoints2 = leg2.generatePoints({ spacing: Distance.fromKilometers(500) });                          // Calculate total distance             const totalDistance = new Distance(                 leg1.distance().inMeters() + leg2.distance().inMeters()             );                          // Verify reasonable results             expect(waypoints1.length).toBeGreaterThan(5);             expect(waypoints2.length).toBeGreaterThan(5);             expect(totalDistance.inKilometers()).toBeGreaterThan(5000);         });          it('should handle flight path restrictions', () => {             // Simulate restricted airspace as a small circle             const restrictedZone = SmallCircle.withCenter(                 new Coordinate(50.0, 40.0)             ).radius(Distance.fromKilometers(500));                          // Calculate route points             const route = GreatCircle.from(LONDON).to(TOKYO);             const waypoints = route.generatePoints({ spacing: Distance.fromKilometers(100) });                          // Check if any waypoint intersects with restricted zone             const intersections = waypoints.filter(point => {                 const distanceToCenter = GreatCircle.from(restrictedZone.getCenter())                     .to(point)                     .distance();                 return distanceToCenter.inMeters() <= restrictedZone.getRadius().inMeters();             });                          // Store intersection points for potential rerouting             expect(intersections.length).toBeDefined();         });     });      describe('Maritime Navigation', () => {         it('should calculate shipping route with heading changes', () => {             // New York to Rotterdam shipping route             const rotterdam = new Coordinate(51.9225, 4.4792);             const route = GreatCircle.from(NEW_YORK).to(rotterdam);                          // Calculate initial and final bearings             const initialBearing = Bearing.from(NEW_YORK).to(rotterdam).initial();             const finalBearing = Bearing.from(NEW_YORK).to(rotterdam).final();                          // Generate navigation points every 100km             const navPoints = route.generatePoints({                  spacing: Distance.fromKilometers(100)              });                          // Calculate heading at each point             const headings = navPoints.map((point, i) => {                 if (i === navPoints.length - 1) return finalBearing;                 return Azimuth.from(point).to(navPoints[i + 1]).forward();             });                          // Verify reasonable results             expect(navPoints.length).toBeGreaterThan(10);             expect(headings.length).toBe(navPoints.length);             expect(Math.abs(headings[0].degrees - initialBearing.degrees))                 .toBeLessThan(1);         });          it('should handle emergency diversion scenarios', () => {             // Original route: NY to Rotterdam             const rotterdam = new Coordinate(51.9225, 4.4792);             const originalRoute = GreatCircle.from(NEW_YORK).to(rotterdam);                          // Emergency port: Halifax             const halifax = new Coordinate(44.6488, -63.5752);                          // Calculate diversion             const diversionRoute = GreatCircle.from(                 originalRoute.interpolate(0.3) as Coordinate             ).to(halifax);                          // Calculate new total distance             const distanceToEmergency = diversionRoute.distance();                          // Verify reasonable results             expect(distanceToEmergency.inKilometers()).toBeGreaterThan(0);             expect(distanceToEmergency.inKilometers()).toBeLessThan(                 originalRoute.distance().inKilometers()             );         });     });      describe('Area Coverage Analysis', () => {         it('should calculate search and rescue coverage area', () => {             // Last known position             const lastKnown = new Coordinate(40.7128, -74.006);                          // Create search patterns: expanding squares             const searchRadius = Distance.fromKilometers(10);             const searchCircle = SmallCircle.withCenter(lastKnown)                 .radius(searchRadius);                          // Generate perimeter points             const perimeterPoints = searchCircle.generatePoints(16);                          // Create search triangles for area coverage             const triangles = perimeterPoints.map((point, i) => {                 const nextPoint = perimeterPoints[(i + 1) % perimeterPoints.length];                 return Triangle.from(lastKnown).to(point).and(nextPoint);             });                          // Calculate total search area             const totalArea = triangles.reduce(                 (sum, triangle) => sum + triangle.area(),                 0             );                          // Verify coverage             expect(totalArea).toBeGreaterThan(0);             expect(triangles.length).toBe(16);         });          it('should handle overlapping coverage areas', () => {             // Two search areas with overlap             const center1 = new Coordinate(40.7128, -74.006);             const center2 = new Coordinate(40.7128, -73.95);             const radius = Distance.fromKilometers(5);                          const area1 = SmallCircle.withCenter(center1).radius(radius);             const area2 = SmallCircle.withCenter(center2).radius(radius);                          // Calculate distance between centers             const centerDistance = GreatCircle.from(center1)                 .to(center2)                 .distance();                          // Check for overlap             const hasOverlap = centerDistance.inMeters() <                  (area1.getRadius().inMeters() + area2.getRadius().inMeters());                          expect(hasOverlap).toBeDefined();             expect(area1.area() + area2.area()).toBeGreaterThan(0);         });     });      describe('Survey Route Planning', () => {         it('should generate parallel survey lines', () => {             // Survey area corners             const sw = new Coordinate(40.7, -74.1);             const se = new Coordinate(40.7, -73.9);             const ne = new Coordinate(40.8, -73.9);             const nw = new Coordinate(40.8, -74.1);                          // Create boundary             const boundary = [sw, se, ne, nw];                          // Generate parallel lines             const lineSpacing = Distance.fromKilometers(0.5);             const lines: GreatCircle[] = [];                          for (let i = 0; i < 5; i++) {                 const start = GreatCircle.from(sw).to(se)                     .interpolate(i/4) as Coordinate;                 const end = GreatCircle.from(nw).to(ne)                     .interpolate(i/4) as Coordinate;                                      lines.push(GreatCircle.from(start).to(end));             }                          // Calculate total survey distance             const totalDistance = lines.reduce(                 (sum, line) => sum + line.distance().inMeters(),                 0             );                          expect(lines.length).toBe(5);             expect(totalDistance).toBeGreaterThan(0);         });     }); });
|   -- utils
|      +-- conversion
|      -- math
+-- test-backup
|   +-- adapters
|   |   -- geojson
|   +-- core
|   |   +-- coordinate
|   |   -- models
|   |      +-- Arc.test.ts: import { describe, it, expect } from 'vitest' import { Arc } from '../src/models/Arc.js' import { Coordinate } from '../src/models/Coordinate.js' import { assertDistanceNearlyEqual } from './helpers/assertions'  describe('Arc Calculations', () => {   it('should create simple arc with default radius', () => {     const arc = Arc.onSphere()     const circumference = arc.length()     const expectedCircumference = 2 * Math.PI * 6371      assertDistanceNearlyEqual(       circumference.inKilometers(),       expectedCircumference,       1,       'Default arc should have Earth\'s circumference'     )   })    it('should calculate great circle arc between two points', () => {     const london = new Coordinate(51.5074, -0.1278)     const paris = new Coordinate(48.8566, 2.3522)     const arc = Arc.fromPoints(london, paris)     const length = arc.length()      assertDistanceNearlyEqual(       length.inKilometers(),       344,       1,       'London-Paris arc length should be about 344 km'     )   }) })
|   |      -- GreatCircle.test.ts: import { describe, it, expect } from 'vitest' import { GreatCircle } from '../src/models/GreatCircle.js' import { Coordinate } from '../src/models/Coordinate.js' import { Distance } from '../src/models/Distance.js'  describe('GreatCircle Calculations', () => {   const london = new Coordinate(51.5074, -0.1278)   const nyc = new Coordinate(40.7128, -74.0060)    it('should calculate distances using default Earth radius', () => {     const distance = new GreatCircle(london, nyc).distance()          // Second parameter specifies decimal points to check     expect(distance.inKilometers()).toBeCloseTo(5570, 0)     expect(distance.inMiles()).toBeCloseTo(3461, 0)   })    it('should handle zero distance', () => {     const distance = new GreatCircle(london, london)       .withSphere(Distance.fromKilometers(6371))       .distance()            expect(distance.inKilometers()).toBeCloseTo(0, 2)   }) })
|   +-- fixtures
|   -- utils
|      -- helpers
|         -- assertions.ts: // test/helpers/assertions.ts import assert from 'node:assert';  export function assertNearlyEqual(     actual: number,     expected: number,     tolerance: number,     message?: string ) {     const diff = Math.abs(actual - expected);     assert.ok(         diff <= tolerance,         message || `Expected ${actual} to be within ${tolerance} of ${expected} (diff: ${diff})`     ); }  export function assertDistanceNearlyEqual(     actual: number,     expected: number,     toleranceKm: number = 0.1,     message?: string ) {     assertNearlyEqual(         actual,         expected,         toleranceKm,         message || `Distance ${actual}km should be within ${toleranceKm}km of ${expected}km`     ); }
+-- test-setup.bat
+-- tree-content.py
+-- tsconfig.json
-- vitest.config.ts: import { defineConfig } from 'vitest/config'  export default defineConfig({   test: {     globals: true,     environment: 'node',     include: ['test/**/*.test.ts'],     coverage: {       provider: 'v8',       reporter: ['text', 'json', 'html'],     },     testTimeout: 20000,     hookTimeout: 20000,     teardownTimeout: 1000   } })
