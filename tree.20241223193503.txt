+-- .gitignore
+-- README.md
+-- package-lock.json
+-- package.json
+-- src
|   +-- CoordinateSystem.ts: import { Coordinate } from "./models/Coordinate"; import { Point } from "./models/Point";  export class CoordinateSystem {   static fromCoordinate(coord: Coordinate): Point {       const lat = coord.latitude * (Math.PI / 180);       const lon = coord.longitude * (Math.PI / 180);       return Point.at(lat, lon);   }    static fromPoint(point: Point): Coordinate {       const lat = point.X * (180 / Math.PI);       const lon = point.Y * (180 / Math.PI);       return Coordinate.at(lat, lon);   } }
|   +-- errors
|   |   +-- GeoConversionError.ts: import { GeoError } from './GeoError';  export class GeoConversionError extends GeoError {     constructor(         message: string,         public readonly sourceType: string,         public readonly targetType: string,         cause?: Error     ) {         super(message, cause);     } }
|   |   +-- GeoError.ts: export abstract class GeoError extends Error {   constructor(       message: string,       public readonly cause?: Error   ) {       super(message);       this.name = this.constructor.name;   } } 
|   |   +-- GeoValidationError.ts: import { GeoError } from './GeoError';  export class GeoValidationError extends GeoError {     constructor(         message: string,         public readonly validationType: string,         public readonly invalidValue: any,         cause?: Error     ) {         super(message, cause);     } }
|   |   -- index.ts: export * from './GeoError'; export * from './GeoConversionError'; export * from './GeoValidationError';
|   +-- geojson
|   |   +-- Feature.ts: // Feature.ts import { GeometryCollection } from "./GeometryCollection"; import { LineString } from "./LineString"; import { MultiLineString } from "./MultiLineString"; import { MultiPoint } from "./MultiPoint"; import { MultiPolygon } from "./MultiPolygon"; import { Point } from "./Point"; import { Polygon } from "./Polygon";  export interface Feature {   type: "Feature";   geometry: GeometryCollection | Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon;   properties: { [key: string]: any }; } 
|   |   +-- FeatureCollection.ts: // FeatureCollection.ts import { Feature } from "./Feature";  export interface FeatureCollection {   type: "FeatureCollection";   features: Feature[]; } 
|   |   +-- GeoConversionError.ts: import { Feature } from "./Feature";  export class GeoConversionError extends Error {   constructor(       message: string,       public readonly sourceType?: string,       public readonly targetType?: string,       public readonly cause?: Error   ) {       super(message);       this.name = 'GeoConversionError';   } }  // Add validation and error handling to existing classes: export class TypeValidator {   static validateFeature(feature: Feature): void {       if (!feature.type || feature.type !== 'Feature') {           throw new GeoConversionError('Invalid Feature type');       }       if (!feature.geometry) {           throw new GeoConversionError('Missing geometry');       }       // Add more validation   }    static validateGeometry(geometry: any): void {       // Geometry validation   } }
|   |   +-- GeoConverter.ts: import { Feature } from "./Feature"; import { GeoReader } from "./GeoReader"; import { GeoWriter } from "./GeoWriter";  export class GeoConverter {   static toGeoJSON(input: any): Feature | Feature[] {       if (Array.isArray(input)) {           return GeoWriter.writeCollection(input);       }       return GeoWriter.write(input);   }    static fromGeoJSON(input: Feature | Feature[]): any {       if (Array.isArray(input)) {           return GeoReader.readCollection(input);       }       return GeoReader.read(input);   } }  /* Example usage: const feature = GeoConverter.toGeoJSON(greatCircle); const circle = GeoConverter.fromGeoJSON(feature); */
|   |   +-- GeoReader.ts: import { Feature } from "./Feature"; import { GeoRegistry } from "./GeoRegistry";  export class GeoReader {   static read(feature: Feature): any {       return GeoRegistry.reverse(feature);   }    static readCollection(collection: Feature[]): any[] {       return collection.map(f => GeoReader.read(f));   } }  
|   |   +-- GeoRegistry.ts: import { TypeConverter } from './TypeConverter'; import { TypeMapping } from './TypeMapping'; import { Feature } from './Feature';  export class GeoRegistry {     private static readonly converters = new Map<string, TypeConverter>();      static register(type: any, converter: TypeConverter): void {         const geoType = TypeMapping.get(type);         if (!geoType) throw new Error(`No mapping for type ${type.name}`);         GeoRegistry.converters.set(type.name, converter);     }      static convert(source: any, target: string): any {         const converter = GeoRegistry.converters.get(source.constructor.name);         if (!converter) throw new Error(`No converter for ${source.constructor.name}`);         return TypeConverter.toFeature(source);     }      static reverse(feature: Feature): any {         return TypeConverter.fromFeature(feature);     } }
|   |   +-- GeoWriter.ts: import { Feature } from "./Feature"; import { GeoRegistry } from "./GeoRegistry";  export class GeoWriter {   static write(source: any): Feature {       return GeoRegistry.convert(source, 'Feature');   }    static writeCollection(sources: any[]): Feature[] {       return sources.map(s => GeoWriter.write(s));   } }
|   |   +-- GeometryCollection.ts: import { LineString } from "./LineString"; import { MultiLineString } from "./MultiLineString"; import { MultiPoint } from "./MultiPoint"; import { MultiPolygon } from "./MultiPolygon"; import { Point } from "./Point"; import { Polygon } from "./Polygon";  // GeometryCollection.ts export interface GeometryCollection {   type: "GeometryCollection";   geometries: Array<Point | LineString | Polygon | MultiPoint | MultiLineString | MultiPolygon | GeometryCollection>; } 
|   |   +-- LineString.ts: // LineString.ts import { Point } from "./Point";  export interface LineString {   type: "LineString";   coordinates: Point['coordinates'][]; } 
|   |   +-- MultiLineString.ts: // MultiLineString.ts import { LineString } from "./LineString";  export interface MultiLineString {   type: "MultiLineString";   coordinates: LineString['coordinates'][]; } 
|   |   +-- MultiPoint.ts: // MultiPoint.ts import { Point } from "./Point";  export interface MultiPoint {   type: "MultiPoint";   coordinates: Point['coordinates'][]; } 
|   |   +-- MultiPolygon.ts: // MultiPolygon.ts import { Polygon } from "./Polygon";  export interface MultiPolygon {   type: "MultiPolygon";   coordinates: Polygon['coordinates'][]; } 
|   |   +-- Point.ts: // Point.ts export interface Point {   type: "Point";   coordinates: [number, number]; // Longitude, Latitude } 
|   |   +-- Polygon.ts: // Polygon.ts import { LineString } from "./LineString";  export interface Polygon {   type: "Polygon";   coordinates: LineString['coordinates'][]; // Array of linear rings } 
|   |   +-- TypeConverter.ts: import { Coordinate } from '../models/Coordinate'; import { Point } from '../models/Point'; import { GreatCircle } from '../models/GreatCircle'; import { SmallCircle } from '../models/SmallCircle'; import { Triangle } from '../models/Triangle'; import { TypeMapping } from './TypeMapping'; import { Feature } from './Feature'; import { Distance } from '../models/Distance'; import { CoordinateSystem } from '../CoordinateSystem';  export class TypeConverter {     static toFeature(source: any): Feature {         const type = TypeMapping.get(source.constructor);         if (!type) {             throw new Error(`No mapping for type ${source.constructor.name}`);         }          try {             switch(type.type) {                 case "Point":                     if (source instanceof Coordinate) {                         return {                             type: "Feature",                             geometry: {                                 type: "Point",                                 coordinates: [source.longitude, source.latitude]                             },                             properties: {}                         };                     }                     return {                         type: "Feature",                         geometry: {                             type: "Point",                             coordinates: [0, 0] // Default return                         },                         properties: {}                     };                  case "LineString":                     if (source instanceof GreatCircle) {                         const points = source.generatePoints({ minPoints: 100 });                         return {                             type: "Feature",                             geometry: {                                 type: "LineString",                                 coordinates: points.map((p: Coordinate) => [p.longitude, p.latitude])                             },                             properties: {                                 distance: source.distance().inMeters()                             }                         };                     }                     return {                         type: "Feature",                         geometry: {                             type: "LineString",                             coordinates: []                         },                         properties: {}                     };                  case "Polygon":                     if (source instanceof SmallCircle) {                         const points = source.generatePoints(100);                         points.push(points[0]);                         return {                             type: "Feature",                             geometry: {                                 type: "Polygon",                                 coordinates: [points.map((p: Coordinate) => [p.longitude, p.latitude])]                             },                             properties: {                                 radius: source.getRadius().inMeters(),                                 area: source.area()                             }                         };                     }                     if (source instanceof Triangle) {                         const vertices = source.vertices;                         const allVertices = [...vertices, vertices[0]];                         return {                             type: "Feature",                             geometry: {                                 type: "Polygon",                                 coordinates: [allVertices.map((v: Coordinate) => [v.longitude, v.latitude])]                             },                             properties: {                                 area: source.area(),                                 perimeter: source.perimeter().inMeters()                             }                         };                     }                     return {                         type: "Feature",                         geometry: {                             type: "Polygon",                             coordinates: [[]]                         },                         properties: {}                     };             }              throw new Error(`Conversion not implemented for ${type.type}`);         } catch (exception: any) {             console.log('Conversion error:', exception);             return {                 type: "Feature",                 geometry: {                     type: "Point",                     coordinates: [0, 0]                 },                 properties: {}             };         }     }      static fromFeature(feature: Feature): any {         if (!feature.geometry) {             throw new Error('Invalid Feature: missing geometry');         }          try {             switch(feature.geometry.type) {                 case "Point":                     const [lon, lat] = feature.geometry.coordinates;                     return Coordinate.at(lat, lon);                  case "LineString":                     const coords = feature.geometry.coordinates;                     if (coords.length < 2) {                         throw new Error('Invalid LineString: needs at least 2 points');                     }                     const startCoord = Coordinate.at(coords[0][1], coords[0][0]);                     const endCoord = Coordinate.at(coords[coords.length - 1][1], coords[coords.length - 1][0]);                     return GreatCircle.from(startCoord).to(endCoord);                  case "Polygon":                     const vertices = feature.geometry.coordinates[0];                     if (vertices.length === 4 && feature.properties?.area) {                         const points = vertices.slice(0, -1).map(([lon, lat]) => Coordinate.at(lat, lon));                         return Triangle.from(points[0]).to(points[1]).and(points[2]);                     } else if (feature.properties?.radius) {                         const center = Coordinate.at(vertices[0][1], vertices[0][0]);                         const radius = new Distance(feature.properties.radius.inMeters());                         return SmallCircle.withCenter(center).radius(radius);                     }                     throw new Error('Unsupported Polygon type');             }              throw new Error(`Conversion not implemented for geometry type ${feature.geometry.type}`);         } catch (exception: any) {             console.log('Conversion error:', exception);             return null;         }     } }
|   |   -- TypeMapping.ts: import { Coordinate } from '../models/Coordinate'; import { Point } from '../models/Point'; import { GreatCircle } from '../models/GreatCircle'; import { SmallCircle } from '../models/SmallCircle'; import { Triangle } from '../models/Triangle'; import { Point as GeoJSONPoint } from './Point'; import { LineString } from './LineString'; import { Polygon } from './Polygon'; import { MultiPoint } from './MultiPoint'; import { MultiLineString } from './MultiLineString'; import { MultiPolygon } from './MultiPolygon';  export interface GeoType {     type: string;     coordinates: any; }  export class TypeMapping {     private static readonly map = new Map<any, GeoType>([         [Coordinate, { type: "Point", coordinates: [] }],         [Point, { type: "Point", coordinates: [] }],         [GreatCircle, { type: "LineString", coordinates: [] }],         [SmallCircle, { type: "Polygon", coordinates: [] }],         [Triangle, { type: "Polygon", coordinates: [] }]     ]);      static get(type: any): GeoType | null {         const mapping = TypeMapping.map.get(type);         if (!mapping) {             return null;         }         return { ...mapping }; // Return a copy to prevent modification     }      static set(sourceType: any, geoType: GeoType): void {         TypeMapping.map.set(sourceType, { ...geoType }); // Store a copy     }      static hasMapping(type: any): boolean {         return TypeMapping.map.has(type);     }      static getAllMappings(): Map<any, GeoType> {         return new Map(TypeMapping.map); // Return a copy     }      static getSourceTypeForGeoType(geoType: string): any[] {         const results: any[] = [];         TypeMapping.map.forEach((value, key) => {             if (value.type === geoType) {                 results.push(key);             }         });         return results;     }      static registerMapping(sourceType: any, geoType: GeoType): void {         if (!geoType.type || !["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"].includes(geoType.type)) {             throw new Error(`Invalid GeoJSON type: ${geoType.type}`);         }         TypeMapping.set(sourceType, geoType);     } }
|   +-- index.js
|   +-- index.ts: // Main entry point for the module.  
|   -- models
|      +-- Angle.js
|      +-- Angle.ts: import { Arc } from "./Arc"; import { Distance } from './Distance.js';    // Angle.ts export class Angle {     constructor(public readonly degrees: number) {}      // Add toRadians method     toRadians(): number {         return this.degrees * (Math.PI / 180);     }      normalize(): number {         return ((this.degrees % 360) + 360) % 360;     }      // Fix overload signatures     static defineBy(a: Arc, b: Arc, c: Arc | Angle, aLength?: Distance, bLength?: Distance, cLength?: Distance): Angle {         if (!aLength || !bLength || !cLength) {             throw new Error("Length parameters are required");         }          if (c instanceof Angle) {             // Law of Sines case             const sinA = Math.sin(c.toRadians());             const calculatedAngleDegrees = Math.asin(                 (aLength.inMeters() * Math.sin(c.toRadians())) / bLength.inMeters()             ) * (180 / Math.PI);              return new Angle(calculatedAngleDegrees);         } else {             // Law of Cosines case             const cosC = (                 Math.pow(aLength.inMeters(), 2) +                  Math.pow(bLength.inMeters(), 2) -                  Math.pow(cLength.inMeters(), 2)             ) / (2 * aLength.inMeters() * bLength.inMeters());              const calculatedAngleDegrees = Math.acos(cosC) * (180 / Math.PI);             return new Angle(calculatedAngleDegrees);         }     }      toString(): string {         return `Angle(${this.degrees} degrees)`;     } }  
|      +-- Arc.js
|      +-- Arc.ts: import { Angle } from "./Angle"; import { Coordinate } from "./Coordinate"; import { Distance } from "./Distance"; import { Sphere } from "./Sphere"; import { Point } from "./Point"; import { CoordinateSystem } from "../CoordinateSystem";  export class Arc {     private constructor(         private readonly sphereRadius: Distance,         private readonly centralAngle?: Angle,         private readonly start?: Coordinate,         private readonly end?: Coordinate     ) { }      static onSphere(         sphereRadius: Distance = Sphere.getRadius(),         centralAngle?: Angle     ): Arc {         return new Arc(sphereRadius, centralAngle);     }      static fromPoints(         start: Coordinate,         end: Coordinate,         sphereRadius: Distance = Sphere.getRadius()     ): Arc {         return new Arc(sphereRadius, undefined, start, end);     }      length(): Distance {         if (this.start && this.end) {             const startPoint = CoordinateSystem.fromCoordinate(this.start);             const endPoint = CoordinateSystem.fromCoordinate(this.end);              // Calculate central angle using haversine formula             const dLat = endPoint.Y - startPoint.Y;             const dLon = endPoint.X - startPoint.X;              const a =                 Math.sin(dLat / 2) ** 2 +                 Math.cos(startPoint.Y) * Math.cos(endPoint.Y) * Math.sin(dLon / 2) ** 2;              const centralAngle = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));              return new Distance(this.sphereRadius.inMeters() * centralAngle);         } else if (this.centralAngle) {             return new Distance(this.sphereRadius.inMeters() * this.centralAngle.toRadians());         } else {             return new Distance(2 * Math.PI * this.sphereRadius.inMeters());         }     }      interpolate(fraction: number): Coordinate | undefined {         if (fraction < 0 || fraction > 1) {             throw new Error('Fraction must be between 0 and 1');         }          if (this.start && this.end) {             const startPoint = CoordinateSystem.fromCoordinate(this.start);             const endPoint = CoordinateSystem.fromCoordinate(this.end);              const d = this.length().inMeters() / this.sphereRadius.inMeters();              const A = Math.sin((1 - fraction) * d) / Math.sin(d);             const B = Math.sin(fraction * d) / Math.sin(d);              const x =                 A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.cos(endPoint.X);             const y =                 A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.sin(endPoint.X);             const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y);              const lat3 = Math.atan2(z, Math.sqrt(x * x + y * y));             const lon3 = Math.atan2(y, x);              return CoordinateSystem.fromPoint(Point.at(lon3, lat3));         }         return undefined;     } }
|      +-- Azimuth.js
|      +-- Azimuth.ts: import { Coordinate } from './Coordinate'; import { Angle } from './Angle'; import { CoordinateSystem } from '../CoordinateSystem';  export class Azimuth {     private constructor(         private readonly start: Coordinate,         private readonly end: Coordinate     ) {}      static from = (start: Coordinate) => ({         to: (end: Coordinate) => new Azimuth(start, end)     });      forward = (): Angle => {         const startPoint = CoordinateSystem.fromCoordinate(this.start);         const endPoint = CoordinateSystem.fromCoordinate(this.end);          const dLon = endPoint.X - startPoint.X;         const y = Math.sin(dLon) * Math.cos(endPoint.Y);         const x = Math.cos(startPoint.Y) * Math.sin(endPoint.Y) -                  Math.sin(startPoint.Y) * Math.cos(endPoint.Y) * Math.cos(dLon);                  const azimuthRadians = Math.atan2(y, x);         const azimuthDegrees = (azimuthRadians * (180 / Math.PI) + 360) % 360;          return new Angle(azimuthDegrees);     };      reverse = (): Angle => {         const forward = this.forward().degrees;         return new Angle((forward + 180) % 360);     };      toString = (): string =>          `Azimuth(${this.start} → ${this.end})`; }
|      +-- Bearing.js
|      +-- Bearing.ts: import { Coordinate } from './Coordinate'; import { Angle } from './Angle'; import { Azimuth } from './Azimuth';  export class Bearing {     private constructor(         private readonly start: Coordinate,         private readonly end: Coordinate     ) {}      static from = (start: Coordinate) => ({         to: (end: Coordinate) => new Bearing(start, end)     });      initial = (): Angle =>          Azimuth.from(this.start).to(this.end).forward();      final = (): Angle =>          Azimuth.from(this.start).to(this.end).reverse();      toString = (): string =>          `Bearing(${this.start} → ${this.end})`; }
|      +-- Coordinate.js
|      +-- Coordinate.ts: export class Coordinate {     public constructor(         private readonly lat: number,         private readonly lon: number,         private readonly alt?: number     ) {         if (lat < -90 || lat > 90) {             throw new Error('Latitude must be between -90 and 90 degrees');         }         if (lon < -180 || lon > 180) {             throw new Error('Longitude must be between -180 and 180 degrees');         }     }      static at = (lat: number, lon: number, alt?: number) =>          new Coordinate(lat, lon, alt);      get latitude(): number {         return this.lat;     }      get longitude(): number {         return this.lon;     }      get altitude(): number | undefined {         return this.alt;     }      equals = (other: Coordinate): boolean =>          this.lat === other.lat &&          this.lon === other.lon &&          this.alt === other.alt;      toString = (): string =>         `(${this.lat}°, ${this.lon}°${this.alt ? `, ${this.alt}m` : ''})`; }
|      +-- Distance.ts: // Angle.ts remains the same...  // Distance.ts export class Distance {     private static readonly METERS_TO_NM = 0.000539957;      constructor(private readonly meters: number) {}      inMeters(): number {         return this.meters;     }      inKilometers(): number {         return this.meters / 1000;     }      inCentimeters(): number {         return this.meters * 100;     }      inMiles(): number {         return this.meters * 0.000621371;     }      inFeet(): number {         return this.meters * 3.28084;     }      inYards(): number {         return this.meters * 1.09361;     }      inNauticalMiles(): number {         return this.meters * Distance.METERS_TO_NM;     }      static fromKilometers(km: number): Distance {         return new Distance(km * 1000);     }      static fromMiles(miles: number): Distance {         return new Distance(miles / 0.000621371);     }      static fromNauticalMiles(nm: number): Distance {         return new Distance(nm / Distance.METERS_TO_NM);     }      static fromFeet(feet: number): Distance {         return new Distance(feet / 3.28084);     }      toString(): string {         return `${this.inKilometers().toFixed(2)} km`;     }      toFormat(unit: 'km' | 'mi' | 'nm' | 'ft' | 'm'): string {         switch(unit) {             case 'km': return `${this.inKilometers().toFixed(2)} km`;             case 'mi': return `${this.inMiles().toFixed(2)} mi`;             case 'nm': return `${this.inNauticalMiles().toFixed(2)} nm`;             case 'ft': return `${this.inFeet().toFixed(2)} ft`;             case 'm': return `${this.inMeters().toFixed(2)} m`;         }     } }
|      +-- GreatCircle.js
|      +-- GreatCircle.ts: import { CoordinateSystem } from '../CoordinateSystem'; import { Azimuth } from './Azimuth'; import { Coordinate } from './Coordinate'; import { Distance } from './Distance'; import { Point } from './Point'; import { Sphere } from './Sphere';  interface PointGenerationOptions {    spacing?: Distance;    minPoints?: number;    maxPoints?: number; }  export class GreatCircle {    public constructor(        private readonly start: Coordinate,        private readonly end: Coordinate,        private readonly sphereRadius: Distance = Sphere.getRadius()    ) {}     static from(start: Coordinate) {        return {            to: (end: Coordinate) => new GreatCircle(start, end)        };    }     withSphere = (sphereRadius: Distance): GreatCircle =>         new GreatCircle(this.start, this.end, sphereRadius);     distance = (): Distance => {        const startPoint = CoordinateSystem.fromCoordinate(this.start);        const endPoint = CoordinateSystem.fromCoordinate(this.end);                const dLat = endPoint.Y - startPoint.Y;        const dLon = endPoint.X - startPoint.X;                const a = Math.sin(dLat/2) ** 2 +                  Math.cos(startPoint.Y) *                  Math.cos(endPoint.Y) *                  Math.sin(dLon/2) ** 2;                         const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));                return new Distance(this.sphereRadius.inMeters() * c);    };     interpolate = (fraction: number): Coordinate | undefined => {        if (fraction < 0 || fraction > 1) {            throw new Error('Fraction must be between 0 and 1');        }         const startPoint = CoordinateSystem.fromCoordinate(this.start);        const endPoint = CoordinateSystem.fromCoordinate(this.end);                const d = this.distance().inMeters() / this.sphereRadius.inMeters();                const A = Math.sin((1 - fraction) * d) / Math.sin(d);        const B = Math.sin(fraction * d) / Math.sin(d);                const x = A * Math.cos(startPoint.Y) * Math.cos(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.cos(endPoint.X);        const y = A * Math.cos(startPoint.Y) * Math.sin(startPoint.X) +                 B * Math.cos(endPoint.Y) * Math.sin(endPoint.X);        const z = A * Math.sin(startPoint.Y) + B * Math.sin(endPoint.Y);                const lat = Math.atan2(z, Math.sqrt(x * x + y * y));        const lon = Math.atan2(y, x);                return CoordinateSystem.fromPoint(Point.at(lon, lat));    };     // Rest of the methods remain unchanged    generatePoints = (options: PointGenerationOptions): Coordinate[] => {        const totalDistance = this.distance();                let numPoints: number;        if (options.spacing) {            numPoints = Math.ceil(totalDistance.inMeters() / options.spacing.inMeters());        } else if (options.minPoints) {            numPoints = options.minPoints;        } else {            numPoints = 100;        }         if (options.maxPoints) {            numPoints = Math.min(numPoints, options.maxPoints);        }         const points: Coordinate[] = [];        for (let i = 0; i <= numPoints; i++) {            const fraction = i / numPoints;            const point = this.interpolate(fraction);            if (point) points.push(point);        }         return points;    };     extend = (distance: Distance): GreatCircle => {        const bearing = Azimuth.from(this.start).to(this.end).forward();        const endPoint = this.interpolate(1 + (distance.inMeters() / this.distance().inMeters()));        return endPoint ? GreatCircle.from(this.start).to(endPoint) : this;    };     midpoint = (): Coordinate =>         this.interpolate(0.5)!;     toString = (): string =>        `GreatCircle(${this.start} → ${this.end})`; }
|      +-- Point.ts: import { Coordinate } from "./Coordinate";  export class Point {    private constructor(        private readonly x: number,        private readonly y: number,        private readonly z?: number    ) {}     static at = (x: number, y: number, z?: number) =>        new Point(x, y, z);     get X(): number {        return this.x;    }     get Y(): number {        return this.y;    }     get Z(): number | undefined {        return this.z;    }     equals = (other: Point): boolean =>        this.x === other.x &&        this.y === other.y &&        this.z === other.z;     toString = (): string =>        `Point(${this.x}, ${this.y}${this.z ? `, ${this.z}` : ''})`; }
|      +-- Polygon.ts: import { Coordinate } from "./Coordinate"; import { Point } from "./Point"; import { CoordinateSystem } from "../CoordinateSystem";  export class Polygon {     constructor(private readonly vertices: Coordinate[]) {         if (vertices.length < 3) {             throw new Error("Polygon must have at least 3 vertices");         }     }      // Coordinate-based constructor     static fromCoordinates = (coords: Coordinate[]): Polygon =>          new Polygon(coords);      // Point-based constructor     static fromPoints = (points: Point[]): Polygon => {         const coords = points.map(p =>              CoordinateSystem.fromPoint(p)         );         return new Polygon(coords);     };      getVertices = (): Coordinate[] => this.vertices;      rewind = (): Polygon => {         const points = this.vertices.map(c => CoordinateSystem.fromCoordinate(c));         const fixed = this.ensureProperWindingPoints(points);         return Polygon.fromPoints(fixed);     };      private ensureProperWindingPoints = (points: Point[]): Point[] => {         // Calculate the signed area         let area = 0;         for (let i = 0; i < points.length; i++) {             const j = (i + 1) % points.length;             area += points[i].X * points[j].Y - points[j].X * points[i].Y;         }          // If area is negative (clockwise), reverse the points         if (area > 0) {             return [...points].reverse();         }         return points;     };      toString = (): string =>         `Polygon(${this.vertices.length} vertices)`; }
|      +-- SmallCircle.js
|      +-- SmallCircle.ts: import { Coordinate } from './Coordinate'; import { Point } from './Point'; import { Distance } from './Distance'; import { Angle } from './Angle'; import { Sphere } from './Sphere'; import { CoordinateSystem } from '../CoordinateSystem';  export class SmallCircle {     private readonly centerPoint: Point;      private constructor(         private readonly center: Coordinate,         private readonly circleRadius: Distance,         private readonly sphereRadius: Distance = Sphere.getRadius()     ) {         this.centerPoint = CoordinateSystem.fromCoordinate(center);     }      static withCenter = (center: Coordinate) => ({         radius: (radius: Distance) => new SmallCircle(center, radius)     });      withSphere = (sphere: Sphere): SmallCircle =>         new SmallCircle(this.center, this.circleRadius, Sphere.getRadius());      circumference = (): Distance => {         const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters();         return new Distance(2 * Math.PI * this.sphereRadius.inMeters() * Math.sin(angularRadius));     };      area = (): number => {         const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters();         const sphereRadiusKm = this.sphereRadius.inMeters() / 1000;         return 2 * Math.PI * Math.pow(sphereRadiusKm, 2) * (1 - Math.cos(angularRadius));     };      generatePoints = (numPoints: number = 100): Coordinate[] => {         const points: Coordinate[] = [];         const angularRadius = this.circleRadius.inMeters() / this.sphereRadius.inMeters();          for (let i = 0; i < numPoints; i++) {             const angle = (2 * Math.PI * i) / numPoints;             const latRad = Math.asin(                 Math.sin(this.centerPoint.Y) * Math.cos(angularRadius) +                 Math.cos(this.centerPoint.Y) * Math.sin(angularRadius) * Math.cos(angle)             );             const lonRad = this.centerPoint.X + Math.atan2(                 Math.sin(angle) * Math.sin(angularRadius) * Math.cos(this.centerPoint.Y),                 Math.cos(angularRadius) - Math.sin(this.centerPoint.Y) * Math.sin(latRad)             );              points.push(CoordinateSystem.fromPoint(Point.at(lonRad, latRad)));         }          return points;     };      getRadius = (): Distance => this.circleRadius;      toString = (): string =>         `SmallCircle(center: ${this.center}, radius: ${this.circleRadius})`; }
|      +-- Sphere.js
|      +-- Sphere.ts: import { Distance } from "./Distance";  export class Sphere {     private static readonly DEFAULT_RADIUS = Distance.fromKilometers(6371);      static getRadius = (radius?: Distance): Distance =>          radius ?? Sphere.DEFAULT_RADIUS;      static surfaceAreaFromRadius = (radius: Distance): number =>          4 * Math.PI * Math.pow(radius.inMeters() / 1000, 2);      static volumeFromRadius = (radius: Distance): number =>          (4/3) * Math.PI * Math.pow(radius.inMeters() / 1000, 3); }  // Usage: const radius = Sphere.getRadius();  // Default 6371km const customRadius = Sphere.getRadius(Distance.fromMiles(4000));
|      +-- SphericalTrigonometry.ts: import { Angle } from "./Angle"; import { Distance } from "./Distance";  // For Law of Sines/Cosines calculations, we should use Distance directly export class SphericalTrigonometry {   static lawOfCosines(arcA: Distance, arcB: Distance, angleC: Angle): Distance {       const a = arcA.inMeters();       const b = arcB.inMeters();       const C = angleC.toRadians();              const c = Math.sqrt(           Math.pow(a, 2) + Math.pow(b, 2) -            2 * a * b * Math.cos(C)       );        return new Distance(c);   }    static lawOfSines(angleA: Angle, angleB: Angle, arcC: Distance): Distance {       const A = angleA.toRadians();       const B = angleB.toRadians();       const C = Math.PI - (A + B);              const c = arcC.inMeters();       const a = Math.abs(c * Math.sin(A) / Math.sin(C));        return new Distance(a);   } }
|      +-- Triangle.js
|      -- Triangle.ts: import { Coordinate } from './Coordinate'; import { Point } from './Point'; import { Sphere } from './Sphere'; import { Distance } from './Distance'; import { Angle } from './Angle'; import { CoordinateSystem } from '../CoordinateSystem';  export class Triangle {     private readonly points: Point[];      private constructor(         private readonly triangleVertices: [Coordinate, Coordinate, Coordinate],         private readonly sphereRadius: Distance = Sphere.getRadius()     ) {         this.points = triangleVertices.map(v => CoordinateSystem.fromCoordinate(v));     }      static from = (a: Coordinate) => ({         to: (b: Coordinate) => ({             and: (c: Coordinate) => new Triangle([a, b, c])         })     });      withSphere = (sphere: Sphere): Triangle =>         new Triangle(this.triangleVertices, Sphere.getRadius());      area = (): number => {         const angles = this.angles();         const sphericalExcess = angles.reduce((sum, angle) => sum + angle.degrees, 0) - 180;         return sphericalExcess * (Math.PI / 180) * Math.pow(this.sphereRadius.inMeters() / 1000, 2);     };      perimeter = (): Distance => {         const sides = this.sides();         const totalMeters = sides.reduce((sum, side) => sum + side.inMeters(), 0);         return new Distance(totalMeters);     };      angles = (): [Angle, Angle, Angle] => {         return [0, 1, 2].map(i => {             const p1 = this.points[i];             const p2 = this.points[(i + 1) % 3];             const p3 = this.points[(i + 2) % 3];              const v1 = this.vectorBetween(p1, p2);             const v2 = this.vectorBetween(p1, p3);             const angle = this.angleBetweenVectors(v1, v2);              return new Angle(angle * (180 / Math.PI));         }) as [Angle, Angle, Angle];     };      sides = (): [Distance, Distance, Distance] => {         return [0, 1, 2].map(i => {             const start = this.points[i];             const end = this.points[(i + 1) % 3];             return this.sphericalDistance(start, end);         }) as [Distance, Distance, Distance];     };      private vectorBetween = (p1: Point, p2: Point): [number, number, number] => {         // Points are already in radians since we converted them in constructor         const x = Math.cos(p2.Y) * Math.cos(p2.X) - Math.cos(p1.Y) * Math.cos(p1.X);         const y = Math.cos(p2.Y) * Math.sin(p2.X) - Math.cos(p1.Y) * Math.sin(p1.X);         const z = Math.sin(p2.Y) - Math.sin(p1.Y);         return [x, y, z];     };      private angleBetweenVectors = (v1: [number, number, number], v2: [number, number, number]): number => {         const dot = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];         const mag1 = Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);         const mag2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);         return Math.acos(dot / (mag1 * mag2));     };      private sphericalDistance = (p1: Point, p2: Point): Distance => {         // Points are already in radians from CoordinateSystem conversion         const dLat = p2.Y - p1.Y;         const dLon = p2.X - p1.X;         const a = Math.sin(dLat/2) ** 2 +                 Math.cos(p1.Y) * Math.cos(p2.Y) *                 Math.sin(dLon/2) ** 2;         const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));         return new Distance(this.sphereRadius.inMeters() * c);     };      get vertices(): [Coordinate, Coordinate, Coordinate] {         return this.triangleVertices;     }      toString = (): string =>         `Triangle(${this.triangleVertices.map(v => v.toString()).join(' → ')})`; }
+-- test
|   +-- Arc.test.ts: import { describe, it, expect } from 'vitest' import { Arc } from '../src/models/Arc.js' import { Coordinate } from '../src/models/Coordinate.js' import { assertDistanceNearlyEqual } from './helpers/assertions'  describe('Arc Calculations', () => {   it('should create simple arc with default radius', () => {     const arc = Arc.onSphere()     const circumference = arc.length()     const expectedCircumference = 2 * Math.PI * 6371      assertDistanceNearlyEqual(       circumference.inKilometers(),       expectedCircumference,       1,       'Default arc should have Earth\'s circumference'     )   })    it('should calculate great circle arc between two points', () => {     const london = new Coordinate(51.5074, -0.1278)     const paris = new Coordinate(48.8566, 2.3522)     const arc = Arc.fromPoints(london, paris)     const length = arc.length()      assertDistanceNearlyEqual(       length.inKilometers(),       344,       1,       'London-Paris arc length should be about 344 km'     )   }) })
|   +-- GreatCircle.test.ts: import { describe, it, expect } from 'vitest' import { GreatCircle } from '../src/models/GreatCircle.js' import { Coordinate } from '../src/models/Coordinate.js' import { Distance } from '../src/models/Distance.js'  describe('GreatCircle Calculations', () => {   const london = new Coordinate(51.5074, -0.1278)   const nyc = new Coordinate(40.7128, -74.0060)    it('should calculate distances using default Earth radius', () => {     const distance = new GreatCircle(london, nyc).distance()          // Second parameter specifies decimal points to check     expect(distance.inKilometers()).toBeCloseTo(5570, 0)     expect(distance.inMiles()).toBeCloseTo(3461, 0)   })    it('should handle zero distance', () => {     const distance = new GreatCircle(london, london)       .withSphere(Distance.fromKilometers(6371))       .distance()            expect(distance.inKilometers()).toBeCloseTo(0, 2)   }) })
|   -- helpers
|      -- assertions.ts: // test/helpers/assertions.ts import assert from 'node:assert';  export function assertNearlyEqual(     actual: number,     expected: number,     tolerance: number,     message?: string ) {     const diff = Math.abs(actual - expected);     assert.ok(         diff <= tolerance,         message || `Expected ${actual} to be within ${tolerance} of ${expected} (diff: ${diff})`     ); }  export function assertDistanceNearlyEqual(     actual: number,     expected: number,     toleranceKm: number = 0.1,     message?: string ) {     assertNearlyEqual(         actual,         expected,         toleranceKm,         message || `Distance ${actual}km should be within ${toleranceKm}km of ${expected}km`     ); }
+-- tree-content.py
+-- tsconfig.json
-- vitest.config.ts: import { defineConfig } from 'vitest/config'  export default defineConfig({   test: {     globals: true,     environment: 'node',     include: ['test/**/*.test.ts'],     coverage: {       provider: 'v8',       reporter: ['text', 'json', 'html'],     },     testTimeout: 20000,     hookTimeout: 20000,     teardownTimeout: 1000   } })
