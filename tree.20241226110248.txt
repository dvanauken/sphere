+-- benchmarks
|   --- README.md: # Performance Benchmarks
+-- docs
|   --- README.md: # API Documentation
+-- examples
|   --- README.md: # Usage Examples
+-- scripts
|   --- README.md: # Build Scripts
+-- src
|   +-- adapters
|   |   \-- geojson
|   |       +-- converters
|   |       |   --- GeoConverter.ts: import { GeoJsonFeature, GeoJsonFeatureCollection } from "../types/index.js"; import { GeoConversionError } from "../errors/GeoConversionError.js"; import { Coordinate, GreatCircle, SmallCircle, Triangle } from "../../../index.js"; import { GeoReader } from "../readers/GeoReader.js"; import { GeoWriter } from "../writers/GeoWriter.js"; /** * Converts between spherical geometry objects and GeoJSON */ export class GeoConverter { /** * Converts a spherical geometry object or array of objects to GeoJSON * * @param input Single geometry object or array of objects * @returns GeoJSON Feature or FeatureCollection * @throws GeoConversionError if conversion fails */ static toGeoJSON( input: Coordinate | GreatCircle | SmallCircle | Triangle | Array<Coordinate | GreatCircle | SmallCircle | Triangle> ): GeoJsonFeature | GeoJsonFeatureCollection { try { if (Array.isArray(input)) { return { type: "FeatureCollection", features: GeoWriter.writeCollection(input) }; } return GeoWriter.write(input); } catch (error) { if (error instanceof GeoConversionError) { throw error; } throw new GeoConversionError( 'Failed to convert to GeoJSON', input?.constructor?.name ?? 'unknown', 'GeoJSON', error as Error ); } } /** * Converts a GeoJSON Feature or FeatureCollection to spherical geometry objects * * @param input GeoJSON Feature or FeatureCollection * @returns Single geometry object or array of objects * @throws GeoConversionError if conversion fails */ static fromGeoJSON( input: GeoJsonFeature | GeoJsonFeatureCollection ): Coordinate | GreatCircle | SmallCircle | Triangle | Array<Coordinate | GreatCircle | SmallCircle | Triangle> { try { // Validate input if (!input || typeof input !== 'object') { throw new GeoConversionError( 'Invalid GeoJSON input', 'unknown', 'spherical geometry' ); } // Handle FeatureCollection if (input.type === 'FeatureCollection') { if (!Array.isArray(input.features)) { throw new GeoConversionError( 'Invalid FeatureCollection: features must be an array', 'GeoJSON', 'spherical geometry' ); } return GeoReader.readCollection(input.features); } // Handle single Feature if (input.type === 'Feature') { return GeoReader.read(input); } throw new GeoConversionError( 'Invalid GeoJSON: must be Feature or FeatureCollection', 'unknown', 'spherical geometry' ); } catch (error) { if (error instanceof GeoConversionError) { throw error; } throw new GeoConversionError( 'Failed to convert from GeoJSON', 'GeoJSON', 'spherical geometry', error as Error ); } } /** * Validates if an object is a valid GeoJSON Feature */ static isValidFeature(obj: any): obj is GeoJsonFeature { return ( obj && typeof obj === 'object' && obj.type === 'Feature' && obj.geometry && typeof obj.geometry === 'object' && typeof obj.geometry.type === 'string' && Array.isArray(obj.geometry.coordinates) && obj.properties && typeof obj.properties === 'object' ); } /** * Validates if an object is a valid GeoJSON FeatureCollection */ static isValidFeatureCollection(obj: any): obj is GeoJsonFeatureCollection { return ( obj && typeof obj === 'object' && obj.type === 'FeatureCollection' && Array.isArray(obj.features) && obj.features.every((feature: any) => GeoConverter.isValidFeature(feature)) ); } } /* Example usage: import { GreatCircle, Coordinate } from '../core/models'; const startPoint = new Coordinate(51.5074, -0.1278); // London const endPoint = new Coordinate(48.8566, 2.3522); // Paris const greatCircle = GreatCircle.from(startPoint).to(endPoint); // Convert to GeoJSON const feature = GeoConverter.toGeoJSON(greatCircle); // Convert back to spherical geometry const circle = GeoConverter.fromGeoJSON(feature); // Convert multiple objects const features = GeoConverter.toGeoJSON([startPoint, greatCircle]); const geometries = GeoConverter.fromGeoJSON(features); */
|   |       |   --- TypeConverter.ts: import { GeoJsonFeature, GeoJsonPoint, GeoJsonLineString, GeoJsonPolygon } from "../types/index.js"; import { TypeMapping } from "./TypeMapping.js"; import { GeoConversionError } from "../errors/GeoConversionError.js"; import { Coordinate, GreatCircle, SmallCircle, Triangle, Distance, Angle, Azimuth, Arc } from "../../../index.js"; export class TypeConverter { static toFeature(source: any): GeoJsonFeature { const type = TypeMapping.get(source.constructor); if (!type) { throw new GeoConversionError( `No mapping for type ${source.constructor.name}`, source.constructor.name, 'GeoJsonFeature' ); } try { switch(type.type) { case "Point": if (source instanceof Coordinate) { return { type: "Feature", geometry: { type: "Point", coordinates: [source.longitude, source.latitude] } as GeoJsonPoint, properties: {} }; } return { type: "Feature", geometry: { type: "Point", coordinates: [0, 0] } as GeoJsonPoint, properties: {} }; case "LineString": if (source instanceof GreatCircle) { const points = source.generatePoints(100); return { type: "Feature", geometry: { type: "LineString", coordinates: points.map(p => [p.longitude, p.latitude]) } as GeoJsonLineString, properties: { type: "greatcircle" } }; } return { type: "Feature", geometry: { type: "LineString", coordinates: [] } as GeoJsonLineString, properties: {} }; case "Polygon": if (source instanceof SmallCircle) { const points = source.generatePoints(100); points.push(points[0]); // Close the ring return { type: "Feature", geometry: { type: "Polygon", coordinates: [points.map(p => [p.longitude, p.latitude])] } as GeoJsonPolygon, properties: { type: "smallcircle", radius: source.getRadius().inMeters(), area: source.area() } }; } if (source instanceof Triangle) { const vertices = source.getVertices(); const allVertices = [...vertices, vertices[0]]; // Close the ring return { type: "Feature", geometry: { type: "Polygon", coordinates: [allVertices.map(v => [v.longitude, v.latitude])] } as GeoJsonPolygon, properties: { type: "triangle", area: source.area(), perimeter: source.perimeter().inMeters() } }; } return { type: "Feature", geometry: { type: "Polygon", coordinates: [[]] } as GeoJsonPolygon, properties: {} }; } throw new GeoConversionError( `Conversion not implemented for ${type.type}`, source.constructor.name, 'GeoJsonFeature' ); } catch (error) { if (error instanceof GeoConversionError) { throw error; } throw new GeoConversionError( 'Error during conversion', source.constructor.name, 'GeoJsonFeature', error as Error ); } } static fromFeature(feature: GeoJsonFeature): any { if (!feature.geometry) { throw new GeoConversionError( 'Invalid Feature: missing geometry', 'GeoJsonFeature', 'unknown' ); } try { switch(feature.geometry.type) { case "Point": { const [lon, lat] = feature.geometry.coordinates; return Coordinate.at(lat, lon); } case "LineString": { const coords = feature.geometry.coordinates; if (coords.length < 2) { throw new GeoConversionError( 'Invalid LineString: needs at least 2 points', 'GeoJsonFeature', 'GreatCircle' ); } const center = Coordinate.at(coords[0][1], coords[0][0]); return GreatCircle.withCenter(center); } case "Polygon": { const coordinates = feature.geometry.coordinates[0]; switch (feature.properties?.type) { case "triangle": { if (coordinates.length !== 4) { throw new GeoConversionError( 'Triangle must have exactly 3 vertices plus closing point', 'GeoJsonFeature', 'Triangle' ); } const [coord1, coord2, coord3] = coordinates .slice(0, -1) .map(geoCoord => Coordinate.fromGeoJSON(geoCoord)); const arc1 = Arc.between(coord1, coord2); const arc2 = Arc.between(coord2, coord3); const sideA = arc1.length(); const sideB = arc2.length(); const bearingToC = Azimuth.from(coord2).to(coord3).forward(); const bearingFromA = Azimuth.from(coord2).to(coord1).forward(); const angleC = new Angle(Math.abs(bearingToC.degrees - bearingFromA.degrees)); return Triangle.fromSAS(sideA, angleC, sideB); } case "smallcircle": { if (!feature.properties?.radius) { throw new GeoConversionError( 'Small circle missing required radius property', 'GeoJsonFeature', 'SmallCircle' ); } const center = Coordinate.fromGeoJSON(coordinates[0]); const radius = new Distance(feature.properties.radius); return SmallCircle.withCenter(center).radius(radius); } default: throw new GeoConversionError( 'Unknown or missing polygon type in properties', 'GeoJsonFeature', 'unknown' ); } } default: throw new GeoConversionError( `Conversion not implemented for geometry type ${feature.geometry.type}`, 'GeoJsonFeature', 'unknown' ); } } catch (error) { if (error instanceof GeoConversionError) { throw error; } throw new GeoConversionError( 'Error during conversion', 'GeoJsonFeature', 'unknown', error as Error ); } } }
|   |       |   --- TypeMapping.ts: import { GeoJsonPoint, GeoJsonMultiPoint, GeoJsonLineString, GeoJsonMultiLineString, GeoJsonPolygon, GeoJsonMultiPolygon } from "../types/index.js"; import { Point, Arc, Polygon } from "../../../index.js"; export interface GeoType { type: string; coordinates: number[] | number[][] | number[][][] | number[][][][]; } type InternalType = typeof Point | typeof Arc | typeof Polygon | typeof Array; type GeoJSONType = "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon"; export class TypeMapping { private static readonly internalToGeoMap = new Map<InternalType, GeoJSONType>([ [Point, "Point"], [Array, "MultiPoint"], [Arc, "LineString"], [Array, "MultiLineString"], [Polygon, "Polygon"], [Array, "MultiPolygon"] ]); private static readonly geoToInternalMap = new Map<GeoJSONType, InternalType>([ ["Point", Point], ["MultiPoint", Array], ["LineString", Arc], ["MultiLineString", Array], ["Polygon", Polygon], ["MultiPolygon", Array] ]); static getGeoType(internalType: any): GeoJSONType | undefined { if (Array.isArray(internalType)) { const firstElement = internalType[0]; if (firstElement instanceof Point) return "MultiPoint"; if (firstElement instanceof Arc) return "MultiLineString"; if (firstElement instanceof Polygon) return "MultiPolygon"; return undefined; } return TypeMapping.internalToGeoMap.get(internalType.constructor); } static getInternalType(geoType: GeoJSONType): InternalType | undefined { return TypeMapping.geoToInternalMap.get(geoType); } static hasInternalMapping(type: any): boolean { if (Array.isArray(type)) { const firstElement = type[0]; return firstElement instanceof Point || firstElement instanceof Arc || firstElement instanceof Polygon; } return TypeMapping.internalToGeoMap.has(type.constructor); } static hasGeoMapping(type: GeoJSONType): boolean { return TypeMapping.geoToInternalMap.has(type); } static getAllMappings(): Map<InternalType, GeoJSONType> { return new Map(TypeMapping.internalToGeoMap); } static getAllGeoTypes(): GeoJSONType[] { return Array.from(TypeMapping.geoToInternalMap.keys()); } static getAllSourceTypes(): InternalType[] { return Array.from(TypeMapping.internalToGeoMap.keys()); } static getSourceTypeForGeoType(geoType: GeoJSONType): InternalType[] { const sourceType = TypeMapping.geoToInternalMap.get(geoType); return sourceType ? [sourceType] : []; } static registerMapping(internalType: InternalType, geoType: GeoJSONType): void { const validTypes: GeoJSONType[] = [ "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon" ]; if (!validTypes.includes(geoType)) { throw new Error(`Invalid GeoJSON type: ${geoType}. Must be one of: ${validTypes.join(', ')}`); } TypeMapping.internalToGeoMap.set(internalType, geoType); TypeMapping.geoToInternalMap.set(geoType, internalType); } static validateCoordinates(type: GeoJSONType, coords: any): boolean { switch (type) { case "Point": return Array.isArray(coords) && coords.length === 2 && coords.every(c => typeof c === 'number'); case "MultiPoint": case "LineString": return Array.isArray(coords) && coords.length > 0 && coords.every(p => Array.isArray(p) && p.length === 2 && p.every(c => typeof c === 'number')); case "MultiLineString": case "Polygon": return Array.isArray(coords) && coords.length > 0 && coords.every(line => Array.isArray(line) && line.length > 0 && line.every(p => Array.isArray(p) && p.length === 2 && p.every(c => typeof c === 'number'))); case "MultiPolygon": return Array.isArray(coords) && coords.length > 0 && coords.every(poly => Array.isArray(poly) && poly.length > 0 && poly.every(line => Array.isArray(line) && line.length > 0 && line.every(p => Array.isArray(p) && p.length === 2 && p.every(c => typeof c === 'number')))); default: return false; } } }
|   |       |   --- index.ts: // Converters index.ts
|   |       +-- errors
|   |       |   --- GeoConversionError.ts: import { GeoJsonFeature } from "../types/GeoJsonFeature.js"; export class GeoConversionError extends Error { constructor( message: string, public readonly sourceType?: string, public readonly targetType?: string, public readonly cause?: Error ) { super(message); this.name = 'GeoConversionError'; } } // Add validation and error handling to existing classes: export class TypeValidator { static validateFeature(feature: Feature): void { if (!feature.type || feature.type !== 'Feature') { throw new GeoConversionError('Invalid Feature type'); } if (!feature.geometry) { throw new GeoConversionError('Missing geometry'); } // Add more validation } static validateGeometry(geometry: any): void { // Geometry validation } }
|   |       |   --- index.ts: // Errors index.ts
|   |       +-- readers
|   |       |   --- GeoReader.ts: import { GeoJsonFeature, GeoJsonLineString, GeoJsonPolygon } from "../types/index.js"; import { GeoRegistry } from "./GeoRegistry.js"; import { GeoConversionError } from "../errors/GeoConversionError.js"; import { Coordinate, GreatCircle, SmallCircle, Triangle } from "../../../index.js"; export class GeoReader { /** * Reads a GeoJSON Feature and converts it to a spherical geometry object */ static read(feature: GeoJsonFeature): Coordinate | GreatCircle | SmallCircle | Triangle { if (!feature || !feature.geometry) { throw new GeoConversionError( 'Invalid Feature: missing geometry', 'GeoJSON', 'spherical geometry' ); } try { return GeoRegistry.reverse(feature); } catch (error) { if (error instanceof GeoConversionError) { throw error; } throw new GeoConversionError( 'Failed to read GeoJSON feature', 'GeoJSON', 'spherical geometry', error as Error ); } } /** * Reads an array of GeoJSON Features and converts them to spherical geometry objects */ static readCollection( collection: GeoJsonFeature[] ): Array<Coordinate | GreatCircle | SmallCircle | Triangle> { if (!Array.isArray(collection)) { throw new GeoConversionError( 'Invalid collection: expected array of features', 'GeoJSON', 'spherical geometry' ); } try { return collection.map((feature, index) => { try { return GeoReader.read(feature); } catch (error) { // Enhance error with feature index throw new GeoConversionError( `Failed to read feature at index ${index}`, 'GeoJSON', 'spherical geometry', error as Error ); } }); } catch (error) { if (error instanceof GeoConversionError) { throw error; } throw new GeoConversionError( 'Failed to read feature collection', 'GeoJSON', 'spherical geometry', error as Error ); } } /** * Type guard to check if a geometry is a Point */ private static isPoint( geometry: GeoJsonFeature['geometry'] ): geometry is GeoJsonPoint { return geometry.type === 'Point'; } /** * Type guard to check if a geometry is a LineString */ private static isLineString( geometry: GeoJsonFeature['geometry'] ): geometry is GeoJsonLineString { return geometry.type === 'LineString'; } /** * Type guard to check if a geometry is a Polygon */ private static isPolygon( geometry: GeoJsonFeature['geometry'] ): geometry is GeoJsonPolygon { return geometry.type === 'Polygon'; } }
|   |       |   --- GeoRegistry.ts: import { TypeConverter } from "../converters/TypeConverter.js"; import { TypeMapping } from "../converters/TypeMapping.js"; import { GeoJsonFeature } from "../types/GeoJsonFeature.js"; export class GeoRegistry { private static readonly converters = new Map<string, TypeConverter>(); static register(type: any, converter: TypeConverter): void { const geoType = TypeMapping.get(type); if (!geoType) throw new Error(`No mapping for type ${type.name}`); GeoRegistry.converters.set(type.name, converter); } static convert(source: any, target: string): any { const converter = GeoRegistry.converters.get(source.constructor.name); if (!converter) throw new Error(`No converter for ${source.constructor.name}`); return TypeConverter.toFeature(source); } static reverse(feature: GeoJsonFeature): any { return TypeConverter.fromFeature(feature); } }
|   |       |   --- index.ts: // Readers index.ts
|   |       +-- types
|   |       |   --- GeoJsonFeature.ts: // GeoJsonFeature.ts import { GeoJsonGeometryCollection } from "./GeoJsonGeometryCollection.js"; import { GeoJsonPoint } from "./GeoJsonPoint.js"; import { GeoJsonLineString } from "./GeoJsonLineString.js"; import { GeoJsonMultiLineString } from "./GeoJsonMultiLineString.js"; import { GeoJsonMultiPolygon } from "./GeoJsonMultiPolygon.js"; import { GeoJsonPolygon } from "./GeoJsonPolygon.js"; import { GeoJsonMultiPoint } from "./GeoJsonMultiPoint.js"; export interface GeoJsonFeature { type: "Feature"; geometry: | GeoJsonGeometryCollection | GeoJsonPoint | GeoJsonLineString | GeoJsonPolygon | GeoJsonMultiPoint | GeoJsonMultiLineString | GeoJsonMultiPolygon; properties: { [key: string]: any }; }
|   |       |   --- GeoJsonFeatureCollection.ts: // GeoJsonFeatureCollection.ts import { GeoJsonFeature } from "./GeoJsonFeature.js"; export interface GeoJsonFeatureCollection { type: "FeatureCollection"; features: GeoJsonFeature[]; }
|   |       |   --- GeoJsonGeometryCollection.ts: // GeoJsonGeometryCollection.ts import { GeoJsonPoint } from "./GeoJsonPoint.js"; import { GeoJsonLineString } from "./GeoJsonLineString.js"; import { GeoJsonPolygon } from "./GeoJsonPolygon.js"; import { GeoJsonMultiPoint } from "./GeoJsonMultiPoint.js"; import { GeoJsonMultiLineString } from "./GeoJsonMultiLineString.js"; import { GeoJsonMultiPolygon } from "./GeoJsonMultiPolygon.js"; export interface GeoJsonGeometryCollection { type: "GeometryCollection"; geometries: Array< | GeoJsonPoint | GeoJsonLineString | GeoJsonPolygon | GeoJsonMultiPoint | GeoJsonMultiLineString | GeoJsonMultiPolygon | GeoJsonGeometryCollection >; }
|   |       |   --- GeoJsonLineString.ts: // GeoJsonLineString.ts import { GeoJsonPoint } from "./GeoJsonPoint.js"; export interface GeoJsonLineString { type: "LineString"; coordinates: [number, number][]; // Array of [longitude, latitude] }
|   |       |   --- GeoJsonMultiLineString.ts: // GeoJsonMultiLineString.ts export interface GeoJsonMultiLineString { type: "MultiLineString"; coordinates: [number, number][][]; // Array of LineString coordinate arrays }
|   |       |   --- GeoJsonMultiPoint.ts: export interface GeoJsonMultiPoint { type: "MultiPoint"; coordinates: [number, number][]; // Array of [longitude, latitude] }
|   |       |   --- GeoJsonMultiPolygon.ts: // GeoJsonMultiPolygon.ts export interface GeoJsonMultiPolygon { type: "MultiPolygon"; coordinates: [number, number][][][]; // Array of Polygon coordinate arrays }
|   |       |   --- GeoJsonPoint.ts: // GeoJsonPoint.ts export interface GeoJsonPoint { type: "Point"; coordinates: [number, number]; // [longitude, latitude] }
|   |       |   --- GeoJsonPolygon.ts: export interface GeoJsonPolygon { type: "Polygon"; coordinates: [number, number][][]; // Array of linear rings, each ring is array of [longitude, latitude] }
|   |       |   --- index.ts: // Export all GeoJSON types export * from './GeoJsonPoint.js'; export * from './GeoJsonLineString.js'; export * from './GeoJsonPolygon.js'; export * from './GeoJsonMultiPoint.js'; export * from './GeoJsonMultiLineString.js'; export * from './GeoJsonMultiPolygon.js'; export * from './GeoJsonFeature.js'; export * from './GeoJsonFeatureCollection.js'; export * from './GeoJsonGeometryCollection.js';
|   |       +-- utils
|   |       |   --- TypeValidator.ts: // TypeValidator.ts
|   |       |   --- index.ts: // Utils index.ts
|   |       +-- writers
|   |       |   --- GeoWriter.ts: import { GeoJsonFeature, GeoJsonFeatureCollection } from "../types/index.js"; import { GeoConversionError } from "../errors/GeoConversionError.js"; import { Coordinate, GreatCircle, SmallCircle, Triangle } from "../../../index.js"; import { GeoRegistry } from "../readers/GeoRegistry.js"; export class GeoWriter { static write( source: Coordinate | GreatCircle | SmallCircle | Triangle ): GeoJsonFeature { if (!source) { throw new GeoConversionError( 'Invalid source object', 'unknown', 'GeoJSON' ); } try { return GeoRegistry.convert(source, 'Feature'); } catch (error) { throw new GeoConversionError( 'Failed to write GeoJSON feature', source.constructor.name, 'GeoJSON', error as Error ); } } static writeCollection( sources: Array<Coordinate | GreatCircle | SmallCircle | Triangle> ): GeoJsonFeature[] { if (!Array.isArray(sources)) { throw new GeoConversionError( 'Invalid source: expected array of geometry objects', 'unknown', 'GeoJSON' ); } try { return sources.map((source, index) => { try { return GeoWriter.write(source); } catch (error) { throw new GeoConversionError( `Failed to write feature at index ${index}`, source?.constructor?.name ?? 'unknown', 'GeoJSON', error as Error ); } }); } catch (error) { throw new GeoConversionError( 'Failed to write feature collection', 'unknown', 'GeoJSON', error as Error ); } } }
|   |       |   --- index.ts: // Writers index.ts
|   |       --- index.ts: // Main GeoJSON adapter index.ts
|   +-- core
|   |   +-- coordinate
|   |   |   --- CoordinateSystem.ts: import { Coordinate } from "../models/Coordinate.js"; import { Point } from "../models/Point.js"; export class CoordinateSystem { static fromCoordinate(coord: Coordinate): Point { const lat = coord.latitude * (Math.PI / 180); const lon = coord.longitude * (Math.PI / 180); return Point.at(lon, lat); } static fromPoint(point: Point): Coordinate { const lat = point.X * (180 / Math.PI); const lon = point.Y * (180 / Math.PI); return Coordinate.at(lat, lon); } }
|   |   +-- errors
|   |   |   --- GeoConversionError.ts: import { GeoError } from "./GeoError.js"; export class GeoConversionError extends GeoError { constructor( message: string, public readonly sourceType: string, public readonly targetType: string, cause?: Error ) { super(message, cause); } }
|   |   |   --- GeoError.ts: export abstract class GeoError extends Error { constructor( message: string, public readonly cause?: Error ) { super(message); this.name = this.constructor.name; } }
|   |   |   --- GeoValidationError.ts: import { GeoError } from "./GeoError.js"; export class GeoValidationError extends GeoError { constructor( message: string, public readonly validationType: string, public readonly invalidValue: any, cause?: Error ) { super(message, cause); } }
|   |   |   --- index.ts: export * from './GeoError.js'; export * from './GeoConversionError.js'; export * from './GeoValidationError.js';
|   |   \-- models
|   |       --- Angle.ts: import { Arc } from "./Arc.js"; import { Distance } from './Distance.js'; import { Sphere } from './Sphere.js'; export class Angle { constructor(public readonly degrees: number) { } toRadians(): number { return this.degrees * (Math.PI / 180); } normalize(): number { return ((this.degrees % 360) + 360) % 360; } static defineBy(a: Arc, b: Arc, c: Arc | Angle, aLength?: Distance, bLength?: Distance, cLength?: Distance): Angle { if (!aLength || !bLength || !cLength) { throw new Error("Length parameters are required"); } const radius = Sphere.getRadius().inMeters(); // Validate spherical triangle constraints const sides = [aLength.inMeters(), bLength.inMeters(), cLength.inMeters()]; // Check each side is positive if (sides.some(side => side <= 0)) { throw new Error("All sides of a spherical triangle must be positive"); } // Check spherical triangle inequality if (sides[0] + sides[1] <= sides[2] || sides[1] + sides[2] <= sides[0] || sides[0] + sides[2] <= sides[1]) { throw new Error("Triangle sides must satisfy the triangle inequality"); } // Check sides are less than a semicircle const halfCircle = Math.PI * radius; if (sides.some(side => side >= halfCircle)) { throw new Error("All sides must be less than half the great circle (π radians)"); } if (c instanceof Angle) { return Angle.defineByLawOfSines(c, bLength, cLength, radius); } else { return Angle.defineByLawOfCosines(aLength, bLength, cLength); } } private static defineByLawOfSines(angleC: Angle, bLength: Distance, cLength: Distance, radius: number): Angle { if (angleC.degrees <= 0 || angleC.degrees >= 180) { throw new Error("Angle must be between 0 and 180 degrees"); } const arcB = bLength.inMeters() / radius; const arcC = cLength.inMeters() / radius; const argument = (Math.sin(angleC.toRadians()) * Math.sin(arcB)) / Math.sin(arcC); if (Math.abs(argument) > 1) { throw new Error("Invalid triangle configuration: no solution exists for these measurements"); } const calculatedAngleDegrees = Math.asin(argument) * (180 / Math.PI); return new Angle(calculatedAngleDegrees); } private static defineByLawOfCosines(aLength: Distance, bLength: Distance, cLength: Distance): Angle { const cosC = ( Math.pow(aLength.inMeters(), 2) + Math.pow(bLength.inMeters(), 2) - Math.pow(cLength.inMeters(), 2) ) / (2 * aLength.inMeters() * bLength.inMeters()); if (Math.abs(cosC) > 1) { throw new Error("Invalid triangle configuration: no solution exists for these measurements"); } const calculatedAngleDegrees = Math.acos(cosC) * (180 / Math.PI); return new Angle(calculatedAngleDegrees); } toString(): string { return `Angle(${this.degrees} degrees)`; } }
|   |       --- Arc.ts: // Arc.ts import { Coordinate } from './Coordinate.js'; import { Distance } from './Distance.js'; import { Sphere } from './Sphere.js'; import { Angle } from './Angle.js'; export class Arc { private constructor( private readonly start: Coordinate, private readonly end: Coordinate, private readonly sphereRadius: Distance = Sphere.getRadius() ) {} static between(start: Coordinate, end: Coordinate): Arc { return new Arc(start, end); } static onSphere(sphereRadius: Distance): Arc { return new Arc(new Coordinate(0, 0), new Coordinate(0, 0), sphereRadius); } length(): Distance { if (!this.start || !this.end) { return new Distance(2 * Math.PI * this.sphereRadius.inMeters()); } // Handle dateline crossing let dLon = this.end.longitude - this.start.longitude; if (Math.abs(dLon) > 180) { dLon = dLon > 0 ? dLon - 360 : dLon + 360; } const lat1 = this.start.latitude * Math.PI / 180; const lat2 = this.end.latitude * Math.PI / 180; const dLonRad = dLon * Math.PI / 180; // Use Vincenty's formula for better accuracy const a = Math.cos(lat2) * Math.sin(dLonRad); const b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLonRad); const c = Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(dLonRad); const centralAngle = Math.atan2(Math.sqrt(a * a + b * b), c); return new Distance(this.sphereRadius.inMeters() * centralAngle); } interpolate(fraction: number): Coordinate | undefined { if (!this.start || !this.end) return undefined; if (fraction < 0 || fraction > 1) { throw new Error('Fraction must be between 0 and 1'); } if (fraction === 0) return this.start; if (fraction === 1) return this.end; // Handle dateline crossing let dLon = this.end.longitude - this.start.longitude; if (Math.abs(dLon) > 180) { dLon = dLon > 0 ? dLon - 360 : dLon + 360; } const lat1 = this.start.latitude * Math.PI / 180; const lon1 = this.start.longitude * Math.PI / 180; const lat2 = this.end.latitude * Math.PI / 180; const lon2 = (this.start.longitude + dLon) * Math.PI / 180; // Calculate central angle const d = 2 * Math.asin(Math.sqrt( Math.pow(Math.sin((lat2 - lat1) / 2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin((lon2 - lon1) / 2), 2) )); if (Math.abs(d) < 1e-10) return this.start; // Interpolation coefficients const a = Math.sin((1 - fraction) * d) / Math.sin(d); const b = Math.sin(fraction * d) / Math.sin(d); // Calculate interpolated point const x = a * Math.cos(lat1) * Math.cos(lon1) + b * Math.cos(lat2) * Math.cos(lon2); const y = a * Math.cos(lat1) * Math.sin(lon1) + b * Math.cos(lat2) * Math.sin(lon2); const z = a * Math.sin(lat1) + b * Math.sin(lat2); // Convert back to lat/lon const lat = Math.atan2(z, Math.sqrt(x * x + y * y)); const lon = Math.atan2(y, x); // Handle wrapping around the dateline let finalLon = lon * 180 / Math.PI; if (Math.abs(dLon) > 180) { if (finalLon < -180) finalLon += 360; if (finalLon > 180) finalLon -= 360; } return new Coordinate(lat * 180 / Math.PI, finalLon); } }
|   |       --- Azimuth.ts: import { Coordinate } from './Coordinate.js'; import { Angle } from './Angle.js'; import { CoordinateSystem } from '../coordinate/CoordinateSystem.js'; export class Azimuth { private constructor( private readonly start: Coordinate, private readonly end: Coordinate ) {} static from = (start: Coordinate) => ({ to: (end: Coordinate) => new Azimuth(start, end) }); forward = (): Angle => { const startPoint = CoordinateSystem.fromCoordinate(this.start); const endPoint = CoordinateSystem.fromCoordinate(this.end); const dLon = endPoint.X - startPoint.X; const y = Math.sin(dLon) * Math.cos(endPoint.Y); const x = Math.cos(startPoint.Y) * Math.sin(endPoint.Y) - Math.sin(startPoint.Y) * Math.cos(endPoint.Y) * Math.cos(dLon); const azimuthRadians = Math.atan2(y, x); const azimuthDegrees = (azimuthRadians * (180 / Math.PI) + 360) % 360; return new Angle(azimuthDegrees); }; reverse = (): Angle => { const forward = this.forward().degrees; return new Angle((forward + 180) % 360); }; toString = (): string => `Azimuth(${this.start} → ${this.end})`; }
|   |       --- Bearing.ts: import { Coordinate } from './Coordinate.js'; import { Angle } from './Angle.js'; import { Azimuth } from './Azimuth.js'; export class Bearing { private constructor( private readonly start: Coordinate, private readonly end: Coordinate ) {} static from = (start: Coordinate) => ({ to: (end: Coordinate) => new Bearing(start, end) }); initial = (): Angle => Azimuth.from(this.start).to(this.end).forward(); final = (): Angle => Azimuth.from(this.start).to(this.end).reverse(); toString = (): string => `Bearing(${this.start} → ${this.end})`; }
|   |       --- Circle.ts: // Circle.ts import { Coordinate } from './Coordinate.js'; import { Distance } from './Distance.js'; import { Sphere } from './Sphere.js'; import { Point } from './Point.js'; export abstract class Circle { protected constructor( protected readonly center: Coordinate, protected readonly sphereRadius: Distance = Sphere.getRadius() ) {} abstract circumference(): Distance; abstract area(): number; abstract generatePoints(numPoints?: number): Coordinate[]; getCenter(): Coordinate { return this.center; } getSphereRadius(): Distance { return this.sphereRadius; } }
|   |       --- Coordinate.ts: // Coordinate.ts export class Coordinate { public constructor( private readonly lat: number, private readonly lon: number, private readonly alt?: number, private readonly isRadians: boolean = false ) { if (!isRadians) { // Validate degrees if (lat < -90 || lat > 90) { throw new Error('Latitude must be between -90 and 90 degrees'); } if (lon < -180 || lon > 180) { throw new Error('Longitude must be between -180 and 180 degrees'); } } else { // Validate radians if (lat < -Math.PI/2 || lat > Math.PI/2) { throw new Error('Latitude must be between -π/2 and π/2 radians'); } if (lon < -Math.PI || lon > Math.PI) { throw new Error('Longitude must be between -π and π radians'); } } } // Factory methods for degrees (primary API) static at(lat: number, lon: number, alt?: number): Coordinate { return new Coordinate(lat, lon, alt, false); } // Factory methods for radians static fromRadians(lat: number, lon: number, alt?: number): Coordinate { return new Coordinate(lat, lon, alt, true); } // Getters in degrees (primary API) get latitude(): number { return this.isRadians ? this.toDegrees(this.lat) : this.lat; } get longitude(): number { return this.isRadians ? this.toDegrees(this.lon) : this.lon; } get altitude(): number | undefined { return this.alt; } // Getters in radians get latitudeRadians(): number { return this.isRadians ? this.lat : this.toRadians(this.lat); } get longitudeRadians(): number { return this.isRadians ? this.lon : this.toRadians(this.lon); } // GeoJSON format (lon/lat order) toGeoJSON(): [number, number] { return [this.longitude, this.latitude]; } static fromGeoJSON(coords: [number, number]): Coordinate { return Coordinate.at(coords[1], coords[0]); } // Internal conversion utilities private toRadians(degrees: number): number { return degrees * (Math.PI / 180); } private toDegrees(radians: number): number { return radians * (180 / Math.PI); } // Utility methods equals(other: Coordinate): boolean { // Compare in the same unit system if (this.isRadians === other.isRadians) { return this.lat === other.lat && this.lon === other.lon && this.alt === other.alt; } // Convert and compare if different unit systems return this.latitude === other.latitude && this.longitude === other.longitude && this.alt === other.alt; } toString(): string { if (this.isRadians) { return `(${this.lat.toFixed(6)}rad, ${this.lon.toFixed(6)}rad${ this.alt ? `, ${this.alt}m` : ''})`; } return `(${this.lat}°, ${this.lon}°${this.alt ? `, ${this.alt}m` : ''})`; } }
|   |       --- Distance.ts: // Angle.ts remains the same... // Distance.ts export class Distance { private static readonly METERS_TO_NM = 0.000539957; constructor(private readonly meters: number) {} inMeters(): number { return this.meters; } inKilometers(): number { return this.meters / 1000; } inCentimeters(): number { return this.meters * 100; } inMiles(): number { return this.meters * 0.000621371; } inFeet(): number { return this.meters * 3.28084; } inYards(): number { return this.meters * 1.09361; } inNauticalMiles(): number { return this.meters * Distance.METERS_TO_NM; } static fromMeters(meters: number): Distance { return new Distance(meters); } static fromKilometers(km: number): Distance { return new Distance(km * 1000); } static fromMiles(miles: number): Distance { return new Distance(miles / 0.000621371); } static fromNauticalMiles(nm: number): Distance { return new Distance(nm / Distance.METERS_TO_NM); } static fromFeet(feet: number): Distance { return new Distance(feet / 3.28084); } toString(): string { return `${this.inKilometers().toFixed(2)} km`; } toFormat(unit: 'km' | 'mi' | 'nm' | 'ft' | 'm'): string { switch(unit) { case 'km': return `${this.inKilometers().toFixed(2)} km`; case 'mi': return `${this.inMiles().toFixed(2)} mi`; case 'nm': return `${this.inNauticalMiles().toFixed(2)} nm`; case 'ft': return `${this.inFeet().toFixed(2)} ft`; case 'm': return `${this.inMeters().toFixed(2)} m`; } } }
|   |       --- GreatCircle.ts: // GreatCircle.ts import { Circle } from './Circle.js'; import { Coordinate } from './Coordinate.js'; import { Distance } from './Distance.js'; import { Sphere } from './Sphere.js'; import { Arc } from './Arc.js'; export class GreatCircle extends Circle { private readonly arc: Arc; private constructor( center: Coordinate, private readonly radius: Distance, sphereRadius: Distance = Sphere.getRadius() ) { super(center, sphereRadius); // Create an arc that represents this great circle const northPole = new Coordinate(90, center.longitude); this.arc = Arc.between(center, northPole); } static withCenter(center: Coordinate): GreatCircle { const sphereRadius = Sphere.getRadius(); return new GreatCircle(center, sphereRadius, sphereRadius); } circumference(): Distance { return new Distance(2 * Math.PI * this.sphereRadius.inMeters()); } area(): number { return 4 * Math.PI * Math.pow(this.sphereRadius.inMeters() / 1000, 2); } generatePoints(numPoints: number = 360): Coordinate[] { const points: Coordinate[] = []; for (let i = 0; i < numPoints; i++) { const fraction = i / numPoints; const point = this.arc.interpolate(fraction); if (point) points.push(point); } return points; } }
|   |       --- Point.ts: // Point.ts export class Point { private constructor( private readonly x: number, private readonly y: number, private readonly z?: number ) {} static at(x: number, y: number, z?: number): Point { return new Point(x, y, z); } static fromCoordinate(coord: Coordinate): Point { const [lat, lon] = coord.toRadians(); return new Point( Math.cos(lat) * Math.cos(lon), Math.cos(lat) * Math.sin(lon), Math.sin(lat) ); } toCoordinate(): Coordinate { const lat = Math.asin(this.z ?? Math.sin(0)); const lon = Math.atan2(this.y, this.x); return Coordinate.fromRadians(lat, lon); } get X(): number { return this.x; } get Y(): number { return this.y; } get Z(): number | undefined { return this.z; } equals(other: Point): boolean { const epsilon = 1e-10; // For floating-point comparisons return Math.abs(this.x - other.x) < epsilon && Math.abs(this.y - other.y) < epsilon && (this.z === undefined && other.z === undefined || this.z !== undefined && other.z !== undefined && Math.abs(this.z - other.z) < epsilon); } toString(): string { return `Point(${this.x}, ${this.y}${this.z ? `, ${this.z}` : ''})`; } }
|   |       --- Polygon.ts: import { CoordinateSystem } from "../coordinate/CoordinateSystem.js"; import { Coordinate } from "./Coordinate.js"; import { Point } from "./Point.js"; export class Polygon { constructor(private readonly vertices: Coordinate[]) { if (vertices.length < 3) { throw new Error("Polygon must have at least 3 vertices"); } } // Coordinate-based constructor static fromCoordinates = (coords: Coordinate[]): Polygon => new Polygon(coords); // Point-based constructor static fromPoints = (points: Point[]): Polygon => { const coords = points.map(p => CoordinateSystem.fromPoint(p) ); return new Polygon(coords); }; getVertices = (): Coordinate[] => this.vertices; rewind = (): Polygon => { const points = this.vertices.map(c => CoordinateSystem.fromCoordinate(c)); const fixed = this.ensureProperWindingPoints(points); return Polygon.fromPoints(fixed); }; private ensureProperWindingPoints = (points: Point[]): Point[] => { // Calculate the signed area let area = 0; for (let i = 0; i < points.length; i++) { const j = (i + 1) % points.length; area += points[i].X * points[j].Y - points[j].X * points[i].Y; } // If area is negative (clockwise), reverse the points if (area > 0) { return [...points].reverse(); } return points; }; toString = (): string => `Polygon(${this.vertices.length} vertices)`; }
|   |       --- SmallCircle.ts: // SmallCircle.ts import { Circle } from './Circle.js'; import { Coordinate } from './Coordinate.js'; import { Distance } from './Distance.js'; import { Sphere } from './Sphere.js'; export class SmallCircle extends Circle { private constructor( center: Coordinate, private readonly radius: Distance, sphereRadius: Distance = Sphere.getRadius() ) { super(center, sphereRadius); } static withCenter(center: Coordinate): { radius: (radius: Distance) => SmallCircle } { return { radius: (radius: Distance) => new SmallCircle(center, radius) }; } getRadius(): Distance { return this.radius; } circumference(): Distance { const angularRadius = this.radius.inMeters() / this.sphereRadius.inMeters(); return new Distance( 2 * Math.PI * this.sphereRadius.inMeters() * Math.sin(angularRadius) ); } area(): number { const angularRadius = this.radius.inMeters() / this.sphereRadius.inMeters(); const sphereRadiusKm = this.sphereRadius.inMeters() / 1000; return 2 * Math.PI * Math.pow(sphereRadiusKm, 2) * (1 - Math.cos(angularRadius)); } generatePoints(numPoints: number = 100): Coordinate[] { const points: Coordinate[] = []; const angularRadius = this.radius.inMeters() / this.sphereRadius.inMeters(); for (let i = 0; i <= numPoints; i++) { const angle = (2 * Math.PI * i) / numPoints; const latRad = Math.asin( Math.sin(this.center.latitude * Math.PI / 180) * Math.cos(angularRadius) + Math.cos(this.center.latitude * Math.PI / 180) * Math.sin(angularRadius) * Math.cos(angle) ); const lonRad = (this.center.longitude * Math.PI / 180) + Math.atan2( Math.sin(angle) * Math.sin(angularRadius) * Math.cos(this.center.latitude * Math.PI / 180), Math.cos(angularRadius) - Math.sin(this.center.latitude * Math.PI / 180) * Math.sin(latRad) ); // Handle dateline crossing let lon = lonRad * 180 / Math.PI; if (lon > 180) lon -= 360; if (lon < -180) lon += 360; points.push(new Coordinate(latRad * 180 / Math.PI, lon)); } return points; } }
|   |       --- Sphere.ts: import { Distance } from "./Distance.js"; export class Sphere { private static readonly DEFAULT_RADIUS = Distance.fromKilometers(6371); static getRadius = (radius?: Distance): Distance => radius ?? Sphere.DEFAULT_RADIUS; static surfaceAreaFromRadius = (radius: Distance): number => 4 * Math.PI * Math.pow(radius.inMeters() / 1000, 2); static volumeFromRadius = (radius: Distance): number => (4/3) * Math.PI * Math.pow(radius.inMeters() / 1000, 3); }
|   |       --- Triangle.ts: import { Coordinate } from './Coordinate.js'; import { Distance } from './Distance.js'; import { Angle } from './Angle.js'; import { Sphere } from './Sphere.js'; export class Triangle { private constructor( private readonly vertices: [Coordinate, Coordinate, Coordinate], private readonly sides: [Distance, Distance, Distance], private readonly angles: [Angle, Angle, Angle], private readonly sphereRadius: Distance = Sphere.getRadius() ) { this.validateTriangle(); } // Side-Angle-Side (SAS) static fromSAS( sideA: Distance, angleC: Angle, sideB: Distance, sphereRadius: Distance = Sphere.getRadius() ): Triangle { if (angleC.degrees <= 0 || angleC.degrees >= 180) { throw new Error("Included angle must be between 0° and 180°"); } // Convert sides to radians (arc lengths) const a = sideA.inMeters() / sphereRadius.inMeters(); const b = sideB.inMeters() / sphereRadius.inMeters(); const C = angleC.toRadians(); // Calculate third side using spherical law of cosines const cosc = Math.cos(a) * Math.cos(b) + Math.sin(a) * Math.sin(b) * Math.cos(C); const c = Math.acos(cosc); // Calculate remaining angles using spherical law of sines const sinA = Math.sin(C) * Math.sin(b) / Math.sin(c); const sinB = Math.sin(C) * Math.sin(a) / Math.sin(c); const A = new Angle(Math.asin(sinA) * (180 / Math.PI)); const B = new Angle(Math.asin(sinB) * (180 / Math.PI)); // Calculate vertices const vertices = Triangle.calculateVertices(a, b, c, A, B, angleC); return new Triangle( vertices, [sideA, sideB, new Distance(c * sphereRadius.inMeters())], [A, B, angleC], sphereRadius ); } // Side-Side-Side (SSS) static fromSSS( sideA: Distance, sideB: Distance, sideC: Distance, sphereRadius: Distance = Sphere.getRadius() ): Triangle { // Convert sides to radians const a = sideA.inMeters() / sphereRadius.inMeters(); const b = sideB.inMeters() / sphereRadius.inMeters(); const c = sideC.inMeters() / sphereRadius.inMeters(); // Validate triangle inequality on sphere if (a + b <= c || b + c <= a || c + a <= b) { throw new Error("Triangle sides must satisfy spherical triangle inequality"); } // Calculate angles using spherical law of cosines const cosA = (Math.cos(a) - Math.cos(b) * Math.cos(c)) / (Math.sin(b) * Math.sin(c)); const cosB = (Math.cos(b) - Math.cos(c) * Math.cos(a)) / (Math.sin(c) * Math.sin(a)); const cosC = (Math.cos(c) - Math.cos(a) * Math.cos(b)) / (Math.sin(a) * Math.sin(b)); const angles: [Angle, Angle, Angle] = [ new Angle(Math.acos(cosA) * (180 / Math.PI)), new Angle(Math.acos(cosB) * (180 / Math.PI)), new Angle(Math.acos(cosC) * (180 / Math.PI)) ]; // Calculate vertices const vertices = Triangle.calculateVertices(a, b, c, angles[0], angles[1], angles[2]); return new Triangle( vertices, [sideA, sideB, sideC], angles, sphereRadius ); } // Angle-Angle-Side (AAS) static fromAAS( angleA: Angle, angleB: Angle, sideC: Distance, sphereRadius: Distance = Sphere.getRadius() ): Triangle { // Calculate third angle const C = new Angle(180 - (angleA.degrees + angleB.degrees)); if (C.degrees <= 0) { throw new Error("Sum of angles must be less than 180°"); } // Convert side to radians const c = sideC.inMeters() / sphereRadius.inMeters(); // Calculate remaining sides using law of sines const sinA = Math.sin(angleA.toRadians()); const sinB = Math.sin(angleB.toRadians()); const sinC = Math.sin(C.toRadians()); const a = Math.asin(Math.sin(c) * sinA / sinC); const b = Math.asin(Math.sin(c) * sinB / sinC); // Calculate vertices const vertices = Triangle.calculateVertices(a, b, c, angleA, angleB, C); return new Triangle( vertices, [new Distance(a * sphereRadius.inMeters()), new Distance(b * sphereRadius.inMeters()), sideC], [angleA, angleB, C], sphereRadius ); } // Angle-Side-Angle (ASA) static fromASA( angleA: Angle, sideB: Distance, angleC: Angle, sphereRadius: Distance = Sphere.getRadius() ): Triangle { // Calculate third angle const B = new Angle(180 - (angleA.degrees + angleC.degrees)); if (B.degrees <= 0) { throw new Error("Sum of angles must be less than 180°"); } // Convert known side to radians const b = sideB.inMeters() / sphereRadius.inMeters(); // Calculate remaining sides using law of sines const sinA = Math.sin(angleA.toRadians()); const sinB = Math.sin(B.toRadians()); const sinC = Math.sin(angleC.toRadians()); const a = Math.asin(Math.sin(b) * sinA / sinB); const c = Math.asin(Math.sin(b) * sinC / sinB); // Calculate vertices const vertices = Triangle.calculateVertices(a, b, c, angleA, B, angleC); return new Triangle( vertices, [new Distance(a * sphereRadius.inMeters()), sideB, new Distance(c * sphereRadius.inMeters())], [angleA, B, angleC], sphereRadius ); } private static calculateVertices( a: number, b: number, c: number, A: Angle, B: Angle, C: Angle ): [Coordinate, Coordinate, Coordinate] { // Place first vertex at (0, 0) const v1 = Coordinate.at(0, 0); // Place second vertex along prime meridian // Remember: Coordinate.at takes (latitude, longitude) const v2 = Coordinate.at(0, b * (180 / Math.PI)); // Calculate third vertex using spherical coordinates const lat3 = Math.asin( Math.sin(c) * Math.sin(C.toRadians()) ) * (180 / Math.PI); const lon3 = Math.atan2( Math.sin(c) * Math.cos(C.toRadians()), Math.cos(c) ) * (180 / Math.PI); const v3 = Coordinate.at(lat3, lon3); return [v1, v2, v3]; } private validateTriangle(): void { // Validate angles sum to less than 360° (spherical excess) const angleSum = this.angles.reduce((sum, angle) => sum + angle.degrees, 0); if (angleSum <= 180 || angleSum >= 540) { throw new Error("Sum of angles must be between 180° and 540° for a spherical triangle"); } // Validate sides against spherical triangle inequality const sides = this.sides.map(s => s.inMeters()); if (sides[0] + sides[1] <= sides[2] || sides[1] + sides[2] <= sides[0] || sides[2] + sides[0] <= sides[1]) { throw new Error("Triangle sides must satisfy spherical triangle inequality"); } } area(): number { // Calculate area using spherical excess formula const angleSum = this.angles.reduce((sum, angle) => sum + angle.degrees, 0); const sphericalExcess = (angleSum - 180) * (Math.PI / 180); return sphericalExcess * Math.pow(this.sphereRadius.inMeters() / 1000, 2); } perimeter(): Distance { return new Distance( this.sides.reduce((sum, side) => sum + side.inMeters(), 0) ); } getVertices(): [Coordinate, Coordinate, Coordinate] { return [...this.vertices]; } getSides(): [Distance, Distance, Distance] { return [...this.sides]; } getAngles(): [Angle, Angle, Angle] { return [...this.angles]; } getSphereRadius(): Distance { return this.sphereRadius; } }
|   +-- types
|   |   \-- geojson
|   |       --- feature.ts: // src/types/geojson/feature.ts import { GeoJsonPoint, GeoJsonLineString, GeoJsonPolygon, GeoJsonMultiPoint, GeoJsonMultiLineString, GeoJsonMultiPolygon, GeoJsonGeometryCollection } from './geometries.js'; export interface GeoJsonFeature<G extends | GeoJsonPoint | GeoJsonLineString | GeoJsonPolygon | GeoJsonMultiPoint | GeoJsonMultiLineString | GeoJsonMultiPolygon | GeoJsonGeometryCollection > { type: "Feature"; geometry: G; properties: { [key: string]: any }; } export interface GeoJsonFeatureCollection<G extends | GeoJsonPoint | GeoJsonLineString | GeoJsonPolygon | GeoJsonMultiPoint | GeoJsonMultiLineString | GeoJsonMultiPolygon | GeoJsonGeometryCollection > { type: "FeatureCollection"; features: Array<GeoJsonFeature<G>>; } // src/types/geojson/index.ts export * from './geometries.js'; export * from './feature.js';
|   |       --- geometries.ts: // src/types/geojson/geometries.ts export interface GeoJsonPoint { type: "Point"; coordinates: [number, number]; } export interface GeoJsonLineString { type: "LineString"; coordinates: [number, number][]; } export interface GeoJsonPolygon { type: "Polygon"; coordinates: [number, number][][]; } export interface GeoJsonMultiPoint { type: "MultiPoint"; coordinates: [number, number][]; } export interface GeoJsonMultiLineString { type: "MultiLineString"; coordinates: [number, number][][]; } export interface GeoJsonMultiPolygon { type: "MultiPolygon"; coordinates: [number, number][][][]; } export interface GeoJsonGeometryCollection { type: "GeometryCollection"; geometries: Array< | GeoJsonPoint | GeoJsonLineString | GeoJsonPolygon | GeoJsonMultiPoint | GeoJsonMultiLineString | GeoJsonMultiPolygon >; }
|   |       --- index.ts: <empty file>
|   --- index.ts: // Main entry point for the spherical geometry library // Export core models export * from './core/models/Angle.js'; export * from './core/models/Arc.js'; export * from './core/models/Azimuth.js'; export * from './core/models/Bearing.js'; export * from './core/models/Coordinate.js'; export * from './core/models/Distance.js'; export * from './core/models/GreatCircle.js'; export * from './core/models/Point.js'; export * from './core/models/Polygon.js'; export * from './core/models/SmallCircle.js'; export * from './core/models/Sphere.js'; export * from './core/models/SphericalTrigonometry.js'; export * from './core/models/Triangle.js'; // Export coordinate system utilities export * from './core/coordinate/CoordinateSystem.js'; // Export error types export * from './core/errors/GeoError.js'; export * from './core/errors/GeoConversionError.js'; export * from './core/errors/GeoValidationError.js'; // Export GeoJSON adapters export * from './adapters/geojson/Feature.js'; export * from './adapters/geojson/FeatureCollection.js'; export * from './adapters/geojson/GeoConverter.js'; export * from './adapters/geojson/TypeConverter.js'; export * from './adapters/geojson/TypeMapping.js';
